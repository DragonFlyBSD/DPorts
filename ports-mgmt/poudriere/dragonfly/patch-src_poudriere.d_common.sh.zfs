--- /dev/null	2012-11-24 04:15:22.498925541 +0100
+++ src/poudriere.d/common.sh.zfs	2012-11-24 14:39:04.000000000 +0100
@@ -0,0 +1,330 @@
+#!/bin/sh
+
+# zfs namespace
+NS="poudriere"
+
+zget() {
+	[ $# -ne 1 ] && eargs property
+	zfs get -H -o value ${NS}:${1} ${JAILFS}
+}
+
+zset() {
+	[ $# -ne 2 ] && eargs property value
+	zfs set ${NS}:$1="$2" ${JAILFS}
+}
+
+pzset() {
+	[ $# -ne 2 ] && eargs property value
+	zfs set ${NS}:$1="$2" ${PTFS}
+}
+
+pzget() {
+	[ $# -ne 1 ] && eargs property
+	zfs get -H -o value ${NS}:${1} ${PTFS}
+}
+
+zsnap() {
+	[ $# -ne 1 ] && eargs filesystem@snapname
+	zfs snapshot ${1}
+}
+
+zkill() {
+	[ $# -ne 1 ] && eargs filesystem@snapname
+	zfs destroy -r ${1}
+}
+
+zkillfs() {
+	[ $# -ne 2 ] && eargs filesystem jailport
+	zfs destroy -r ${1}
+}
+
+zdelete() {
+	[ $# -ne 2 ] && eargs filesystem subdirectory
+	zfs destroy -r ${1}/${2}
+}
+
+zrollback () {
+	[ $# -ne 1 ] && eargs filesystem@snapname
+	zfs rollback -R ${1}
+}
+
+zxdiff () {
+	[ $# -ne 2 ] && eargs filesystem@snapname filesystem
+	zfs diff -FH ${1} ${2}
+}
+
+jail_exists() {
+	[ $# -ne 1 ] && eargs jailname
+	zfs list -rt filesystem -H -o ${NS}:type,${NS}:name ${ZPOOL}${ZROOTFS} | \
+		awk -v n=$1 'BEGIN { ret = 1 } $1 == "rootfs" && $2 == n { ret = 0; } END { exit ret }' && return 0
+	return 1
+}
+
+jail_get_base() {
+	[ $# -ne 1 ] && eargs jailname
+	zfs list -rt filesystem -s name -H -o ${NS}:type,${NS}:name,mountpoint ${ZPOOL}${ZROOTFS} | \
+		awk -v n=$1 '$1 == "rootfs" && $2 == n  { print $3 }' | head -n 1
+}
+
+jail_get_version() {
+	[ $# -ne 1 ] && eargs jailname
+	zfs list -rt filesystem -s name -H -o ${NS}:type,${NS}:name,${NS}:version ${ZPOOL}${ZROOTFS} | \
+		awk -v n=$1 '$1 == "rootfs" && $2 == n { print $3 }' | head -n 1
+}
+
+jail_get_fs() {
+	[ $# -ne 1 ] && eargs jailname
+	zfs list -rt filesystem -s name -H -o ${NS}:type,${NS}:name,name ${ZPOOL}${ZROOTFS} | \
+		awk -v n=$1 '$1 == "rootfs" && $2 == n { print $3 }' | head -n 1
+}
+
+port_exists() {
+	[ $# -ne 1 ] && eargs portstree_name
+	zfs list -t filesystem -H -o ${NS}:type,${NS}:name,name | \
+		awk -v n=$1 'BEGIN { ret = 1 } $1 == "ports" && $2 == n { ret = 0; } END { exit ret }' && return 0
+	return 1
+}
+
+port_get_base() {
+	[ $# -ne 1 ] && eargs portstree_name
+	zfs list -t filesystem -H -o ${NS}:type,${NS}:name,mountpoint | \
+		awk -v n=$1 '$1 == "ports" && $2 == n { print $3 }'
+}
+
+port_get_fs() {
+	[ $# -ne 1 ] && eargs portstree_name
+	zfs list -t filesystem -H -o ${NS}:type,${NS}:name,name | \
+		awk -v n=$1 '$1 == "ports" && $2 == n { print $3 }'
+}
+
+get_data_dir() {
+	local data
+	if [ -n "${POUDRIERE_DATA}" ]; then
+		echo ${POUDRIERE_DATA}
+		return
+	fi
+	data=$(zfs list -rt filesystem -H -o ${NS}:type,mountpoint ${ZPOOL}${ZROOTFS} | awk '$1 == "data" { print $2 }' | head -n 1)
+	if [ -n "${data}" ]; then
+		echo $data
+		return
+	fi
+	zfs create -p -o ${NS}:type=data \
+		-o mountpoint=${BASEFS}/data \
+		${ZPOOL}${ZROOTFS}/data
+	echo "${BASEFS}/data"
+}
+
+jail_create_zfs() {
+	[ $# -ne 5 ] && eargs name version arch mountpoint fs
+	local name=$1
+	local version=$2
+	local arch=$3
+	local mnt=$( echo $4 | sed -e "s,//,/,g")
+	local fs=$5
+	msg_n "Creating ${name} fs..."
+	zfs create -p \
+		-o ${NS}:type=rootfs \
+		-o ${NS}:name=${name} \
+		-o ${NS}:version=${version} \
+		-o ${NS}:arch=${arch} \
+		-o mountpoint=${mnt} ${fs} || err 1 " Fail" && echo " done"
+}
+
+port_create_zfs() {
+	[ $# -ne 3 ] && eargs name mountpoint fs
+	local name=$1
+	local mnt=$( echo $2 | sed -e 's,//,/,g')
+	local fs=$3
+	msg_n "Creating ${name} fs..."
+	zfs create -p \
+		-o mountpoint=${mnt} \
+		-o ${NS}:type=ports \
+		-o ${NS}:name=${name} \
+		${fs} || err 1 " Fail" && echo " done"
+}
+
+start_builders() {
+	local arch=$(zget arch)
+	local version=$(zget version)
+	local j mnt fs name
+
+	zfs create -o canmount=off ${JAILFS}/build
+
+	for j in ${JOBS}; do
+		mnt="${JAILMNT}/build/${j}"
+		fs="${JAILFS}/build/${j}"
+		name="${JAILNAME}-job-${j}"
+		zset status "starting_jobs:${j}"
+		mkdir -p "${mnt}"
+		zfs clone -o mountpoint=${mnt} \
+			-o ${NS}:name=${name} \
+			-o ${NS}:type=rootfs \
+			-o ${NS}:arch=${arch} \
+			-o ${NS}:version=${version} \
+			${JAILFS}@prepkg ${fs}
+		zsnap ${fs}@prepkg
+		# Jail might be lingering from previous build. Already recursively
+		# destroyed all the builder datasets, so just try stopping the jail
+		# and ignore any errors
+		jail_soft_stop ${name} 2>&1 || :
+		MASTERMNT=${JAILMNT} JAILNAME=${name} JAILMNT=${mnt} JAILFS=${fs} do_jail_mounts 0
+		MASTERMNT=${JAILMNT} JAILNAME=${name} JAILMNT=${mnt} JAILFS=${fs} do_portbuild_mounts 0
+		MASTERMNT=${JAILMNT} JAILNAME=${name} JAILMNT=${mnt} JAILFS=${fs} jrun 0
+		JAILFS=${fs} zset status "idle:"
+	done
+}
+
+stop_builders() {
+	local j mnt
+
+	# wait for the last running processes
+	cat ${JAILMNT}/poudriere/var/run/*.pid 2>/dev/null | xargs pwait 2>/dev/null
+
+	msg "Stopping ${PARALLEL_JOBS} builders"
+
+	for j in ${JOBS}; do
+		jail_soft_stop ${JAILNAME}-job-${j} || :
+	done
+
+	mnt=`realpath ${JAILMNT}`
+	mount | awk -v mnt="${mnt}/build/" 'BEGIN{ gsub(/\//, "\\\/", mnt); } { if ($3 ~ mnt && $1 !~ /\/dev\/md/ ) { print $3 }}' |  sort -r | xargs umount -f 2>/dev/null || :
+
+	zdelete ${JAILFS} build 2>/dev/null || :
+
+	# No builders running, unset JOBS
+	JOBS=""
+}
+
+post_conf_check () {
+	[ -z ${ZPOOL} ] && err 1 "ZPOOL variable is not set"
+
+	# Test if spool exists
+	zpool list ${ZPOOL} >/dev/null 2>&1 || err 1 "No such zpool: ${ZPOOL}"
+	ZVERSION=$(zpool list -H -oversion ${ZPOOL})
+
+	# Pool version has now
+	if [ "${ZVERSION}" = "-" ]; then
+		ZVERSION=29
+	fi
+}
+
+print_ports_table () {
+	printf '%-20s %-10s\n' "PORTSTREE" "METHOD"
+	zfs list -t filesystem -H -o ${NS}:type,${NS}:name,${NS}:method | \
+		awk '$1 == "ports" {printf("%-20s %-10s\n",$2,$3) }'
+}
+
+print_jails_table () {
+	[ $# -ne 1 ] && eargs quiet
+	[ ${1} -eq 0] && printf '%-20s %-20s %-7s %-7s %-7s %-7s %-7s %-7s %-7s %s\n' "JAILNAME" "VERSION" "ARCH" "METHOD" "SUCCESS" "FAILED" "IGNORED" "SKIPPED" "QUEUED" "STATUS"
+	zfs list -rt filesystem -H \
+		-o ${NS}:type,${NS}:name,${NS}:version,${NS}:arch,${NS}:method,${NS}:stats_built,${NS}:stats_failed,${NS}:stats_ignored,${NS}:stats_skipped,${NS}:stats_queued,${NS}:status ${ZPOOL}${ZROOTFS} | \
+		awk '$1 == "rootfs" { printf("%-20s %-20s %-7s %-7s %-7s %-7s %-7s %-7s %-7s %s\n",$2, $3, $4, $5, $6, $7, $8, $9, $10, $11) }'
+}
+
+list_jail_info () {
+	[ $# -ne 2 ] && eargs num_queued num_to_build
+	zfs list -H -o ${NS}:type,${NS}:name,${NS}:version,${NS}:arch,${NS}:stats_built,${NS}:stats_failed,${NS}:stats_ignored,${NS}:stats_skipped,${NS}:status,${NS}:method ${JAILFS}| \
+		awk -v q="${1}" -v tb="${2}" '/^rootfs/  {
+			print "Jailname: " $2;
+			print "FreeBSD version: " $3;
+			print "FreeBSD arch: "$4;
+			print "install/update method: "$10;
+			print "Status: "$9;
+			print "Packages built: "$5;
+			print "Packages failed: "$6;
+			print "Packages ignored: "$7;
+			print "Packages skipped: "$8;
+			print "Packages queued: "q;
+			print "Packages to be built: "tb;
+		}'
+}
+
+mount_jailport() {
+	[ $# -ne 2 ] && eargs filesystem mountpoint
+	# no-op for ZFS
+}
+
+get_portsdir() {
+	[ $# -ne 1 ] && eargs porttree
+	local PD=`port_get_base ${PTNAME}`
+	[ -d "${PD}/ports" ] && PD="${PD}/ports"
+	echo ${PD}
+}
+
+check_jobs() {
+	case ${PARALLEL_JOBS} in
+	''|*[!0-9]*)
+		PARALLEL_JOBS=$(sysctl -n hw.ncpu)
+		;;
+	esac
+}
+
+build_queue() {
+
+	local activity j cnt mnt fs name pkgname
+
+	while :; do
+		activity=0
+		for j in ${JOBS}; do
+			mnt="${JAILMNT}/build/${j}"
+			fs="${JAILFS}/build/${j}"
+			name="${JAILNAME}-job-${j}"
+			if [ -f  "${JAILMNT}/poudriere/var/run/${j}.pid" ]; then
+				if pgrep -F "${JAILMNT}/poudriere/var/run/${j}.pid" >/dev/null 2>&1; then
+					continue
+				fi
+				build_stats
+				rm -f "${JAILMNT}/poudriere/var/run/${j}.pid"
+				JAILFS="${fs}" zset status "idle:"
+			fi
+			pkgname=$(next_in_queue)
+			if [ -z "${pkgname}" ]; then
+				# pool empty ?
+				[ $(stat -f '%z' ${JAILMNT}/poudriere/pool) -eq 2 ] && return
+				break
+			fi
+			activity=1
+			MASTERMNT=${JAILMNT} JAILNAME="${name}" JAILMNT="${mnt}" JAILFS="${fs}" \
+				MY_JOBID="${j}" \
+				build_pkg "${pkgname}" >/dev/null 2>&1 &
+			echo "$!" > ${JAILMNT}/poudriere/var/run/${j}.pid
+		done
+		# Sleep briefly if still waiting on builds, to save CPU
+		[ $activity -eq 0 ] && sleep 0.1
+	done
+}
+
+cleanup() {
+	[ -n "${CLEANED_UP}" ] && return 0
+	msg "Cleaning up"
+	# If this is a builder, don't cleanup, the master will handle that.
+	if [ -n "${MY_JOBID}" ]; then
+		[ -n "${PKGNAME}" ] && clean_pool ${PKGNAME} 1 || :
+		return 0
+
+	fi
+	# Prevent recursive cleanup on error
+	if [ -n "${CLEANING_UP}" ]; then
+		echo "Failure cleaning up. Giving up." >&2
+		return
+	fi
+	export CLEANING_UP=1
+	[ -z "${JAILNAME%-job-*}" ] && err 2 "Fail: Missing JAILNAME"
+	log_stop
+
+	if [ -d ${MASTERMNT:-${JAILMNT}}/poudriere/var/run ]; then
+		for pid in ${MASTERMNT:-${JAILMNT}}/poudriere/var/run/*.pid; do
+			# Ensure there is a pidfile to read or break
+			[ "${pid}" = "${MASTERMNT:-${JAILMNT}}/poudriere/var/run/*.pid" ] && break
+			pkill -15 -F ${pid} >/dev/null 2>&1 || :
+		done
+		wait
+	fi
+
+	zdelete ${JAILFS%/build/*} build 2>/dev/null || :
+	zkill ${JAILFS%/build/*}@prepkg 2>/dev/null || :
+	zkill ${JAILFS%/build/*}@preinst 2>/dev/null || :
+	jail_stop
+	export CLEANED_UP=1
+}
