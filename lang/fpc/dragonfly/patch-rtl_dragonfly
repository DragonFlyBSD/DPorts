diff -ur --unidirectional-new-file rtl/dragonfly.null/Makefile rtl/dragonfly/Makefile
--- rtl/dragonfly.null/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/Makefile	2014-11-19 00:13:06.000000000 +0100
@@ -0,0 +1,1436 @@
+#
+# Don't edit, this file is generated by FPCMake Version 2.0.0 [2013/10/30]
+#
+default: all
+MAKEFILETARGETS=x86_64-dragonfly
+BSDs = freebsd netbsd openbsd darwin dragonfly
+UNIXs = linux $(BSDs) solaris qnx haiku
+LIMIT83fs = go32v2 os2 emx watcom
+OSNeedsComspecToRunBatch = go32v2 watcom
+FORCE:
+.PHONY: FORCE
+override PATH:=$(patsubst %/,%,$(subst \,/,$(PATH)))
+ifneq ($(findstring darwin,$(OSTYPE)),)
+inUnix=1 #darwin
+SEARCHPATH:=$(filter-out .,$(subst :, ,$(PATH)))
+else
+ifeq ($(findstring ;,$(PATH)),)
+inUnix=1
+SEARCHPATH:=$(filter-out .,$(subst :, ,$(PATH)))
+else
+SEARCHPATH:=$(subst ;, ,$(PATH))
+endif
+endif
+SEARCHPATH+=$(patsubst %/,%,$(subst \,/,$(dir $(MAKE))))
+PWD:=$(strip $(wildcard $(addsuffix /pwd.exe,$(SEARCHPATH))))
+ifeq ($(PWD),)
+PWD:=$(strip $(wildcard $(addsuffix /pwd,$(SEARCHPATH))))
+ifeq ($(PWD),)
+$(error You need the GNU utils package to use this Makefile)
+else
+PWD:=$(firstword $(PWD))
+SRCEXEEXT=
+endif
+else
+PWD:=$(firstword $(PWD))
+SRCEXEEXT=.exe
+endif
+ifndef inUnix
+ifeq ($(OS),Windows_NT)
+inWinNT=1
+else
+ifdef OS2_SHELL
+inOS2=1
+endif
+endif
+else
+ifneq ($(findstring cygdrive,$(PATH)),)
+inCygWin=1
+endif
+endif
+ifdef inUnix
+SRCBATCHEXT=.sh
+else
+ifdef inOS2
+SRCBATCHEXT=.cmd
+else
+SRCBATCHEXT=.bat
+endif
+endif
+ifdef COMSPEC
+ifneq ($(findstring $(OS_SOURCE),$(OSNeedsComspecToRunBatch)),)
+ifndef RUNBATCH
+RUNBATCH=$(COMSPEC) /C
+endif
+endif
+endif
+ifdef inUnix
+PATHSEP=/
+else
+PATHSEP:=$(subst /,\,/)
+ifdef inCygWin
+PATHSEP=/
+endif
+endif
+ifdef PWD
+BASEDIR:=$(subst \,/,$(shell $(PWD)))
+ifdef inCygWin
+ifneq ($(findstring /cygdrive/,$(BASEDIR)),)
+BASENODIR:=$(patsubst /cygdrive%,%,$(BASEDIR))
+BASEDRIVE:=$(firstword $(subst /, ,$(BASENODIR)))
+BASEDIR:=$(subst /cygdrive/$(BASEDRIVE)/,$(BASEDRIVE):/,$(BASEDIR))
+endif
+endif
+else
+BASEDIR=.
+endif
+ifdef inOS2
+ifndef ECHO
+ECHO:=$(strip $(wildcard $(addsuffix /gecho$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(ECHO),)
+ECHO:=$(strip $(wildcard $(addsuffix /echo$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(ECHO),)
+ECHO=echo
+else
+ECHO:=$(firstword $(ECHO))
+endif
+else
+ECHO:=$(firstword $(ECHO))
+endif
+endif
+export ECHO
+endif
+override OS_TARGET_DEFAULT=dragonfly
+override DEFAULT_FPCDIR=../..
+ifndef FPC
+ifdef PP
+FPC=$(PP)
+endif
+endif
+ifndef FPC
+FPCPROG:=$(strip $(wildcard $(addsuffix /fpc$(SRCEXEEXT),$(SEARCHPATH))))
+ifneq ($(FPCPROG),)
+FPCPROG:=$(firstword $(FPCPROG))
+ifneq ($(CPU_TARGET),)
+FPC:=$(shell $(FPCPROG) -P$(CPU_TARGET) -PB)
+else
+FPC:=$(shell $(FPCPROG) -PB)
+endif
+ifneq ($(findstring Error,$(FPC)),)
+override FPC=$(firstword $(strip $(wildcard $(addsuffix /ppc386$(SRCEXEEXT),$(SEARCHPATH)))))
+else
+ifeq ($(strip $(wildcard $(FPC))),)
+FPC:=$(firstword $(FPCPROG))
+endif
+endif
+else
+override FPC=$(firstword $(strip $(wildcard $(addsuffix /ppc386$(SRCEXEEXT),$(SEARCHPATH)))))
+endif
+endif
+override FPC:=$(subst $(SRCEXEEXT),,$(FPC))
+override FPC:=$(subst \,/,$(FPC))$(SRCEXEEXT)
+FOUNDFPC:=$(strip $(wildcard $(FPC)))
+ifeq ($(FOUNDFPC),)
+FOUNDFPC=$(strip $(wildcard $(addsuffix /$(FPC),$(SEARCHPATH))))
+ifeq ($(FOUNDFPC),)
+$(error Compiler $(FPC) not found)
+endif
+endif
+ifndef FPC_COMPILERINFO
+FPC_COMPILERINFO:=$(shell $(FPC) -iVSPTPSOTO)
+endif
+ifndef FPC_VERSION
+FPC_VERSION:=$(word 1,$(FPC_COMPILERINFO))
+endif
+export FPC FPC_VERSION FPC_COMPILERINFO
+unexport CHECKDEPEND ALLDEPENDENCIES
+ifndef CPU_TARGET
+ifdef CPU_TARGET_DEFAULT
+CPU_TARGET=$(CPU_TARGET_DEFAULT)
+endif
+endif
+ifndef OS_TARGET
+ifdef OS_TARGET_DEFAULT
+OS_TARGET=$(OS_TARGET_DEFAULT)
+endif
+endif
+ifndef CPU_SOURCE
+CPU_SOURCE:=$(word 2,$(FPC_COMPILERINFO))
+endif
+ifndef CPU_TARGET
+CPU_TARGET:=$(word 3,$(FPC_COMPILERINFO))
+endif
+ifndef OS_SOURCE
+OS_SOURCE:=$(word 4,$(FPC_COMPILERINFO))
+endif
+ifndef OS_TARGET
+OS_TARGET:=$(word 5,$(FPC_COMPILERINFO))
+endif
+FULL_TARGET=$(CPU_TARGET)-$(OS_TARGET)
+FULL_SOURCE=$(CPU_SOURCE)-$(OS_SOURCE)
+ifeq ($(CPU_TARGET),armeb)
+ARCH=arm
+override FPCOPT+=-Cb
+else
+ifeq ($(CPU_TARGET),armel)
+ARCH=arm
+override FPCOPT+=-CaEABI
+else
+ARCH=$(CPU_TARGET)
+endif
+endif
+ifneq ($(findstring $(OS_SOURCE),$(LIMIT83fs)),)
+TARGETSUFFIX=$(OS_TARGET)
+SOURCESUFFIX=$(OS_SOURCE)
+else
+ifneq ($(findstring $(OS_TARGET),$(LIMIT83fs)),)
+TARGETSUFFIX=$(OS_TARGET)
+else
+TARGETSUFFIX=$(FULL_TARGET)
+endif
+SOURCESUFFIX=$(FULL_SOURCE)
+endif
+ifneq ($(FULL_TARGET),$(FULL_SOURCE))
+CROSSCOMPILE=1
+endif
+ifeq ($(findstring makefile,$(MAKECMDGOALS)),)
+ifeq ($(findstring $(FULL_TARGET),$(MAKEFILETARGETS)),)
+$(error The Makefile doesn't support target $(FULL_TARGET), please run fpcmake first)
+endif
+endif
+ifneq ($(findstring $(OS_TARGET),$(BSDs)),)
+BSDhier=1
+endif
+ifeq ($(OS_TARGET),linux)
+linuxHier=1
+endif
+export OS_TARGET OS_SOURCE ARCH CPU_TARGET CPU_SOURCE FULL_TARGET FULL_SOURCE TARGETSUFFIX SOURCESUFFIX CROSSCOMPILE
+ifdef FPCDIR
+override FPCDIR:=$(subst \,/,$(FPCDIR))
+ifeq ($(wildcard $(addprefix $(FPCDIR)/,rtl units)),)
+override FPCDIR=wrong
+endif
+else
+override FPCDIR=wrong
+endif
+ifdef DEFAULT_FPCDIR
+ifeq ($(FPCDIR),wrong)
+override FPCDIR:=$(subst \,/,$(DEFAULT_FPCDIR))
+ifeq ($(wildcard $(addprefix $(FPCDIR)/,rtl units)),)
+override FPCDIR=wrong
+endif
+endif
+endif
+ifeq ($(FPCDIR),wrong)
+ifdef inUnix
+override FPCDIR=/usr/local/lib/fpc/$(FPC_VERSION)
+ifeq ($(wildcard $(FPCDIR)/units),)
+override FPCDIR=/usr/lib/fpc/$(FPC_VERSION)
+endif
+else
+override FPCDIR:=$(subst /$(FPC),,$(firstword $(strip $(wildcard $(addsuffix /$(FPC),$(SEARCHPATH))))))
+override FPCDIR:=$(FPCDIR)/..
+ifeq ($(wildcard $(addprefix $(FPCDIR)/,rtl units)),)
+override FPCDIR:=$(FPCDIR)/..
+ifeq ($(wildcard $(addprefix $(FPCDIR)/,rtl units)),)
+override FPCDIR:=$(BASEDIR)
+ifeq ($(wildcard $(addprefix $(FPCDIR)/,rtl units)),)
+override FPCDIR=c:/pp
+endif
+endif
+endif
+endif
+endif
+ifndef CROSSBINDIR
+CROSSBINDIR:=$(wildcard $(FPCDIR)/bin/$(TARGETSUFFIX))
+endif
+ifneq ($(findstring $(OS_TARGET),darwin iphonesim),)
+ifeq ($(OS_SOURCE),darwin)
+DARWIN2DARWIN=1
+endif
+endif
+ifndef BINUTILSPREFIX
+ifndef CROSSBINDIR
+ifdef CROSSCOMPILE
+ifndef DARWIN2DARWIN
+BINUTILSPREFIX=$(CPU_TARGET)-$(OS_TARGET)-
+endif
+endif
+endif
+endif
+UNITSDIR:=$(wildcard $(FPCDIR)/units/$(TARGETSUFFIX))
+ifeq ($(UNITSDIR),)
+UNITSDIR:=$(wildcard $(FPCDIR)/units/$(OS_TARGET))
+endif
+PACKAGESDIR:=$(wildcard $(FPCDIR) $(FPCDIR)/packages $(FPCDIR)/packages/base $(FPCDIR)/packages/extra)
+ifndef FPCFPMAKE
+ifdef CROSSCOMPILE
+ifeq ($(strip $(wildcard $(addsuffix /compiler/ppc$(SRCEXEEXT),$(FPCDIR)))),)
+FPCPROG:=$(strip $(wildcard $(addsuffix /fpc$(SRCEXEEXT),$(SEARCHPATH))))
+ifneq ($(FPCPROG),)
+FPCPROG:=$(firstword $(FPCPROG))
+FPCFPMAKE:=$(shell $(FPCPROG) -PB)
+ifeq ($(strip $(wildcard $(FPCFPMAKE))),)
+FPCFPMAKE:=$(firstword $(FPCPROG))
+endif
+else
+override FPCFPMAKE=$(firstword $(strip $(wildcard $(addsuffix /ppc386$(SRCEXEEXT),$(SEARCHPATH)))))
+endif
+else
+FPCFPMAKE=$(strip $(wildcard $(addsuffix /compiler/ppc$(SRCEXEEXT),$(FPCDIR))))
+FPMAKE_SKIP_CONFIG=-n
+export FPCFPMAKE
+export FPMAKE_SKIP_CONFIG
+endif
+else
+FPMAKE_SKIP_CONFIG=-n
+FPCFPMAKE=$(FPC)
+endif
+endif
+override PACKAGE_NAME=rtl
+PACKAGEDIR_MAIN:=$(firstword $(subst /Makefile.fpc,,$(strip $(wildcard $(addsuffix /rtl/Makefile.fpc,$(PACKAGESDIR))))))
+RTL=..
+INC=$(RTL)/inc
+COMMON=$(RTL)/common
+PROCINC=$(RTL)/$(CPU_TARGET)
+OSPROCINC=$(RTL)/dragonfly/$(CPU_TARGET)
+BSDINC=$(RTL)/bsd
+BSDPROCINC=$(BSDINC)/$(CPU_TARGET)
+UNIXINC=$(RTL)/unix
+UNITPREFIX=rtl
+CPU_UNITS=
+ifeq ($(findstring 1.0.,$(FPC_VERSION)),)
+SYSTEMUNIT=system
+override FPCOPT+=-dNOMOUSE
+loaders+=gprt0
+else
+SYSTEMUNIT=sysbsd
+override FPCOPT+=-dUNIX -dNOMOUSE
+endif
+ifeq ($(ARCH),i386)
+CPU_UNITS=x86 ports cpu mmx
+endif
+ifeq ($(ARCH),x86_64)
+CPU_UNITS=x86 ports cpu
+endif
+ifdef RELEASE
+override FPCOPT+=-Ur
+endif
+OBJPASDIR=$(RTL)/objpas
+override INSTALL_FPCPACKAGE=y y
+ifeq ($(FULL_TARGET),x86_64-dragonfly)
+override TARGET_UNITS+=$(SYSTEMUNIT) unixtype ctypes objpas macpas iso7185 strings syscall sysctl  baseunix unixutil unix rtlconsts initc cmem matrix dl termio  printer sysutils varutils math variants typinfo types classes fgl fmtbcd dynlibs $(CPU_UNITS) charset ucomplex crt getopts heaptrc lnfodwrf lineinfo errors sockets ipc terminfo bsd video mouse keyboard console serial dateutils sysconst cthreads strutils convutils stdconvs dos objects cwstring fpintres clocale
+override TARGET_IMPLICITUNITS+=exeinfo
+override TARGET_LOADERS+=prt0 cprt0 gprt0 dllprt0
+override TARGET_RSTS+=math varutils typinfo classes variants dateutils sysconst
+override COMPILER_INCLUDEDIR+=$(INC) $(PROCINC) $(UNIXINC) $(BSDINC) $(BSDPROCINC) $(OSPROCINC)
+override COMPILER_SOURCEDIR+=$(INC) $(PROCINC) $(UNIXINC) $(BSDINC) $(COMMON)
+endif
+ifdef REQUIRE_UNITSDIR
+override UNITSDIR+=$(REQUIRE_UNITSDIR)
+endif
+ifdef REQUIRE_PACKAGESDIR
+override PACKAGESDIR+=$(REQUIRE_PACKAGESDIR)
+endif
+ifdef ZIPINSTALL
+ifneq ($(findstring $(OS_TARGET),$(UNIXs)),)
+UNIXHier=1
+endif
+else
+ifneq ($(findstring $(OS_SOURCE),$(UNIXs)),)
+UNIXHier=1
+endif
+endif
+ifndef INSTALL_PREFIX
+ifdef PREFIX
+INSTALL_PREFIX=$(PREFIX)
+endif
+endif
+ifndef INSTALL_PREFIX
+ifdef UNIXHier
+INSTALL_PREFIX=/usr/local
+else
+ifdef INSTALL_FPCPACKAGE
+INSTALL_BASEDIR:=/pp
+else
+INSTALL_BASEDIR:=/$(PACKAGE_NAME)
+endif
+endif
+endif
+export INSTALL_PREFIX
+ifdef INSTALL_FPCSUBDIR
+export INSTALL_FPCSUBDIR
+endif
+ifndef DIST_DESTDIR
+DIST_DESTDIR:=$(BASEDIR)
+endif
+export DIST_DESTDIR
+ifndef COMPILER_UNITTARGETDIR
+ifdef PACKAGEDIR_MAIN
+COMPILER_UNITTARGETDIR=$(PACKAGEDIR_MAIN)/units/$(TARGETSUFFIX)
+else
+COMPILER_UNITTARGETDIR=units/$(TARGETSUFFIX)
+endif
+endif
+ifndef COMPILER_TARGETDIR
+COMPILER_TARGETDIR=.
+endif
+ifndef INSTALL_BASEDIR
+ifdef UNIXHier
+ifdef INSTALL_FPCPACKAGE
+INSTALL_BASEDIR:=$(INSTALL_PREFIX)/lib/fpc/$(FPC_VERSION)
+else
+INSTALL_BASEDIR:=$(INSTALL_PREFIX)/lib/$(PACKAGE_NAME)
+endif
+else
+INSTALL_BASEDIR:=$(INSTALL_PREFIX)
+endif
+endif
+ifndef INSTALL_BINDIR
+ifdef UNIXHier
+INSTALL_BINDIR:=$(INSTALL_PREFIX)/bin
+else
+INSTALL_BINDIR:=$(INSTALL_BASEDIR)/bin
+ifdef INSTALL_FPCPACKAGE
+ifdef CROSSCOMPILE
+ifdef CROSSINSTALL
+INSTALL_BINDIR:=$(INSTALL_BINDIR)/$(SOURCESUFFIX)
+else
+INSTALL_BINDIR:=$(INSTALL_BINDIR)/$(TARGETSUFFIX)
+endif
+else
+INSTALL_BINDIR:=$(INSTALL_BINDIR)/$(TARGETSUFFIX)
+endif
+endif
+endif
+endif
+ifndef INSTALL_UNITDIR
+INSTALL_UNITDIR:=$(INSTALL_BASEDIR)/units/$(TARGETSUFFIX)
+ifdef INSTALL_FPCPACKAGE
+ifdef PACKAGE_NAME
+INSTALL_UNITDIR:=$(INSTALL_UNITDIR)/$(PACKAGE_NAME)
+endif
+endif
+endif
+ifndef INSTALL_LIBDIR
+ifdef UNIXHier
+INSTALL_LIBDIR:=$(INSTALL_PREFIX)/lib
+else
+INSTALL_LIBDIR:=$(INSTALL_UNITDIR)
+endif
+endif
+ifndef INSTALL_SOURCEDIR
+ifdef UNIXHier
+ifdef BSDhier
+SRCPREFIXDIR=share/src
+else
+ifdef linuxHier
+SRCPREFIXDIR=share/src
+else
+SRCPREFIXDIR=src
+endif
+endif
+ifdef INSTALL_FPCPACKAGE
+ifdef INSTALL_FPCSUBDIR
+INSTALL_SOURCEDIR:=$(INSTALL_PREFIX)/$(SRCPREFIXDIR)/fpc-$(FPC_VERSION)/$(INSTALL_FPCSUBDIR)/$(PACKAGE_NAME)
+else
+INSTALL_SOURCEDIR:=$(INSTALL_PREFIX)/$(SRCPREFIXDIR)/fpc-$(FPC_VERSION)/$(PACKAGE_NAME)
+endif
+else
+INSTALL_SOURCEDIR:=$(INSTALL_PREFIX)/$(SRCPREFIXDIR)/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
+endif
+else
+ifdef INSTALL_FPCPACKAGE
+ifdef INSTALL_FPCSUBDIR
+INSTALL_SOURCEDIR:=$(INSTALL_BASEDIR)/source/$(INSTALL_FPCSUBDIR)/$(PACKAGE_NAME)
+else
+INSTALL_SOURCEDIR:=$(INSTALL_BASEDIR)/source/$(PACKAGE_NAME)
+endif
+else
+INSTALL_SOURCEDIR:=$(INSTALL_BASEDIR)/source
+endif
+endif
+endif
+ifndef INSTALL_DOCDIR
+ifdef UNIXHier
+ifdef BSDhier
+DOCPREFIXDIR=share/doc
+else
+ifdef linuxHier
+DOCPREFIXDIR=share/doc
+else
+DOCPREFIXDIR=doc
+endif
+endif
+ifdef INSTALL_FPCPACKAGE
+INSTALL_DOCDIR:=$(INSTALL_PREFIX)/$(DOCPREFIXDIR)/fpc-$(FPC_VERSION)/$(PACKAGE_NAME)
+else
+INSTALL_DOCDIR:=$(INSTALL_PREFIX)/$(DOCPREFIXDIR)/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
+endif
+else
+ifdef INSTALL_FPCPACKAGE
+INSTALL_DOCDIR:=$(INSTALL_BASEDIR)/doc/$(PACKAGE_NAME)
+else
+INSTALL_DOCDIR:=$(INSTALL_BASEDIR)/doc
+endif
+endif
+endif
+ifndef INSTALL_EXAMPLEDIR
+ifdef UNIXHier
+ifdef INSTALL_FPCPACKAGE
+ifdef BSDhier
+INSTALL_EXAMPLEDIR:=$(INSTALL_PREFIX)/share/examples/fpc-$(FPC_VERSION)/$(PACKAGE_NAME)
+else
+ifdef linuxHier
+INSTALL_EXAMPLEDIR:=$(INSTALL_DOCDIR)/examples
+else
+INSTALL_EXAMPLEDIR:=$(INSTALL_PREFIX)/doc/fpc-$(FPC_VERSION)/examples/$(PACKAGE_NAME)
+endif
+endif
+else
+ifdef BSDhier
+INSTALL_EXAMPLEDIR:=$(INSTALL_PREFIX)/share/examples/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
+else
+ifdef linuxHier
+INSTALL_EXAMPLEDIR:=$(INSTALL_DOCDIR)/examples/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
+else
+INSTALL_EXAMPLEDIR:=$(INSTALL_PREFIX)/doc/$(PACKAGE_NAME)-$(PACKAGE_VERSION)
+endif
+endif
+endif
+else
+ifdef INSTALL_FPCPACKAGE
+INSTALL_EXAMPLEDIR:=$(INSTALL_BASEDIR)/examples/$(PACKAGE_NAME)
+else
+INSTALL_EXAMPLEDIR:=$(INSTALL_BASEDIR)/examples
+endif
+endif
+endif
+ifndef INSTALL_DATADIR
+INSTALL_DATADIR=$(INSTALL_BASEDIR)
+endif
+ifndef INSTALL_SHAREDDIR
+INSTALL_SHAREDDIR=$(INSTALL_PREFIX)/lib
+endif
+ifdef CROSSCOMPILE
+ifndef CROSSBINDIR
+CROSSBINDIR:=$(wildcard $(CROSSTARGETDIR)/bin/$(SOURCESUFFIX))
+ifeq ($(CROSSBINDIR),)
+CROSSBINDIR:=$(wildcard $(INSTALL_BASEDIR)/cross/$(TARGETSUFFIX)/bin/$(FULL_SOURCE))
+endif
+endif
+else
+CROSSBINDIR=
+endif
+BATCHEXT=.bat
+LOADEREXT=.as
+EXEEXT=.exe
+PPLEXT=.ppl
+PPUEXT=.ppu
+OEXT=.o
+ASMEXT=.s
+SMARTEXT=.sl
+STATICLIBEXT=.a
+SHAREDLIBEXT=.so
+SHAREDLIBPREFIX=libfp
+STATICLIBPREFIX=libp
+IMPORTLIBPREFIX=libimp
+RSTEXT=.rst
+EXEDBGEXT=.dbg
+ifeq ($(OS_TARGET),dragonfly)
+BATCHEXT=.sh
+EXEEXT=
+HASSHAREDLIB=1
+SHORTSUFFIX=df
+endif
+ifneq ($(findstring $(OS_SOURCE),$(LIMIT83fs)),)
+FPCMADE=fpcmade.$(SHORTSUFFIX)
+ZIPSUFFIX=$(SHORTSUFFIX)
+ZIPCROSSPREFIX=
+ZIPSOURCESUFFIX=src
+ZIPEXAMPLESUFFIX=exm
+else
+FPCMADE=fpcmade.$(TARGETSUFFIX)
+ZIPSOURCESUFFIX=.source
+ZIPEXAMPLESUFFIX=.examples
+ifdef CROSSCOMPILE
+ZIPSUFFIX=.$(SOURCESUFFIX)
+ZIPCROSSPREFIX=$(TARGETSUFFIX)-
+else
+ZIPSUFFIX=.$(TARGETSUFFIX)
+ZIPCROSSPREFIX=
+endif
+endif
+ifndef ECHO
+ECHO:=$(strip $(wildcard $(addsuffix /gecho$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(ECHO),)
+ECHO:=$(strip $(wildcard $(addsuffix /echo$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(ECHO),)
+ECHO= __missing_command_ECHO
+else
+ECHO:=$(firstword $(ECHO))
+endif
+else
+ECHO:=$(firstword $(ECHO))
+endif
+endif
+export ECHO
+ifndef DATE
+DATE:=$(strip $(wildcard $(addsuffix /gdate$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(DATE),)
+DATE:=$(strip $(wildcard $(addsuffix /date$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(DATE),)
+DATE= __missing_command_DATE
+else
+DATE:=$(firstword $(DATE))
+endif
+else
+DATE:=$(firstword $(DATE))
+endif
+endif
+export DATE
+ifndef GINSTALL
+GINSTALL:=$(strip $(wildcard $(addsuffix /ginstall$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(GINSTALL),)
+GINSTALL:=$(strip $(wildcard $(addsuffix /install$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(GINSTALL),)
+GINSTALL= __missing_command_GINSTALL
+else
+GINSTALL:=$(firstword $(GINSTALL))
+endif
+else
+GINSTALL:=$(firstword $(GINSTALL))
+endif
+endif
+export GINSTALL
+ifndef CPPROG
+CPPROG:=$(strip $(wildcard $(addsuffix /cp$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(CPPROG),)
+CPPROG= __missing_command_CPPROG
+else
+CPPROG:=$(firstword $(CPPROG))
+endif
+endif
+export CPPROG
+ifndef RMPROG
+RMPROG:=$(strip $(wildcard $(addsuffix /rm$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(RMPROG),)
+RMPROG= __missing_command_RMPROG
+else
+RMPROG:=$(firstword $(RMPROG))
+endif
+endif
+export RMPROG
+ifndef MVPROG
+MVPROG:=$(strip $(wildcard $(addsuffix /mv$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(MVPROG),)
+MVPROG= __missing_command_MVPROG
+else
+MVPROG:=$(firstword $(MVPROG))
+endif
+endif
+export MVPROG
+ifndef MKDIRPROG
+MKDIRPROG:=$(strip $(wildcard $(addsuffix /gmkdir$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(MKDIRPROG),)
+MKDIRPROG:=$(strip $(wildcard $(addsuffix /mkdir$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(MKDIRPROG),)
+MKDIRPROG= __missing_command_MKDIRPROG
+else
+MKDIRPROG:=$(firstword $(MKDIRPROG))
+endif
+else
+MKDIRPROG:=$(firstword $(MKDIRPROG))
+endif
+endif
+export MKDIRPROG
+ifndef ECHOREDIR
+ifndef inUnix
+ECHOREDIR=echo
+else
+ECHOREDIR=$(ECHO)
+endif
+endif
+ifndef COPY
+COPY:=$(CPPROG) -fp
+endif
+ifndef COPYTREE
+COPYTREE:=$(CPPROG) -Rfp
+endif
+ifndef MKDIRTREE
+MKDIRTREE:=$(MKDIRPROG) -p
+endif
+ifndef MOVE
+MOVE:=$(MVPROG) -f
+endif
+ifndef DEL
+DEL:=$(RMPROG) -f
+endif
+ifndef DELTREE
+DELTREE:=$(RMPROG) -rf
+endif
+ifndef INSTALL
+ifdef inUnix
+INSTALL:=$(GINSTALL) -c -m 644
+else
+INSTALL:=$(COPY)
+endif
+endif
+ifndef INSTALLEXE
+ifdef inUnix
+INSTALLEXE:=$(GINSTALL) -c -m 755
+else
+INSTALLEXE:=$(COPY)
+endif
+endif
+ifndef MKDIR
+MKDIR:=$(GINSTALL) -m 755 -d
+endif
+export ECHOREDIR COPY COPYTREE MOVE DEL DELTREE INSTALL INSTALLEXE MKDIR
+ifndef PPUMOVE
+PPUMOVE:=$(strip $(wildcard $(addsuffix /ppumove$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(PPUMOVE),)
+PPUMOVE= __missing_command_PPUMOVE
+else
+PPUMOVE:=$(firstword $(PPUMOVE))
+endif
+endif
+export PPUMOVE
+ifndef FPCMAKE
+FPCMAKE:=$(strip $(wildcard $(addsuffix /fpcmake$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(FPCMAKE),)
+FPCMAKE= __missing_command_FPCMAKE
+else
+FPCMAKE:=$(firstword $(FPCMAKE))
+endif
+endif
+export FPCMAKE
+ifndef ZIPPROG
+ZIPPROG:=$(strip $(wildcard $(addsuffix /zip$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(ZIPPROG),)
+ZIPPROG= __missing_command_ZIPPROG
+else
+ZIPPROG:=$(firstword $(ZIPPROG))
+endif
+endif
+export ZIPPROG
+ifndef TARPROG
+TARPROG:=$(strip $(wildcard $(addsuffix /gtar$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(TARPROG),)
+TARPROG:=$(strip $(wildcard $(addsuffix /tar$(SRCEXEEXT),$(SEARCHPATH))))
+ifeq ($(TARPROG),)
+TARPROG= __missing_command_TARPROG
+else
+TARPROG:=$(firstword $(TARPROG))
+endif
+else
+TARPROG:=$(firstword $(TARPROG))
+endif
+endif
+export TARPROG
+ASNAME=$(BINUTILSPREFIX)as
+LDNAME=$(BINUTILSPREFIX)ld
+ARNAME=$(BINUTILSPREFIX)ar
+RCNAME=$(BINUTILSPREFIX)rc
+ifndef ASPROG
+ifdef CROSSBINDIR
+ASPROG=$(CROSSBINDIR)/$(ASNAME)$(SRCEXEEXT)
+else
+ASPROG=$(ASNAME)
+endif
+endif
+ifndef LDPROG
+ifdef CROSSBINDIR
+LDPROG=$(CROSSBINDIR)/$(LDNAME)$(SRCEXEEXT)
+else
+LDPROG=$(LDNAME)
+endif
+endif
+ifndef RCPROG
+ifdef CROSSBINDIR
+RCPROG=$(CROSSBINDIR)/$(RCNAME)$(SRCEXEEXT)
+else
+RCPROG=$(RCNAME)
+endif
+endif
+ifndef ARPROG
+ifdef CROSSBINDIR
+ARPROG=$(CROSSBINDIR)/$(ARNAME)$(SRCEXEEXT)
+else
+ARPROG=$(ARNAME)
+endif
+endif
+AS=$(ASPROG)
+LD=$(LDPROG)
+RC=$(RCPROG)
+AR=$(ARPROG)
+PPAS=ppas$(SRCBATCHEXT)
+ifdef inUnix
+LDCONFIG=ldconfig
+else
+LDCONFIG=
+endif
+ifdef DATE
+DATESTR:=$(shell $(DATE) +%Y%m%d)
+else
+DATESTR=
+endif
+ZIPOPT=-9
+ZIPEXT=.zip
+ifeq ($(USETAR),bz2)
+TAROPT=vj
+TAREXT=.tar.bz2
+else
+TAROPT=vz
+TAREXT=.tar.gz
+endif
+ifndef NOCPUDEF
+override FPCOPTDEF=$(ARCH)
+endif
+ifneq ($(OS_TARGET),$(OS_SOURCE))
+override FPCOPT+=-T$(OS_TARGET)
+endif
+ifneq ($(CPU_TARGET),$(CPU_SOURCE))
+override FPCOPT+=-P$(ARCH)
+endif
+ifeq ($(OS_SOURCE),openbsd)
+override FPCOPT+=-FD$(NEW_BINUTILS_PATH)
+override FPCMAKEOPT+=-FD$(NEW_BINUTILS_PATH)
+endif
+ifndef CROSSBOOTSTRAP
+ifneq ($(BINUTILSPREFIX),)
+override FPCOPT+=-XP$(BINUTILSPREFIX)
+endif
+ifneq ($(BINUTILSPREFIX),)
+override FPCOPT+=-Xr$(RLINKPATH)
+endif
+endif
+ifndef CROSSCOMPILE
+ifneq ($(BINUTILSPREFIX),)
+override FPCMAKEOPT+=-XP$(BINUTILSPREFIX)
+endif
+endif
+ifdef UNITDIR
+override FPCOPT+=$(addprefix -Fu,$(UNITDIR))
+endif
+ifdef LIBDIR
+override FPCOPT+=$(addprefix -Fl,$(LIBDIR))
+endif
+ifdef OBJDIR
+override FPCOPT+=$(addprefix -Fo,$(OBJDIR))
+endif
+ifdef INCDIR
+override FPCOPT+=$(addprefix -Fi,$(INCDIR))
+endif
+ifdef LINKSMART
+override FPCOPT+=-XX
+endif
+ifdef CREATESMART
+override FPCOPT+=-CX
+endif
+ifdef DEBUG
+override FPCOPT+=-gl
+override FPCOPTDEF+=DEBUG
+endif
+ifdef RELEASE
+ifneq ($(findstring 2.0.,$(FPC_VERSION)),)
+ifeq ($(CPU_TARGET),i386)
+FPCCPUOPT:=-OG2p3
+endif
+ifeq ($(CPU_TARGET),powerpc)
+FPCCPUOPT:=-O1r
+endif
+else
+FPCCPUOPT:=-O2
+endif
+override FPCOPT+=-Ur -Xs $(FPCCPUOPT) -n
+override FPCOPTDEF+=RELEASE
+endif
+ifdef STRIP
+override FPCOPT+=-Xs
+endif
+ifdef OPTIMIZE
+override FPCOPT+=-O2
+endif
+ifdef VERBOSE
+override FPCOPT+=-vwni
+endif
+ifdef COMPILER_OPTIONS
+override FPCOPT+=$(COMPILER_OPTIONS)
+endif
+ifdef COMPILER_UNITDIR
+override FPCOPT+=$(addprefix -Fu,$(COMPILER_UNITDIR))
+endif
+ifdef COMPILER_LIBRARYDIR
+override FPCOPT+=$(addprefix -Fl,$(COMPILER_LIBRARYDIR))
+endif
+ifdef COMPILER_OBJECTDIR
+override FPCOPT+=$(addprefix -Fo,$(COMPILER_OBJECTDIR))
+endif
+ifdef COMPILER_INCLUDEDIR
+override FPCOPT+=$(addprefix -Fi,$(COMPILER_INCLUDEDIR))
+endif
+ifdef CROSSBINDIR
+override FPCOPT+=-FD$(CROSSBINDIR)
+endif
+ifdef COMPILER_TARGETDIR
+override FPCOPT+=-FE$(COMPILER_TARGETDIR)
+ifeq ($(COMPILER_TARGETDIR),.)
+override TARGETDIRPREFIX=
+else
+override TARGETDIRPREFIX=$(COMPILER_TARGETDIR)/
+endif
+endif
+ifdef COMPILER_UNITTARGETDIR
+override FPCOPT+=-FU$(COMPILER_UNITTARGETDIR)
+ifeq ($(COMPILER_UNITTARGETDIR),.)
+override UNITTARGETDIRPREFIX=
+else
+override UNITTARGETDIRPREFIX=$(COMPILER_UNITTARGETDIR)/
+endif
+else
+ifdef COMPILER_TARGETDIR
+override COMPILER_UNITTARGETDIR=$(COMPILER_TARGETDIR)
+override UNITTARGETDIRPREFIX=$(TARGETDIRPREFIX)
+endif
+endif
+ifdef CREATESHARED
+override FPCOPT+=-Cg
+ifeq ($(CPU_TARGET),i386)
+override FPCOPT+=-Aas
+endif
+endif
+ifeq ($(findstring 2.0.,$(FPC_VERSION)),)
+ifneq ($(findstring $(OS_TARGET),dragonfly freebsd openbsd netbsd linux solaris),)
+ifeq ($(CPU_TARGET),x86_64)
+override FPCOPT+=-Cg
+endif
+endif
+endif
+ifdef LINKSHARED
+endif
+ifdef OPT
+override FPCOPT+=$(OPT)
+endif
+ifdef FPCOPTDEF
+override FPCOPT+=$(addprefix -d,$(FPCOPTDEF))
+endif
+ifdef CFGFILE
+override FPCOPT+=@$(CFGFILE)
+endif
+ifdef USEENV
+override FPCEXTCMD:=$(FPCOPT)
+override FPCOPT:=!FPCEXTCMD
+export FPCEXTCMD
+endif
+override AFULL_TARGET=$(CPU_TARGET)-$(OS_TARGET)
+override AFULL_SOURCE=$(CPU_SOURCE)-$(OS_SOURCE)
+ifneq ($(AFULL_TARGET),$(AFULL_SOURCE))
+override ACROSSCOMPILE=1
+endif
+ifdef ACROSSCOMPILE
+override FPCOPT+=$(CROSSOPT)
+endif
+override COMPILER:=$(FPC) $(FPCOPT)
+ifeq (,$(findstring -s ,$(COMPILER)))
+EXECPPAS=
+else
+ifeq ($(FULL_SOURCE),$(FULL_TARGET))
+ifdef RUNBATCH
+EXECPPAS:=@$(RUNBATCH) $(PPAS)
+else
+EXECPPAS:=@$(PPAS)
+endif
+endif
+endif
+.PHONY: fpc_loaders
+ifneq ($(TARGET_LOADERS),)
+override ALLTARGET+=fpc_loaders
+override CLEANTARGET+=fpc_loaders_clean
+override INSTALLTARGET+=fpc_loaders_install
+override LOADEROFILES:=$(addsuffix $(OEXT),$(TARGET_LOADERS))
+endif
+%$(OEXT): %$(LOADEREXT)
+ifdef COMPILER_UNITTARGETDIR
+	$(AS) -o $(COMPILER_UNITTARGETDIR)/$*$(OEXT) $<
+else
+	$(AS) -o $*$(OEXT) $<
+endif
+fpc_loaders: $(COMPILER_UNITTARGETDIR) $(LOADEROFILES)
+fpc_loaders_clean:
+ifdef COMPILER_UNITTARGETDIR
+	-$(DEL) $(addprefix $(COMPILER_UNITTARGETDIR)/,$(LOADEROFILES))
+else
+	-$(DEL) $(LOADEROFILES)
+endif
+fpc_loaders_install:
+	$(MKDIR) $(INSTALL_UNITDIR)
+ifdef COMPILER_UNITTARGETDIR
+	$(INSTALL) $(addprefix $(COMPILER_UNITTARGETDIR)/,$(LOADEROFILES)) $(INSTALL_UNITDIR)
+else
+	$(INSTALL) $(LOADEROFILES) $(INSTALL_UNITDIR)
+endif
+.PHONY: fpc_units
+ifneq ($(TARGET_UNITS)$(TARGET_IMPLICITUNITS),)
+override ALLTARGET+=fpc_units
+override UNITPPUFILES=$(addsuffix $(PPUEXT),$(TARGET_UNITS))
+override IMPLICITUNITPPUFILES=$(addsuffix $(PPUEXT),$(TARGET_IMPLICITUNITS))
+override INSTALLPPUFILES+=$(UNITPPUFILES) $(IMPLICITUNITPPUFILES)
+override CLEANPPUFILES+=$(UNITPPUFILES) $(IMPLICITUNITPPUFILES)
+endif
+fpc_units: $(COMPILER_UNITTARGETDIR) $(UNITPPUFILES)
+ifdef TARGET_RSTS
+override RSTFILES=$(addsuffix $(RSTEXT),$(TARGET_RSTS))
+override CLEANRSTFILES+=$(RSTFILES)
+endif
+.PHONY: fpc_all fpc_smart fpc_debug fpc_release fpc_shared
+$(FPCMADE): $(ALLDEPENDENCIES) $(ALLTARGET)
+	@$(ECHOREDIR) Compiled > $(FPCMADE)
+fpc_all: $(FPCMADE)
+fpc_smart:
+	$(MAKE) all LINKSMART=1 CREATESMART=1
+fpc_debug:
+	$(MAKE) all DEBUG=1
+fpc_release:
+	$(MAKE) all RELEASE=1
+.SUFFIXES: $(EXEEXT) $(PPUEXT) $(OEXT) .pas .lpr .dpr .pp .rc .res
+$(COMPILER_UNITTARGETDIR):
+	$(MKDIRTREE) $(COMPILER_UNITTARGETDIR)
+$(COMPILER_TARGETDIR):
+	$(MKDIRTREE) $(COMPILER_TARGETDIR)
+%$(PPUEXT): %.pp
+	$(COMPILER) $<
+	$(EXECPPAS)
+%$(PPUEXT): %.pas
+	$(COMPILER) $<
+	$(EXECPPAS)
+%$(EXEEXT): %.pp
+	$(COMPILER) $<
+	$(EXECPPAS)
+%$(EXEEXT): %.pas
+	$(COMPILER) $<
+	$(EXECPPAS)
+%$(EXEEXT): %.lpr
+	$(COMPILER) $<
+	$(EXECPPAS)
+%$(EXEEXT): %.dpr
+	$(COMPILER) $<
+	$(EXECPPAS)
+%.res: %.rc
+	windres -i $< -o $@
+vpath %.pp $(COMPILER_SOURCEDIR) $(COMPILER_INCLUDEDIR)
+vpath %.pas $(COMPILER_SOURCEDIR) $(COMPILER_INCLUDEDIR)
+vpath %.lpr $(COMPILER_SOURCEDIR) $(COMPILER_INCLUDEDIR)
+vpath %.dpr $(COMPILER_SOURCEDIR) $(COMPILER_INCLUDEDIR)
+vpath %.inc $(COMPILER_INCLUDEDIR)
+vpath %$(OEXT) $(COMPILER_UNITTARGETDIR)
+vpath %$(PPUEXT) $(COMPILER_UNITTARGETDIR)
+.PHONY: fpc_shared
+override INSTALLTARGET+=fpc_shared_install
+ifndef SHARED_LIBVERSION
+SHARED_LIBVERSION=$(FPC_VERSION)
+endif
+ifndef SHARED_LIBNAME
+SHARED_LIBNAME=$(PACKAGE_NAME)
+endif
+ifndef SHARED_FULLNAME
+SHARED_FULLNAME=$(SHAREDLIBPREFIX)$(SHARED_LIBNAME)-$(SHARED_LIBVERSION)$(SHAREDLIBEXT)
+endif
+ifndef SHARED_LIBUNITS
+SHARED_LIBUNITS:=$(TARGET_UNITS) $(TARGET_IMPLICITUNITS)
+override SHARED_LIBUNITS:=$(filter-out $(INSTALL_BUILDUNIT),$(SHARED_LIBUNITS))
+endif
+fpc_shared:
+ifdef HASSHAREDLIB
+	$(MAKE) all CREATESHARED=1 LINKSHARED=1 CREATESMART=1
+ifneq ($(SHARED_BUILD),n)
+	$(PPUMOVE) -q $(SHARED_LIBUNITS) -i$(COMPILER_UNITTARGETDIR) -o$(SHARED_FULLNAME) -d$(COMPILER_UNITTARGETDIR)
+endif
+else
+	@$(ECHO) Shared Libraries not supported
+endif
+fpc_shared_install:
+ifneq ($(SHARED_BUILD),n)
+ifneq ($(SHARED_LIBUNITS),)
+ifneq ($(wildcard $(COMPILER_UNITTARGETDIR)/$(SHARED_FULLNAME)),)
+	$(INSTALL) $(COMPILER_UNITTARGETDIR)/$(SHARED_FULLNAME) $(INSTALL_SHAREDDIR)
+endif
+endif
+endif
+.PHONY: fpc_install fpc_sourceinstall fpc_exampleinstall
+ifdef INSTALL_UNITS
+override INSTALLPPUFILES+=$(addsuffix $(PPUEXT),$(INSTALL_UNITS))
+endif
+ifdef INSTALL_BUILDUNIT
+override INSTALLPPUFILES:=$(filter-out $(INSTALL_BUILDUNIT)$(PPUEXT),$(INSTALLPPUFILES))
+endif
+ifdef INSTALLPPUFILES
+override INSTALLPPULINKFILES:=$(subst $(PPUEXT),$(OEXT),$(INSTALLPPUFILES)) $(addprefix $(STATICLIBPREFIX),$(subst $(PPUEXT),$(STATICLIBEXT),$(INSTALLPPUFILES))) $(addprefix $(IMPORTLIBPREFIX),$(subst $(PPUEXT),$(STATICLIBEXT),$(INSTALLPPUFILES)))
+ifneq ($(UNITTARGETDIRPREFIX),)
+override INSTALLPPUFILES:=$(addprefix $(UNITTARGETDIRPREFIX),$(notdir $(INSTALLPPUFILES)))
+override INSTALLPPULINKFILES:=$(wildcard $(addprefix $(UNITTARGETDIRPREFIX),$(notdir $(INSTALLPPULINKFILES))))
+endif
+override INSTALL_CREATEPACKAGEFPC=1
+endif
+ifdef INSTALLEXEFILES
+ifneq ($(TARGETDIRPREFIX),)
+override INSTALLEXEFILES:=$(addprefix $(TARGETDIRPREFIX),$(notdir $(INSTALLEXEFILES)))
+endif
+endif
+fpc_install: all $(INSTALLTARGET)
+ifdef INSTALLEXEFILES
+	$(MKDIR) $(INSTALL_BINDIR)
+	$(INSTALLEXE) $(INSTALLEXEFILES) $(INSTALL_BINDIR)
+endif
+ifdef INSTALL_CREATEPACKAGEFPC
+ifdef FPCMAKE
+ifdef PACKAGE_VERSION
+ifneq ($(wildcard Makefile.fpc),)
+	$(FPCMAKE) -p -T$(CPU_TARGET)-$(OS_TARGET) Makefile.fpc
+	$(MKDIR) $(INSTALL_UNITDIR)
+	$(INSTALL) Package.fpc $(INSTALL_UNITDIR)
+endif
+endif
+endif
+endif
+ifdef INSTALLPPUFILES
+	$(MKDIR) $(INSTALL_UNITDIR)
+	$(INSTALL) $(INSTALLPPUFILES) $(INSTALL_UNITDIR)
+ifneq ($(INSTALLPPULINKFILES),)
+	$(INSTALL) $(INSTALLPPULINKFILES) $(INSTALL_UNITDIR)
+endif
+ifneq ($(wildcard $(LIB_FULLNAME)),)
+	$(MKDIR) $(INSTALL_LIBDIR)
+	$(INSTALL) $(LIB_FULLNAME) $(INSTALL_LIBDIR)
+ifdef inUnix
+	ln -sf $(LIB_FULLNAME) $(INSTALL_LIBDIR)/$(LIB_NAME)
+endif
+endif
+endif
+ifdef INSTALL_FILES
+	$(MKDIR) $(INSTALL_DATADIR)
+	$(INSTALL) $(INSTALL_FILES) $(INSTALL_DATADIR)
+endif
+fpc_sourceinstall: distclean
+	$(MKDIR) $(INSTALL_SOURCEDIR)
+	$(COPYTREE) $(BASEDIR)/* $(INSTALL_SOURCEDIR)
+fpc_exampleinstall: $(addsuffix _distclean,$(TARGET_EXAMPLEDIRS))
+ifdef HASEXAMPLES
+	$(MKDIR) $(INSTALL_EXAMPLEDIR)
+endif
+ifdef EXAMPLESOURCEFILES
+	$(COPY) $(EXAMPLESOURCEFILES) $(INSTALL_EXAMPLEDIR)
+endif
+ifdef TARGET_EXAMPLEDIRS
+	$(COPYTREE) $(addsuffix /*,$(TARGET_EXAMPLEDIRS)) $(INSTALL_EXAMPLEDIR)
+endif
+.PHONY: fpc_clean fpc_cleanall fpc_distclean
+ifdef EXEFILES
+override CLEANEXEFILES:=$(addprefix $(TARGETDIRPREFIX),$(CLEANEXEFILES))
+override CLEANEXEDBGFILES:=$(addprefix $(TARGETDIRPREFIX),$(CLEANEXEDBGFILES))
+endif
+ifdef CLEAN_PROGRAMS
+override CLEANEXEFILES+=$(addprefix $(TARGETDIRPREFIX),$(addsuffix $(EXEEXT), $(CLEAN_PROGRAMS)))
+override CLEANEXEDBGFILES+=$(addprefix $(TARGETDIRPREFIX),$(addsuffix $(EXEDBGEXT), $(CLEAN_PROGRAMS)))
+endif
+ifdef CLEAN_UNITS
+override CLEANPPUFILES+=$(addsuffix $(PPUEXT),$(CLEAN_UNITS))
+endif
+ifdef CLEANPPUFILES
+override CLEANPPULINKFILES:=$(subst $(PPUEXT),$(OEXT),$(CLEANPPUFILES)) $(addprefix $(STATICLIBPREFIX),$(subst $(PPUEXT),$(STATICLIBEXT),$(CLEANPPUFILES))) $(addprefix $(IMPORTLIBPREFIX),$(subst $(PPUEXT),$(STATICLIBEXT),$(CLEANPPUFILES)))
+ifdef DEBUGSYMEXT
+override CLEANPPULINKFILES+=$(subst $(PPUEXT),$(DEBUGSYMEXT),$(CLEANPPUFILES))
+endif
+override CLEANPPUFILES:=$(addprefix $(UNITTARGETDIRPREFIX),$(CLEANPPUFILES))
+override CLEANPPULINKFILES:=$(wildcard $(addprefix $(UNITTARGETDIRPREFIX),$(CLEANPPULINKFILES)))
+endif
+fpc_clean: $(CLEANTARGET)
+ifdef CLEANEXEFILES
+	-$(DEL) $(CLEANEXEFILES)
+endif
+ifdef CLEANEXEDBGFILES
+	-$(DELTREE) $(CLEANEXEDBGFILES)
+endif
+ifdef CLEANPPUFILES
+	-$(DEL) $(CLEANPPUFILES)
+endif
+ifneq ($(CLEANPPULINKFILES),)
+	-$(DEL) $(CLEANPPULINKFILES)
+endif
+ifdef CLEANRSTFILES
+	-$(DEL) $(addprefix $(UNITTARGETDIRPREFIX),$(CLEANRSTFILES))
+endif
+ifdef CLEAN_FILES
+	-$(DEL) $(CLEAN_FILES)
+endif
+ifdef LIB_NAME
+	-$(DEL) $(LIB_NAME) $(LIB_FULLNAME)
+endif
+	-$(DEL) $(FPCMADE) Package.fpc $(PPAS) script.res link.res $(FPCEXTFILE) $(REDIRFILE)
+	-$(DEL) *$(ASMEXT) *_ppas$(BATCHEXT)
+fpc_cleanall: $(CLEANTARGET)
+ifdef CLEANEXEFILES
+	-$(DEL) $(CLEANEXEFILES)
+endif
+ifdef COMPILER_UNITTARGETDIR
+ifdef CLEANPPUFILES
+	-$(DEL) $(CLEANPPUFILES)
+endif
+ifneq ($(CLEANPPULINKFILES),)
+	-$(DEL) $(CLEANPPULINKFILES)
+endif
+ifdef CLEANRSTFILES
+	-$(DEL) $(addprefix $(UNITTARGETDIRPREFIX),$(CLEANRSTFILES))
+endif
+endif
+ifdef CLEAN_FILES
+	-$(DEL) $(CLEAN_FILES)
+endif
+	-$(DELTREE) units
+	-$(DEL) *$(OEXT) *$(PPUEXT) *$(RSTEXT) *$(ASMEXT) *$(STATICLIBEXT) *$(SHAREDLIBEXT) *$(PPLEXT)
+ifneq ($(PPUEXT),.ppu)
+	-$(DEL) *.o *.ppu *.a
+endif
+	-$(DELTREE) *$(SMARTEXT)
+	-$(DEL) fpcmade.* Package.fpc $(PPAS) script.res link.res $(FPCEXTFILE) $(REDIRFILE)
+	-$(DEL) *_ppas$(BATCHEXT)
+ifdef AOUTEXT
+	-$(DEL) *$(AOUTEXT)
+endif
+ifdef DEBUGSYMEXT
+	-$(DEL) *$(DEBUGSYMEXT)
+endif
+fpc_distclean: cleanall
+.PHONY: fpc_baseinfo
+override INFORULES+=fpc_baseinfo
+fpc_baseinfo:
+	@$(ECHO)
+	@$(ECHO)  == Package info ==
+	@$(ECHO)  Package Name..... $(PACKAGE_NAME)
+	@$(ECHO)  Package Version.. $(PACKAGE_VERSION)
+	@$(ECHO)
+	@$(ECHO)  == Configuration info ==
+	@$(ECHO)
+	@$(ECHO)  FPC.......... $(FPC)
+	@$(ECHO)  FPC Version.. $(FPC_VERSION)
+	@$(ECHO)  Source CPU... $(CPU_SOURCE)
+	@$(ECHO)  Target CPU... $(CPU_TARGET)
+	@$(ECHO)  Source OS.... $(OS_SOURCE)
+	@$(ECHO)  Target OS.... $(OS_TARGET)
+	@$(ECHO)  Full Source.. $(FULL_SOURCE)
+	@$(ECHO)  Full Target.. $(FULL_TARGET)
+	@$(ECHO)  SourceSuffix. $(SOURCESUFFIX)
+	@$(ECHO)  TargetSuffix. $(TARGETSUFFIX)
+	@$(ECHO)  FPC fpmake... $(FPCFPMAKE)
+	@$(ECHO)
+	@$(ECHO)  == Directory info ==
+	@$(ECHO)
+	@$(ECHO)  Required pkgs... $(REQUIRE_PACKAGES)
+	@$(ECHO)
+	@$(ECHO)  Basedir......... $(BASEDIR)
+	@$(ECHO)  FPCDir.......... $(FPCDIR)
+	@$(ECHO)  CrossBinDir..... $(CROSSBINDIR)
+	@$(ECHO)  UnitsDir........ $(UNITSDIR)
+	@$(ECHO)  PackagesDir..... $(PACKAGESDIR)
+	@$(ECHO)
+	@$(ECHO)  GCC library..... $(GCCLIBDIR)
+	@$(ECHO)  Other library... $(OTHERLIBDIR)
+	@$(ECHO)
+	@$(ECHO)  == Tools info ==
+	@$(ECHO)
+	@$(ECHO)  As........ $(AS)
+	@$(ECHO)  Ld........ $(LD)
+	@$(ECHO)  Ar........ $(AR)
+	@$(ECHO)  Rc........ $(RC)
+	@$(ECHO)
+	@$(ECHO)  Mv........ $(MVPROG)
+	@$(ECHO)  Cp........ $(CPPROG)
+	@$(ECHO)  Rm........ $(RMPROG)
+	@$(ECHO)  GInstall.. $(GINSTALL)
+	@$(ECHO)  Echo...... $(ECHO)
+	@$(ECHO)  Shell..... $(SHELL)
+	@$(ECHO)  Date...... $(DATE)
+	@$(ECHO)  FPCMake... $(FPCMAKE)
+	@$(ECHO)  PPUMove... $(PPUMOVE)
+	@$(ECHO)  Zip....... $(ZIPPROG)
+	@$(ECHO)
+	@$(ECHO)  == Object info ==
+	@$(ECHO)
+	@$(ECHO)  Target Loaders........ $(TARGET_LOADERS)
+	@$(ECHO)  Target Units.......... $(TARGET_UNITS)
+	@$(ECHO)  Target Implicit Units. $(TARGET_IMPLICITUNITS)
+	@$(ECHO)  Target Programs....... $(TARGET_PROGRAMS)
+	@$(ECHO)  Target Dirs........... $(TARGET_DIRS)
+	@$(ECHO)  Target Examples....... $(TARGET_EXAMPLES)
+	@$(ECHO)  Target ExampleDirs.... $(TARGET_EXAMPLEDIRS)
+	@$(ECHO)
+	@$(ECHO)  Clean Units......... $(CLEAN_UNITS)
+	@$(ECHO)  Clean Files......... $(CLEAN_FILES)
+	@$(ECHO)
+	@$(ECHO)  Install Units....... $(INSTALL_UNITS)
+	@$(ECHO)  Install Files....... $(INSTALL_FILES)
+	@$(ECHO)
+	@$(ECHO)  == Install info ==
+	@$(ECHO)
+	@$(ECHO)  DateStr.............. $(DATESTR)
+	@$(ECHO)  ZipName.............. $(ZIPNAME)
+	@$(ECHO)  ZipPrefix............ $(ZIPPREFIX)
+	@$(ECHO)  ZipCrossPrefix....... $(ZIPCROSSPREFIX)
+	@$(ECHO)  ZipSuffix............ $(ZIPSUFFIX)
+	@$(ECHO)  FullZipName.......... $(FULLZIPNAME)
+	@$(ECHO)  Install FPC Package.. $(INSTALL_FPCPACKAGE)
+	@$(ECHO)
+	@$(ECHO)  Install base dir..... $(INSTALL_BASEDIR)
+	@$(ECHO)  Install binary dir... $(INSTALL_BINDIR)
+	@$(ECHO)  Install library dir.. $(INSTALL_LIBDIR)
+	@$(ECHO)  Install units dir.... $(INSTALL_UNITDIR)
+	@$(ECHO)  Install source dir... $(INSTALL_SOURCEDIR)
+	@$(ECHO)  Install doc dir...... $(INSTALL_DOCDIR)
+	@$(ECHO)  Install example dir.. $(INSTALL_EXAMPLEDIR)
+	@$(ECHO)  Install data dir..... $(INSTALL_DATADIR)
+	@$(ECHO)
+	@$(ECHO)  Dist destination dir. $(DIST_DESTDIR)
+	@$(ECHO)  Dist zip name........ $(DIST_ZIPNAME)
+	@$(ECHO)
+.PHONY: fpc_info
+fpc_info: $(INFORULES)
+.PHONY: fpc_makefile fpc_makefiles fpc_makefile_sub1 fpc_makefile_sub2 \
+	fpc_makefile_dirs
+fpc_makefile:
+	$(FPCMAKE) -w -T$(OS_TARGET) Makefile.fpc
+fpc_makefile_sub1:
+ifdef TARGET_DIRS
+	$(FPCMAKE) -w -T$(OS_TARGET) $(addsuffix /Makefile.fpc,$(TARGET_DIRS))
+endif
+ifdef TARGET_EXAMPLEDIRS
+	$(FPCMAKE) -w -T$(OS_TARGET) $(addsuffix /Makefile.fpc,$(TARGET_EXAMPLEDIRS))
+endif
+fpc_makefile_sub2: $(addsuffix _makefile_dirs,$(TARGET_DIRS) $(TARGET_EXAMPLEDIRS))
+fpc_makefile_dirs: fpc_makefile_sub1 fpc_makefile_sub2
+fpc_makefiles: fpc_makefile fpc_makefile_dirs
+all: fpc_all
+debug: fpc_debug
+smart: fpc_smart
+release: fpc_release
+units: fpc_units
+examples:
+shared: fpc_shared
+install: fpc_install
+sourceinstall: fpc_sourceinstall
+exampleinstall: fpc_exampleinstall
+distinstall:
+zipinstall:
+zipsourceinstall:
+zipexampleinstall:
+zipdistinstall:
+clean: fpc_clean
+distclean: fpc_distclean
+cleanall: fpc_cleanall
+info: fpc_info
+makefiles: fpc_makefiles
+.PHONY: all debug smart release units examples shared install sourceinstall exampleinstall distinstall zipinstall zipsourceinstall zipexampleinstall zipdistinstall clean distclean cleanall info makefiles
+ifneq ($(wildcard fpcmake.loc),)
+include fpcmake.loc
+endif
+.NOTPARALLEL:
+include $(INC)/makefile.inc
+SYSINCDEPS=$(addprefix $(INC)/,$(SYSINCNAMES))
+include $(PROCINC)/makefile.cpu
+SYSCPUDEPS=$(addprefix $(PROCINC)/,$(CPUINCNAMES))
+SYSDEPS=$(SYSINCDEPS) $(SYSCPUDEPS)
+prt0$(OEXT) : $(CPU_TARGET)/prt0.as
+	$(AS) -o $(UNITTARGETDIRPREFIX)prt0$(OEXT) $(CPU_TARGET)/prt0.as
+cprt0$(OEXT) : $(CPU_TARGET)/cprt0.as
+	$(AS) -o $(UNITTARGETDIRPREFIX)cprt0$(OEXT) $(CPU_TARGET)/cprt0.as
+gprt0$(OEXT) : $(CPU_TARGET)/gprt0.as
+	$(AS) -o $(UNITTARGETDIRPREFIX)gprt0$(OEXT) $(CPU_TARGET)/gprt0.as
+dllprt0$(OEXT) : $(CPU_TARGET)/dllprt0.as
+	$(AS) -o $(UNITTARGETDIRPREFIX)dllprt0$(OEXT) $(CPU_TARGET)/dllprt0.as
+$(SYSTEMUNIT)$(PPUEXT) : $(BSDINC)/$(SYSTEMUNIT).pp unxconst.inc $(SYSDEPS)
+	$(COMPILER) -Us -Sg $(BSDINC)/$(SYSTEMUNIT).pp
+objpas$(PPUEXT): $(OBJPASDIR)/objpas.pp $(INC)/except.inc $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) -I$(OBJPASDIR) $(OBJPASDIR)/objpas.pp
+dateutils$(PPUEXT): $(OBJPASDIR)/dateutils.pp baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) -I$(OBJPASDIR) $(OBJPASDIR)/dateutils.pp
+strings$(PPUEXT) : $(INC)/strings.pp $(INC)/stringsi.inc\
+		   $(PROCINC)/strings.inc $(PROCINC)/stringss.inc\
+		   $(SYSTEMUNIT)$(PPUEXT)
+unixtype$(PPUEXT): $(UNIXINC)/unixtype.pp $(UNIXINC)/ctypes.inc ptypes.inc $(SYSTEMUNIT)$(PPUEXT)
+baseunix$(PPUEXT) : errno.inc ptypes.inc $(UNIXINC)/ctypes.inc \
+  signal.inc $(UNIXINC)/bunxh.inc \
+  $(BSDINC)/bunxsysc.inc $(BSDPROCINC)/syscallh.inc sysnr.inc \
+  $(BSDINC)/ostypes.inc $(BSDINC)/osmacro.inc $(UNIXINC)/gensigset.inc \
+  $(UNIXINC)/genfuncs.inc sysctl$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+unix$(PPUEXT) : $(UNIXINC)/unix.pp strings$(PPUEXT) $(INC)/textrec.inc $(INC)/filerec.inc \
+		 unxconst.inc $(UNIXINC)/timezone.inc \
+		 unxfunc.inc baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+linux$(PPUEXT) : baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+dos$(PPUEXT) : $(UNIXINC)/dos.pp $(INC)/filerec.inc $(INC)/textrec.inc strings$(PPUEXT) \
+	       unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+crt$(PPUEXT) : $(UNIXINC)/crt.pp $(INC)/textrec.inc unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+objects$(PPUEXT) : $(INC)/objects.pp $(SYSTEMUNIT)$(PPUEXT)
+printer$(PPUEXT) : $(UNIXINC)/printer.pp $(INC)/textrec.inc unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+sysutils$(PPUEXT) : $(UNIXINC)/sysutils.pp $(wildcard $(OBJPASDIR)/sysutils/*.inc) \
+		    objpas$(PPUEXT) unix$(PPUEXT) errors$(PPUEXT) sysconst$(PPUEXT)
+	$(COMPILER) -Fi$(OBJPASDIR)/sysutils $(UNIXINC)/sysutils.pp
+rtlconsts$(PPUEXT) : $(OBJPASDIR)/rtlconsts.pp
+	$(COMPILER) $(OBJPASDIR)/rtlconsts.pp
+classes$(PPUEXT) : $(UNIXINC)/classes.pp $(wildcard $(OBJPASDIR)/classes/*.inc) \
+		   sysutils$(PPUEXT) typinfo$(PPUEXT) rtlconsts$(PPUEXT) fgl$(PPUEXT)
+	$(COMPILER) -Fi$(OBJPASDIR)/classes $(UNIXINC)/classes.pp
+fgl$(PPUEXT) : $(OBJPASDIR)/fgl.pp objpas$(PPUEXT) types$(PPUEXT) system$(PPUEXT) sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/fgl.pp
+typinfo$(PPUEXT): $(OBJPASDIR)/typinfo.pp objpas$(PPUEXT) rtlconsts$(PPUEXT)
+	$(COMPILER) -Sg $(OBJPASDIR)/typinfo.pp
+math$(PPUEXT): $(OBJPASDIR)/math.pp objpas$(PPUEXT) sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/math.pp
+gettext$(PPUEXT): $(OBJPASDIR)/gettext.pp objpas$(PPUEXT) sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/gettext.pp
+varutils$(PPUEXT) : $(OBJPASDIR)/cvarutil.inc $(OBJPASDIR)/varutils.inc \
+		    $(OBJPASDIR)/varutilh.inc varutils.pp
+	$(COMPILER) -I$(OBJPASDIR) $(UNIXINC)/varutils.pp
+fmtbcd$(PPUEXT) : $(OBJPASDIR)/fmtbcd.pp objpas$(PPUEXT) sysutils$(PPUEXT) variants$(PPUEXT) classes$(PPUEXT) system$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/fmtbcd.pp
+types$(PPUEXT) : $(OBJPASDIR)/types.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/types.pp
+sysconst$(PPUEXT) : $(OBJPASDIR)/sysconst.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/sysconst.pp
+macpas$(PPUEXT) : $(INC)/macpas.pp objpas$(PPUEXT) math$(PPUEXT)
+	$(COMPILER) $(INC)/macpas.pp $(REDIR)
+x86$(PPUEXT) : $(UNIXINC)/x86.pp $(SYSTEMUNIT)$(PPUEXT)
+ifeq ($(ARCH),x86_64)
+cpu$(PPUEXT) : $(PROCINC)/cpu.pp $(SYSTEMUNIT)$(PPUEXT) sysutils$(PPUEXT)
+else
+cpu$(PPUEXT) : $(PROCINC)/cpu.pp $(SYSTEMUNIT)$(PPUEXT)
+endif
+mmx$(PPUEXT) : $(PROCINC)/mmx.pp cpu$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+getopts$(PPUEXT) : $(INC)/getopts.pp $(SYSTEMUNIT)$(PPUEXT)
+heaptrc$(PPUEXT) : $(INC)/heaptrc.pp $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) -Sg $(INC)/heaptrc.pp
+lineinfo$(PPUEXT) : $(INC)/lineinfo.pp $(SYSTEMUNIT)$(PPUEXT)
+lnfodwrf$(PPUEXT) : $(INC)/lnfodwrf.pp $(SYSTEMUNIT)$(PPUEXT)
+charset$(PPUEXT) : $(INC)/charset.pp $(SYSTEMUNIT)$(PPUEXT)
+ucomplex$(PPUEXT) : $(INC)/ucomplex.pp math$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+sockets$(PPUEXT) : $(UNIXINC)/sockets.pp $(INC)/textrec.inc $(INC)/filerec.inc \
+		   unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+errors$(PPUEXT) : $(UNIXINC)/errors.pp strings$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+ipc$(PPUEXT) : $(UNIXINC)/ipc.pp unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+terminfo$(PPUEXT) : terminfo.pp unix$(PPUEXT)
+callspec$(PPUEXT) : $(INC)/callspec.pp $(SYSTEMUNIT)$(PPUEXT)
+cmem$(PPUEXT) : $(INC)/cmem.pp $(SYSTEMUNIT)$(PPUEXT)
+sysctl$(PPUEXT) : $(BSDINC)/sysctl.pp $(SYSTEMUNIT)$(PPUEXT) syscall$(PPUEXT)
+cthreads$(PPUEXT) : $(UNIXINC)/cthreads.pp $(SYSTEMUNIT)$(PPUEXT)
+strutils$(PPUEXT) : $(OBJPASDIR)/strutils.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+		    sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/strutils.pp
+convutils$(PPUEXT) : $(OBJPASDIR)/convutils.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+		    sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/convutils.pp
+stdconvs$(PPUEXT) : $(OBJPASDIR)/stdconvs.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+		    sysutils$(PPUEXT)
+	$(COMPILER) $(OBJPASDIR)/stdconvs.pp
+dynlibs$(PPUEXT) : $(INC)/dynlibs.pas $(UNIXINC)/dynlibs.inc dl$(PPUEXT) objpas$(PPUEXT)
+ctypes$(PPUEXT) :  $(INC)/ctypes.pp $(SYSTEMUNIT)$(PPUEXT)
+variants$(PPUEXT) : $(INC)/variants.pp sysutils$(PPUEXT) sysconst$(PPUEXT) varutils$(PPUEXT) typinfo$(PPUEXT) rtlconsts$(PPUEXT) math$(PPUEXT)
+	$(COMPILER) -Fi$(INC) $(INC)/variants.pp
+cwstring$(PPUEXT) : $(UNIXINC)/cwstring.pp $(SYSTEMUNIT)$(PPUEXT) sysutils$(PPUEXT) baseunix$(PPUEXT) unix$(PPUEXT) unixtype$(PPUEXT) ctypes$(PPUEXT)
diff -ur --unidirectional-new-file rtl/dragonfly.null/Makefile.fpc rtl/dragonfly/Makefile.fpc
--- rtl/dragonfly.null/Makefile.fpc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/Makefile.fpc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,288 @@
+#
+#   Makefile.fpc for Free Pascal DragonFly RTL
+#
+
+[package]
+main=rtl
+
+[install]
+fpcpackage=y
+
+[target]
+loaders=prt0 cprt0 gprt0 dllprt0
+units=$(SYSTEMUNIT) unixtype ctypes objpas macpas iso7185 \
+      strings syscall sysctl  baseunix unixutil \
+      unix rtlconsts initc cmem matrix \
+       dl termio  printer \
+      sysutils varutils math variants typinfo types classes fgl fmtbcd dynlibs \
+      $(CPU_UNITS) charset ucomplex crt getopts heaptrc lnfodwrf lineinfo \
+      errors sockets ipc terminfo bsd \
+      video mouse keyboard console serial dateutils \
+      sysconst cthreads strutils convutils stdconvs dos objects cwstring \
+      fpintres clocale
+implicitunits=exeinfo
+
+rsts=math varutils typinfo classes variants dateutils sysconst
+
+[require]
+nortl=y
+
+[install]
+fpcpackage=y
+
+[default]
+fpcdir=../..
+target=dragonfly
+
+[compiler]
+includedir=$(INC) $(PROCINC) $(UNIXINC) $(BSDINC) $(BSDPROCINC) $(OSPROCINC)
+sourcedir=$(INC) $(PROCINC) $(UNIXINC) $(BSDINC) $(COMMON)
+
+
+[lib]
+libname=libfprtl.so
+libversion=2.0.0
+libunits=$(SYSTEMUNIT) objpas strings \
+      unix  \
+      dos crt objects printer \
+      sysutils typinfo math \
+      $(CPU_UNITS) getopts heaptrc \
+      errors sockets ipc dynlibs
+
+[prerules]
+RTL=..
+INC=$(RTL)/inc
+COMMON=$(RTL)/common
+PROCINC=$(RTL)/$(CPU_TARGET)
+OSPROCINC=$(RTL)/dragonfly/$(CPU_TARGET)
+BSDINC=$(RTL)/bsd
+BSDPROCINC=$(BSDINC)/$(CPU_TARGET)
+UNIXINC=$(RTL)/unix
+UNITPREFIX=rtl
+CPU_UNITS=
+
+ifeq ($(findstring 1.0.,$(FPC_VERSION)),)
+SYSTEMUNIT=system
+override FPCOPT+=-dNOMOUSE
+loaders+=gprt0
+else
+SYSTEMUNIT=sysbsd
+override FPCOPT+=-dUNIX -dNOMOUSE
+endif
+
+ifeq ($(ARCH),x86_64)
+CPU_UNITS=x86 ports cpu
+endif
+
+
+# Use new feature from 1.0.5 version
+# that generates release PPU files
+# which will not be recompiled
+ifdef RELEASE
+override FPCOPT+=-Ur
+endif
+
+# Paths
+OBJPASDIR=$(RTL)/objpas
+
+[rules]
+.NOTPARALLEL:
+# Get the system independent include file names.
+# This will set the following variables :
+# SYSINCNAMES
+include $(INC)/makefile.inc
+SYSINCDEPS=$(addprefix $(INC)/,$(SYSINCNAMES))
+
+# Get the processor dependent include file names.
+# This will set the following variables :
+# CPUINCNAMES
+include $(PROCINC)/makefile.cpu
+SYSCPUDEPS=$(addprefix $(PROCINC)/,$(CPUINCNAMES))
+
+# Put system unit dependencies together.
+SYSDEPS=$(SYSINCDEPS) $(SYSCPUDEPS)
+
+
+#
+# Loaders
+#
+
+prt0$(OEXT) : $(CPU_TARGET)/prt0.as
+        $(AS) -o $(UNITTARGETDIRPREFIX)prt0$(OEXT) $(CPU_TARGET)/prt0.as
+
+cprt0$(OEXT) : $(CPU_TARGET)/cprt0.as
+        $(AS) -o $(UNITTARGETDIRPREFIX)cprt0$(OEXT) $(CPU_TARGET)/cprt0.as
+
+gprt0$(OEXT) : $(CPU_TARGET)/gprt0.as
+        $(AS) -o $(UNITTARGETDIRPREFIX)gprt0$(OEXT) $(CPU_TARGET)/gprt0.as
+
+dllprt0$(OEXT) : $(CPU_TARGET)/dllprt0.as
+        $(AS) -o $(UNITTARGETDIRPREFIX)dllprt0$(OEXT) $(CPU_TARGET)/dllprt0.as
+
+#
+# System Units (System, Objpas, Strings)
+#
+
+$(SYSTEMUNIT)$(PPUEXT) : $(BSDINC)/$(SYSTEMUNIT).pp unxconst.inc $(SYSDEPS)
+        $(COMPILER) -Us -Sg $(BSDINC)/$(SYSTEMUNIT).pp
+
+objpas$(PPUEXT): $(OBJPASDIR)/objpas.pp $(INC)/except.inc $(SYSTEMUNIT)$(PPUEXT)
+        $(COMPILER) -I$(OBJPASDIR) $(OBJPASDIR)/objpas.pp
+
+
+dateutils$(PPUEXT): $(OBJPASDIR)/dateutils.pp baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+	$(COMPILER) -I$(OBJPASDIR) $(OBJPASDIR)/dateutils.pp
+
+
+strings$(PPUEXT) : $(INC)/strings.pp $(INC)/stringsi.inc\
+                   $(PROCINC)/strings.inc $(PROCINC)/stringss.inc\
+                   $(SYSTEMUNIT)$(PPUEXT)
+
+#
+# System Dependent Units
+#
+
+unixtype$(PPUEXT): $(UNIXINC)/unixtype.pp $(UNIXINC)/ctypes.inc ptypes.inc $(SYSTEMUNIT)$(PPUEXT)
+
+baseunix$(PPUEXT) : errno.inc ptypes.inc $(UNIXINC)/ctypes.inc \
+  $(CPU_TARGET)/signal.inc $(UNIXINC)/bunxh.inc \
+  $(BSDINC)/bunxsysc.inc $(BSDPROCINC)/syscallh.inc sysnr.inc \
+  $(BSDINC)/ostypes.inc $(BSDINC)/osmacro.inc $(UNIXINC)/gensigset.inc \
+  $(UNIXINC)/genfuncs.inc sysctl$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+
+unix$(PPUEXT) : $(UNIXINC)/unix.pp strings$(PPUEXT) $(INC)/textrec.inc $(INC)/filerec.inc \
+                 unxconst.inc $(UNIXINC)/timezone.inc \
+                 unxfunc.inc baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+linux$(PPUEXT) : baseunix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+#
+# TP7 Compatible RTL Units
+#
+
+dos$(PPUEXT) : $(UNIXINC)/dos.pp $(INC)/filerec.inc $(INC)/textrec.inc strings$(PPUEXT) \
+               unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+crt$(PPUEXT) : $(UNIXINC)/crt.pp $(INC)/textrec.inc unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+objects$(PPUEXT) : $(INC)/objects.pp $(SYSTEMUNIT)$(PPUEXT)
+
+printer$(PPUEXT) : $(UNIXINC)/printer.pp $(INC)/textrec.inc unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+#
+# Delphi Compatible Units
+#
+
+sysutils$(PPUEXT) : $(UNIXINC)/sysutils.pp $(wildcard $(OBJPASDIR)/sysutils/*.inc) \
+                    objpas$(PPUEXT) unix$(PPUEXT) errors$(PPUEXT) sysconst$(PPUEXT)
+        $(COMPILER) -Fi$(OBJPASDIR)/sysutils $(UNIXINC)/sysutils.pp
+
+rtlconsts$(PPUEXT) : $(OBJPASDIR)/rtlconsts.pp
+	$(COMPILER) $(OBJPASDIR)/rtlconsts.pp
+
+classes$(PPUEXT) : $(UNIXINC)/classes.pp $(wildcard $(OBJPASDIR)/classes/*.inc) \
+                   sysutils$(PPUEXT) typinfo$(PPUEXT) rtlconsts$(PPUEXT) fgl$(PPUEXT)
+        $(COMPILER) -Fi$(OBJPASDIR)/classes $(UNIXINC)/classes.pp
+
+fgl$(PPUEXT) : $(OBJPASDIR)/fgl.pp objpas$(PPUEXT) types$(PPUEXT) system$(PPUEXT) sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/fgl.pp
+
+typinfo$(PPUEXT): $(OBJPASDIR)/typinfo.pp objpas$(PPUEXT) rtlconsts$(PPUEXT)
+        $(COMPILER) -Sg $(OBJPASDIR)/typinfo.pp
+
+math$(PPUEXT): $(OBJPASDIR)/math.pp objpas$(PPUEXT) sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/math.pp
+
+gettext$(PPUEXT): $(OBJPASDIR)/gettext.pp objpas$(PPUEXT) sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/gettext.pp
+
+varutils$(PPUEXT) : $(OBJPASDIR)/cvarutil.inc $(OBJPASDIR)/varutils.inc \
+                    $(OBJPASDIR)/varutilh.inc varutils.pp
+        $(COMPILER) -I$(OBJPASDIR) $(UNIXINC)/varutils.pp
+
+fmtbcd$(PPUEXT) : $(OBJPASDIR)/fmtbcd.pp objpas$(PPUEXT) sysutils$(PPUEXT) variants$(PPUEXT) classes$(PPUEXT) system$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/fmtbcd.pp
+
+types$(PPUEXT) : $(OBJPASDIR)/types.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/types.pp
+
+sysconst$(PPUEXT) : $(OBJPASDIR)/sysconst.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/sysconst.pp
+
+#
+# Mac Pascal Model
+#
+
+macpas$(PPUEXT) : $(INC)/macpas.pp objpas$(PPUEXT) math$(PPUEXT)
+        $(COMPILER) $(INC)/macpas.pp $(REDIR)
+
+#
+# Other system-independent RTL Units
+#
+
+x86$(PPUEXT) : $(UNIXINC)/x86.pp $(SYSTEMUNIT)$(PPUEXT)
+
+ifeq ($(ARCH),x86_64)
+cpu$(PPUEXT) : $(PROCINC)/cpu.pp $(SYSTEMUNIT)$(PPUEXT) sysutils$(PPUEXT)
+else
+cpu$(PPUEXT) : $(PROCINC)/cpu.pp $(SYSTEMUNIT)$(PPUEXT)
+endif
+
+mmx$(PPUEXT) : $(PROCINC)/mmx.pp cpu$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+getopts$(PPUEXT) : $(INC)/getopts.pp $(SYSTEMUNIT)$(PPUEXT)
+
+heaptrc$(PPUEXT) : $(INC)/heaptrc.pp $(SYSTEMUNIT)$(PPUEXT)
+        $(COMPILER) -Sg $(INC)/heaptrc.pp
+
+lineinfo$(PPUEXT) : $(INC)/lineinfo.pp $(SYSTEMUNIT)$(PPUEXT)
+
+lnfodwrf$(PPUEXT) : $(INC)/lnfodwrf.pp $(SYSTEMUNIT)$(PPUEXT)
+
+charset$(PPUEXT) : $(INC)/charset.pp $(SYSTEMUNIT)$(PPUEXT)
+
+ucomplex$(PPUEXT) : $(INC)/ucomplex.pp math$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+#
+# Other system-dependent RTL Units
+#
+
+sockets$(PPUEXT) : $(UNIXINC)/sockets.pp $(INC)/textrec.inc $(INC)/filerec.inc \
+                   unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+errors$(PPUEXT) : $(UNIXINC)/errors.pp strings$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+ipc$(PPUEXT) : $(UNIXINC)/ipc.pp unix$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT)
+
+terminfo$(PPUEXT) : terminfo.pp unix$(PPUEXT)
+
+callspec$(PPUEXT) : $(INC)/callspec.pp $(SYSTEMUNIT)$(PPUEXT)
+
+cmem$(PPUEXT) : $(INC)/cmem.pp $(SYSTEMUNIT)$(PPUEXT)
+
+sysctl$(PPUEXT) : $(BSDINC)/sysctl.pp $(SYSTEMUNIT)$(PPUEXT) syscall$(PPUEXT)
+
+cthreads$(PPUEXT) : $(UNIXINC)/cthreads.pp $(SYSTEMUNIT)$(PPUEXT)
+
+strutils$(PPUEXT) : $(OBJPASDIR)/strutils.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+                    sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/strutils.pp
+
+convutils$(PPUEXT) : $(OBJPASDIR)/convutils.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+                    sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/convutils.pp
+
+stdconvs$(PPUEXT) : $(OBJPASDIR)/stdconvs.pp objpas$(PPUEXT) $(SYSTEMUNIT)$(PPUEXT) \
+                    sysutils$(PPUEXT)
+        $(COMPILER) $(OBJPASDIR)/stdconvs.pp
+
+dynlibs$(PPUEXT) : $(INC)/dynlibs.pas $(UNIXINC)/dynlibs.inc dl$(PPUEXT) objpas$(PPUEXT)
+
+ctypes$(PPUEXT) :  $(INC)/ctypes.pp $(SYSTEMUNIT)$(PPUEXT)
+
+variants$(PPUEXT) : $(INC)/variants.pp sysutils$(PPUEXT) sysconst$(PPUEXT) varutils$(PPUEXT) typinfo$(PPUEXT) rtlconsts$(PPUEXT) math$(PPUEXT)
+        $(COMPILER) -Fi$(INC) $(INC)/variants.pp
+
+cwstring$(PPUEXT) : $(UNIXINC)/cwstring.pp $(SYSTEMUNIT)$(PPUEXT) sysutils$(PPUEXT) baseunix$(PPUEXT) unix$(PPUEXT) unixtype$(PPUEXT) ctypes$(PPUEXT)
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/buildrtl.pp rtl/dragonfly/buildrtl.pp
--- rtl/dragonfly.null/buildrtl.pp	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/buildrtl.pp	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,20 @@
+{ This unit is only used to edit the rtl with lazarus }
+unit buildrtl;
+
+  interface
+
+    uses
+      system, unixtype, ctypes, baseunix, strings, objpas,macpas, syscall, unixutil,
+      fpintres, heaptrc, lineinfo, lnfodwrf,
+      termio, unix, initc, cmem, mmx,
+      crt, printer,
+      sysutils, typinfo, math, matrix, varutils,
+      charset, ucomplex, getopts,
+      errors, sockets, gpm, ipc, serial, terminfo, dl, dynlibs,
+      video, mouse, keyboard, variants, types, dateutils, sysconst, fmtbcd,
+      cthreads, classes, fgl, convutils, stdconvs, strutils, rtlconsts, dos, objects, cwstring, fpcylix, clocale,
+      exeinfo;
+
+  implementation
+
+end.
diff -ur --unidirectional-new-file rtl/dragonfly.null/console.pp rtl/dragonfly/console.pp
--- rtl/dragonfly.null/console.pp	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/console.pp	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,3474 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   Header conversions (with FpIoctl macro expansion) for FreeBSD 4.2's
+   sys/fbio.h sys/consio.h sys/kbdio.h (together these three form
+        machine/console.h) and
+   machine/mouse.h
+
+   Converted to use in a future FreeBSD API to get the IDE running on
+   the physical console with mousesupport.
+
+   As soon as cross unit inlining is ready, all functions should be made
+    inline. (so the FpIoctl and the other very small macro's)
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+UNIT Console;
+
+{$packrecords C}
+
+interface
+
+{I tried to keep original types as much as possible, only "int" is converted
+to longint because INT is a standard function in TP/FPC}
+
+TYPE
+     uchar = char;
+     uint  = dword;
+     u_int = uint;
+     ushort= word;
+     short = integer;
+     long  = dword;             {?}
+     size_t= longint;           {Dunno sure, but it is 32-bit}
+     caddr_t= longint;          {idem}
+     vm_offset_t=dword;         {idem}
+
+{----------------------------- sys/fbio.h ----------------------------------}
+
+{
+ * Copyright (c) 1992, 1993
+ *      The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software developed by the Computer Systems
+ * Engineering group at Lawrence Berkeley Laboratory under DARPA
+ * contract BG 91-66 and contributed to Berkeley.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *      This product includes software developed by the University of
+ *      California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *      @(#)fbio.h      8.2 (Berkeley) 10/30/93
+ *
+ * $FreeBSD: src/sys/sys/fbio.h,v 1.9.2.1 2000/05/05 09:16:16 nyan Exp $
+ }
+
+{
+ * Frame buffer FpIoctls (from Sprite, trimmed to essentials for X11).
+ }
+
+{
+ * Frame buffer type codes.
+ }
+
+CONST
+
+                FBTYPE_SUN1BW           =0;     { multibus mono }
+                FBTYPE_SUN1COLOR        =1;     { multibus color }
+                FBTYPE_SUN2BW           =2;     { memory mono }
+                FBTYPE_SUN2COLOR        =3;     { color w/rasterop chips }
+                FBTYPE_SUN2GP           =4;     { GP1/GP2 }
+                FBTYPE_SUN5COLOR        =5;     { RoadRunner accelerator }
+                FBTYPE_SUN3COLOR        =6;     { memory color }
+                FBTYPE_MEMCOLOR         =7;     { memory 24-bit }
+                FBTYPE_SUN4COLOR        =8;     { memory color w/overlay }
+
+                FBTYPE_NOTSUN1          =9;     { reserved for customer }
+                FBTYPE_NOTSUN2          =10;    { reserved for customer }
+                FBTYPE_NOTSUN3          =11;    { reserved for customer }
+
+                FBTYPE_SUNFAST_COLOR    =12;    { accelerated 8bit }
+                FBTYPE_SUNROP_COLOR     =13;    { MEMCOLOR with rop h/w }
+                FBTYPE_SUNFB_VIDEO      =14;    { Simple video mixing }
+                FBTYPE_RESERVED5        =15;    { reserved, do not use }
+                FBTYPE_RESERVED4        =16;    { reserved, do not use }
+                FBTYPE_RESERVED3        =17;    { reserved, do not use }
+                FBTYPE_RESERVED2        =18;    { reserved, do not use }
+                FBTYPE_RESERVED1        =19;    { reserved, do not use }
+
+                FBTYPE_MDA              =20;
+                FBTYPE_HERCULES         =21;
+                FBTYPE_CGA              =22;
+                FBTYPE_EGA              =23;
+                FBTYPE_VGA              =24;
+                FBTYPE_PC98             =25;
+                FBTYPE_TGA              =26;
+
+                FBTYPE_LASTPLUSONE      =27;    { max number of fbs (change as add) }
+
+{
+ * Frame buffer descriptor as returned by FBIOGTYPE.
+ }
+
+type fbtype = record
+                fb_type   : longint;    { as defined above }
+                fb_height : longint;    { in pixels }
+                fb_width  : longint;    { in pixels }
+                fb_depth  : longint;    { bits per pixel }
+                fb_cmsize : longint;    { size of color map (entries) }
+                fb_size   : longint;    { total size in bytes }
+               end;
+
+Function FBIOGTYPE(fd:longint;var param1 : fbtype):boolean;
+
+{
+ * General purpose structure for passing info in and out of frame buffers
+ * (used for gp1) -- unsupported.
+ }
+type  fbinfo = record
+                fb_physaddr   : longint;        { physical frame buffer address }
+                fb_hwwidth    : longint;        { fb board width }
+                fb_hwheight   : longint;        { fb board height }
+                fb_addrdelta  : longint;        { phys addr diff between boards }
+                fb_ropaddr    : ^uchar;         { fb virtual addr }
+                fb_unit       : longint;        { minor devnum of fb }
+                end;
+
+Function FBIOGINFO(fd:longint;var param1 : fbinfo):boolean;
+
+type
+{
+ * Color map I/O.
+ }
+       fbcmap = record
+                index   : longint;              { first element (0 origin) }
+                count   : longint;              { number of elements }
+                red     : ^uchar;               { red color map elements }
+                green   : ^uchar;               { green color map elements }
+                blue    : ^uchar;               { blue color map elements }
+                end;
+
+Function FBIOPUTCMAP(fd:longint;var param1 : fbcmap):boolean;
+Function FBIOGETCMAP(fd:longint;var param1 : fbcmap):boolean;
+
+{
+ * Set/get attributes.
+ }
+const
+                FB_ATTR_NDEVSPECIFIC    =8;     { no. of device specific values }
+                FB_ATTR_NEMUTYPES       =4;     { no. of emulation types }
+
+type  fbsattr = record
+                flags:longint;                  { flags; see below }
+                emu_type : longint;             { emulation type (-1 if unused) }
+                dev_specific : array[0..FB_ATTR_NDEVSPECIFIC-1] of longint;     { catchall }
+               end;
+const
+                FB_ATTR_AUTOINIT        =1;     { emulation auto init flag }
+                FB_ATTR_DEVSPECIFIC     =2;     { dev. specific stuff valid flag }
+
+type   fbgattr = record
+                real_type : longint;            { real device type }
+                owner     : longint;                    { PID of owner, 0 if myself }
+                _fbtype   : fbtype;             { fbtype info for real device }
+                sattr     : fbsattr;            { see above }
+                emu_types : array [0..FB_ATTR_NEMUTYPES-1] OF Longint;  { possible emulations }
+                                                { (-1 if unused) }
+                end;
+
+{       FBIOSATTR       _IOW('F', 5, struct fbsattr) -- unsupported }
+
+Function FBIOGATTR(fd:longint;var param1 : fbgattr):boolean;
+
+{
+ * Video control.
+ }
+
+const
+                FBVIDEO_OFF             =0;
+                FBVIDEO_ON              =1;
+
+Function FBIOSVIDEO(fd:longint;var param1 : longint):boolean;
+Function FBIOGVIDEO(fd:longint;var param1 : longint):boolean;
+
+{
+ * Hardware cursor control (for, e.g., CG6).  A rather complex and icky
+ * interface that smells like VMS, but there it is....
+ }
+type fbcurpos = record
+                x : short;
+                y : short;
+                end;
+
+
+
+     fbcursor = record
+                _set     : short;               { flags; see below }
+                enable  : short;                { nonzero => cursor on, 0 => cursor off }
+                _pos     : fbcurpos;    { position on display }
+                hot     : fbcurpos;     { hot-spot within cursor }
+                cmap    : fbcmap;       { cursor color map }
+                _size   : fbcurpos;     { number of valid bits in image & mask }
+                image   : caddr_t;              { cursor image bits }
+                mask    : caddr_t;              { cursor mask bits }
+               end;
+
+const
+                FB_CUR_SETCUR   =$01;   { set on/off (i.e., obey fbcursor.enable) }
+                FB_CUR_SETPOS   =$02;   { set position }
+                FB_CUR_SETHOT   =$04;   { set hot-spot }
+                FB_CUR_SETCMAP  =$08;   { set cursor color map }
+                FB_CUR_SETSHAPE =$10;   { set size & bits }
+                FB_CUR_SETALL   =(FB_CUR_SETCUR OR FB_CUR_SETPOS OR FB_CUR_SETHOT OR
+                         FB_CUR_SETCMAP OR FB_CUR_SETSHAPE);
+
+{ controls for cursor attributes & shape (including position) }
+Function FBIOSCURSOR(fd:longint;var param1 : fbcursor):boolean;
+Function FBIOGCURSOR(fd:longint;var param1 : fbcursor):boolean;
+
+{ controls for cursor position only }
+Function FBIOSCURPOS(fd:longint;var param1 : fbcurpos):boolean;
+Function FBIOGCURPOS(fd:longint;var param1 : fbcurpos):boolean;
+
+{ get maximum cursor size }
+Function FBIOGCURMAX(fd:longint;var param1 : fbcurpos):boolean;
+
+{ The new style frame buffer FpIoctls. }
+
+CONST
+         V_INFO_COLOR   =(1 SHL 0);
+         V_INFO_GRAPHICS        =(1 SHL 1);
+         V_INFO_LINEAR  =(1 SHL 2);
+         V_INFO_VESA    =(1 SHL 3);
+         V_INFO_MM_OTHER  =(-1);
+         V_INFO_MM_TEXT  =0;
+         V_INFO_MM_PLANAR =1;
+         V_INFO_MM_PACKED =2;
+         V_INFO_MM_DIRECT =3;
+         V_INFO_MM_CGA   =100;
+         V_INFO_MM_HGC   =101;
+         V_INFO_MM_VGAX  =102;
+
+TYPE
+{ video mode information block }
+  video_info = record
+                        vi_mode         : longint;      { mode number, see below }
+                        vi_flags        : longint;
+                        vi_width        : longint;
+                        vi_height       : longint;
+                        vi_cwidth       : longint;
+                        vi_cheight      : longint;
+                        vi_depth        : longint;
+                        vi_planes       : longint;
+                        vi_window       : uint; { physical address }
+                        vi_window_size  : size_t;
+                        vi_window_gran  : size_t;
+                        vi_buffer       : uint; { physical address }
+                        vi_buffer_size  : size_t;
+                        vi_mem_model    : longint;
+    { for MM_PACKED and MM_DIRECT only }
+                        vi_pixel_size   : longint;      { in bytes }
+    { for MM_DIRECT only }
+                        vi_pixel_fields : array[0..3] of longint;       { RGB and reserved fields }
+                        vi_pixel_fsizes : array[0..3] of longint;
+    { reserved }
+                        vi_reserved     : array[0..63] of uchar;
+                        end;
+
+        video_info_t = video_info;
+const
+         KD_OTHER       =0;             { unknown }
+         KD_MONO                =1;             { monochrome adapter }
+         KD_HERCULES    =2;             { hercules adapter }
+         KD_CGA         =3;             { color graphics adapter }
+         KD_EGA         =4;             { enhanced graphics adapter }
+         KD_VGA         =5;             { video graphics adapter }
+         KD_PC98                =6;             { PC-98 display }
+         KD_TGA         =7;             { TGA }
+         V_ADP_COLOR    =(1 SHL 0);
+         V_ADP_MODECHANGE=(1 SHL 1);
+         V_ADP_STATESAVE        =(1 SHL 2);
+         V_ADP_STATELOAD        =(1 SHL 3);
+         V_ADP_FONT     =(1 SHL 4);
+         V_ADP_PALETTE  =(1 SHL 5);
+         V_ADP_BORDER   =(1 SHL 6);
+         V_ADP_VESA     =(1 SHL 7);
+         V_ADP_PROBED   =(1 SHL 16);
+         V_ADP_INITIALIZED=(1 SHL 17);
+         V_ADP_REGISTERED =(1 SHL 18);
+
+{ adapter infromation block }
+type  video_adapter  = record
+                        va_index                : longint;
+                        va_type                 : longint;
+                        va_name                 : pchar;
+                        va_unit                 : longint;
+                        va_minor                : longint;
+                        va_flags                : longint;
+                        va_io_base              : longint;
+                        va_io_size              : longint;
+                        va_crtc_addr            : longint;
+                        va_mem_base             : longint;
+                        va_mem_size             : longint;
+                        va_window               : vm_offset_t;  { virtual address }
+                        va_window_size          : size_t;
+                        va_window_gran          : size_t;
+                        va_window_orig          : uint;
+                        va_buffer               : vm_offset_t;  { virtual address }
+                        va_buffer_size          : size_t;
+                        va_initial_mode         : longint;
+                        va_initial_bios_mode    : longint;
+                        va_mode                 : longint;
+                        va_info                 : video_info;
+                        va_line_width           : longint;
+                        va_disp_start : record
+                                          x : longint;
+                                          y : longint;
+                                         end;
+                        va_token      : pointer;
+                        end;
+
+        video_adapter_t = video_adapter;
+
+       video_adapter_info = record
+                        va_index                : longint;
+                        va_type                 : longint;
+                        va_name                 : array[0..15] of char;
+                        va_unit                 : longint;
+                        va_flags                : longint;
+                        va_io_base              : longint;
+                        va_io_size              : longint;
+                        va_crtc_addr            : longint;
+                        va_mem_base             : longint;
+                        va_mem_size             : longint;
+                        va_window               : uint;         { virtual address }
+                        va_window_size          : size_t;
+                        va_window_gran          : size_t;
+                        va_unused0              : uint;
+                        va_buffer_size          : size_t;
+                        va_initial_mode         : longint;
+                        va_initial_bios_mode    : longint;
+                        va_mode                 : longint;
+                        va_line_width           : longint;
+                        va_disp_start : record
+                                          x : longint;
+                                          y : longint;
+                                         end;
+                        va_window_orig :  uint;
+    { reserved }
+                        va_reserved : array[0..63] OF uchar;
+                        end;
+        video_adapter_info_t = video_adapter_info;
+
+CONST
+{ some useful video adapter index }
+         V_ADP_PRIMARY  =0;
+         V_ADP_SECONDARY        =1;
+
+{ video mode numbers }
+
+         M_B40x25       =0;     { black & white 40 columns }
+         M_C40x25       =1;     { color 40 columns }
+         M_B80x25       =2;     { black & white 80 columns }
+         M_C80x25       =3;     { color 80 columns }
+         M_BG320                =4;     { black & white graphics 320x200 }
+         M_CG320                =5;     { color graphics 320x200 }
+         M_BG640                =6;     { black & white graphics 640x200 hi-res }
+         M_EGAMONO80x25  =7;       { ega-mono 80x25 }
+         M_CG320_D      =13;    { ega mode D }
+         M_CG640_E      =14;    { ega mode E }
+         M_EGAMONOAPA   =15;    { ega mode F }
+         M_CG640x350    =16;    { ega mode 10 }
+         M_ENHMONOAPA2  =17;    { ega mode F with extended memory }
+         M_ENH_CG640    =18;    { ega mode 10* }
+         M_ENH_B40x25    =19;      { ega enhanced black & white 40 columns }
+         M_ENH_C40x25    =20;      { ega enhanced color 40 columns }
+         M_ENH_B80x25    =21;      { ega enhanced black & white 80 columns }
+         M_ENH_C80x25    =22;      { ega enhanced color 80 columns }
+         M_VGA_C40x25   =23;    { vga 8x16 font on color }
+         M_VGA_C80x25   =24;    { vga 8x16 font on color }
+         M_VGA_M80x25   =25;    { vga 8x16 font on mono }
+
+         M_VGA11                =26;    { vga 640x480 2 colors }
+         M_BG640x480    =26;
+         M_VGA12                =27;    { vga 640x480 16 colors }
+         M_CG640x480    =27;
+         M_VGA13                =28;    { vga 320x200 256 colors }
+         M_VGA_CG320    =28;
+
+         M_VGA_C80x50   =30;    { vga 8x8 font on color }
+         M_VGA_M80x50   =31;    { vga 8x8 font on color }
+         M_VGA_C80x30   =32;    { vga 8x16 font on color }
+         M_VGA_M80x30   =33;    { vga 8x16 font on color }
+         M_VGA_C80x60   =34;    { vga 8x8 font on color }
+         M_VGA_M80x60   =35;    { vga 8x8 font on color }
+         M_VGA_CG640    =36;    { vga 640x400 256 color }
+         M_VGA_MODEX    =37;    { vga 320x240 256 color }
+
+         M_VGA_C90x25   =40;    { vga 8x16 font on color }
+         M_VGA_M90x25   =41;    { vga 8x16 font on mono }
+         M_VGA_C90x30   =42;    { vga 8x16 font on color }
+         M_VGA_M90x30   =43;    { vga 8x16 font on mono }
+         M_VGA_C90x43   =44;    { vga 8x8 font on color }
+         M_VGA_M90x43   =45;    { vga 8x8 font on mono }
+         M_VGA_C90x50   =46;    { vga 8x8 font on color }
+         M_VGA_M90x50   =47;    { vga 8x8 font on mono }
+         M_VGA_C90x60   =48;    { vga 8x8 font on color }
+         M_VGA_M90x60   =49;    { vga 8x8 font on mono }
+
+         M_ENH_B80x43   =$70;   { ega black & white 80x43 }
+         M_ENH_C80x43   =$71;   { ega color 80x43 }
+
+         M_PC98_80x25           =98;    { PC98 text 80x25 }
+         M_PC98_80x30           =99;    { PC98 text 80x30 }
+         M_PC98_EGC640x400      =100;   { PC98 graphic 640x400 16 colors }
+         M_PC98_PEGC640x400     =101;   { PC98 graphic 640x400 256 colors }
+         M_PC98_PEGC640x480     =102;   { PC98 graphic 640x480 256 colors }
+
+         M_HGC_P0       =$e0;   { hercules graphics - page 0 @ B0000 }
+         M_HGC_P1       =$e1;   { hercules graphics - page 1 @ B8000 }
+         M_MCA_MODE     =$ff;   { monochrome adapter mode }
+
+         M_TEXT_80x25   =200;   { generic text modes }
+         M_TEXT_80x30   =201;
+         M_TEXT_80x43   =202;
+         M_TEXT_80x50   =203;
+         M_TEXT_80x60   =204;
+         M_TEXT_132x25  =205;
+         M_TEXT_132x30  =206;
+         M_TEXT_132x43  =207;
+         M_TEXT_132x50  =208;
+         M_TEXT_132x60  =209;
+
+         M_VESA_BASE            =$100;  { VESA mode number base }
+         M_VESA_CG640x400       =$100;  { 640x400, 256 color }
+         M_VESA_CG640x480       =$101;  { 640x480, 256 color }
+         M_VESA_800x600         =$102;  { 800x600, 16 color }
+         M_VESA_CG800x600       =$103;  { 800x600, 256 color }
+         M_VESA_1024x768                =$104;  { 1024x768, 16 color }
+         M_VESA_CG1024x768      =$105;  { 1024x768, 256 color }
+         M_VESA_1280x1024       =$106;  { 1280x1024, 16 color }
+         M_VESA_CG1280x1024     =$107;  { 1280x1024, 256 color }
+         M_VESA_C80x60          =$108;  { 8x8 font }
+         M_VESA_C132x25         =$109;  { 8x16 font }
+         M_VESA_C132x43         =$10a;  { 8x14 font }
+         M_VESA_C132x50         =$10b;  { 8x8 font }
+         M_VESA_C132x60         =$10c;  { 8x8 font }
+         M_VESA_32K_320         =$10d;  { 320x200, 5:5:5 }
+         M_VESA_64K_320         =$10e;  { 320x200, 5:6:5 }
+         M_VESA_FULL_320                =$10f;  { 320x200, 8:8:8 }
+         M_VESA_32K_640         =$110;  { 640x480, 5:5:5 }
+         M_VESA_64K_640         =$111;  { 640x480, 5:6:5 }
+         M_VESA_FULL_640                =$112;  { 640x480, 8:8:8 }
+         M_VESA_32K_800         =$113;  { 800x600, 5:5:5 }
+         M_VESA_64K_800         =$114;  { 800x600, 5:6:5 }
+         M_VESA_FULL_800                =$115;  { 800x600, 8:8:8 }
+         M_VESA_32K_1024                =$116;  { 1024x768, 5:5:5 }
+         M_VESA_64K_1024                =$117;  { 1024x768, 5:6:5 }
+         M_VESA_FULL_1024       =$118;  { 1024x768, 8:8:8 }
+         M_VESA_32K_1280                =$119;  { 1280x1024, 5:5:5 }
+         M_VESA_64K_1280                =$11a;  { 1280x1024, 5:6:5 }
+         M_VESA_FULL_1280       =$11b;  { 1280x1024, 8:8:8 }
+         M_VESA_MODE_MAX                =$1ff;
+
+type
+        video_display_start = record
+                        x  :longint;
+                        y : longint;
+                        end;
+
+        video_display_start_t= video_display_start;
+
+        video_color_palette = record
+                        index : longint;                { first element (zero-based) }
+                        count : longint;                { number of elements }
+                        red   : ^uchar;         { red }
+                        green : ^uchar;         { green }
+                        blue  : ^uchar;         { blue }
+                        transparent : ^uchar;   { may be NULL }
+                        end;
+
+        video_color_palette_t = video_color_palette;
+
+{ adapter info. }
+Function FBIO_ADAPTER(fd:longint;var param1 : longint):boolean;
+Function FBIO_ADPTYPE(fd:longint;var param1 : longint):boolean;
+Function FBIO_ADPINFO(fd:longint;var param1 : video_adapter_info):boolean;
+
+{ video mode control }
+Function FBIO_MODEINFO(fd:longint;var param1 : video_info):boolean;
+Function FBIO_FINDMODE(fd:longint;var param1 : video_info):boolean;
+Function FBIO_GETMODE(fd:longint;var param1 : longint):boolean;
+Function FBIO_SETMODE(fd:longint;var param1 : longint):boolean;
+
+{ get/set frame buffer window origin }
+Function FBIO_GETWINORG(fd:longint;var param1 : u_int):boolean;
+Function FBIO_SETWINORG(fd:longint;var param1 : u_int):boolean;
+
+{ get/set display start address }
+Function FBIO_GETDISPSTART(fd:longint;var param1 : video_display_start_t):boolean;
+Function FBIO_SETDISPSTART(fd:longint;var param1 : video_display_start_t):boolean;
+
+{ get/set scan line width }
+Function FBIO_GETLINEWIDTH(fd:longint;var param1 : u_int):boolean;
+Function FBIO_SETLINEWIDTH(fd:longint;var param1 : u_int):boolean;
+
+{ color palette control }
+Function FBIO_GETPALETTE(fd:longint;var param1 : video_color_palette_t):boolean;
+Function FBIO_SETPALETTE(fd:longint;var param1 : video_color_palette_t):boolean;
+
+{----------------------------- sys/consio.h ----------------------------------}
+
+{ version packaged with FreeBSD 4.2-RELEASE
+Translation to FreePascal by Marco van de Voort. (2000-2001), original
+copyright follows:
+
+ * Copyright (c) 1991-1996 Sren Schmidt
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer
+ *    in this position and unchanged.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/sys/consio.h,v 1.5.2.1 2000/05/05 09:16:15 nyan Exp $
+
+}
+
+{$define definconsole}
+
+{
+ * Console FpIoctl commands.  Some commands are named as KDXXXX, GIO_XXX, and
+ * PIO_XXX, rather than CONS_XXX, for historical and compatibility reasons.
+ * Some other CONS_XXX commands are works as wrapper around frame buffer
+ * FpIoctl commands FBIO_XXX.  Do not try to change all these commands,
+ * otherwise we shall have compatibility problems.
+ }
+
+const
+
+{ get/set video mode }
+        KD_TEXT     =0;         { set text mode restore fonts  }
+        KD_TEXT0    =0;         { ditto            }
+        KD_GRAPHICS =1;         { set graphics mode        }
+        KD_TEXT1    =2;         { set text mode !restore fonts }
+        KD_PIXEL    =3;         { set pixel mode       }
+
+Function KDGETMODE(fd:longint;var param1 : longint):boolean;
+Function KDSETMODE(fd:longint;param1 : longint):boolean;
+
+{ set border color }
+Function KDSBORDER(fd:longint;param1 : longint):boolean;
+
+{ set up raster(pixel) text mode }
+type
+        scr_size        = record
+                          _scrsize : array[0..2] of longint;
+                          end;
+        scr_size_t      = scr_size;
+
+Function KDRASTER(fd:longint;var param1 : scr_size_t):boolean;
+
+type
+
+{ get/set screen char map }
+
+        scrmap   = record
+                    _scrmap : array[0..255] of char;
+                    end;
+        scrmap_t =  scrmap;
+
+Function GIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+Function PIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+
+{ get the current text attribute }
+Function GIO_ATTR(fd:longint;var param1 : longint):boolean;
+
+{ get the current text color }
+Function GIO_COLOR(fd:longint;var param1 : longint):boolean;
+
+{ get the adapter type (equivalent to FBIO_ADPTYPE) }
+Function CONS_CURRENT(fd:longint;var param1 : longint):boolean;
+
+{ get the current video mode (equivalent to FBIO_GETMODE) }
+Function CONS_GET(fd:longint;var param1 : longint):boolean;
+
+{ not supported? }
+Function CONS_IO(fd:longint):boolean;
+
+{ set blank time interval }
+Function CONS_BLANKTIME(fd:longint;var param1 : longint):boolean;
+
+{ set/get the screen saver (these FpIoctls are current noop) }
+CONST        maxsaver=16;
+
+type ssaver =record
+                name : array[0..maxsaver-1] of char;
+                num  : Longint;
+                time : Long;
+                end;
+     ssaver_t =   ssaver;
+
+Function CONS_SSAVER(fd:longint;var param1 : ssaver_t):boolean;
+Function CONS_GSAVER(fd:longint;var param1 : ssaver_t):boolean;
+
+{ set the text cursor shape }
+
+CONST
+        CONS_BLINK_CURSOR  = (1  shl  0);
+        CONS_CHAR_CURSOR   = (1  shl  1);
+
+Function CONS_CURSORTYPE(fd:longint;var param1 : longint):boolean;
+
+{ set the bell type to audible or visual }
+CONST
+        CONS_VISUAL_BELL   =(1  shl  0);
+        CONS_QUIET_BELL    =(1  shl  1);
+
+Function CONS_BELLTYPE(fd:longint;var param1 : longint):boolean;
+
+{ set the history (scroll back) buffer size (in lines) }
+Function CONS_HISTORY(fd:longint;var param1 : longint):boolean;
+
+{ mouse cursor FpIoctl }
+type
+        mouse_data      = record
+                            x       : longint;
+                            y       : Longint;
+                            z       : longint;
+                            buttons : longint;
+                           end;
+
+        mouse_data_t    = mouse_data;
+
+        mouse_mode      = record
+                            mode    : longint;
+                            signal  : longint;
+                           end;
+
+        mouse_mode_t    = mouse_mode;
+
+        mouse_event     = record
+                            id    : Longint;   { one based }
+                            value : longint;
+                           end;
+
+        mouse_event_t   = mouse_event;
+
+CONST
+        MOUSE_SHOW           =$01;
+        MOUSE_HIDE           =$02;
+        MOUSE_MOVEABS        =$03;
+        MOUSE_MOVEREL        =$04;
+        MOUSE_GETINFO        =$05;
+        _MOUSE_MODE           =$06;
+        MOUSE_ACTION         =$07;
+        MOUSE_MOTION_EVENT   =$08;
+        MOUSE_BUTTON_EVENT   =$09;
+        MOUSE_MOUSECHAR      =$0a;
+
+TYPE
+        mouse_info = record
+                       operation : longint;
+                       u : record
+                            case integer of
+                               0:  (data : mouse_data_t);
+                               1:  (mode : mouse_mode_t);
+                               2:  (event: mouse_event_t);
+                               3:  (mouse_char : longint);
+                               end;
+                      end;
+        mouse_info_t = mouse_info;
+
+Function CONS_MOUSECTL(fd:longint;var param1 : mouse_info_t):boolean;
+
+{ see if the vty has been idle }
+Function CONS_IDLE(fd:longint;var param1 : longint):boolean;
+
+{ set the screen saver mode }
+CONST
+        CONS_LKM_SAVER = 0;
+        CONS_USR_SAVER =  1;
+
+Function CONS_SAVERMODE(fd:longint;var param1 : longint):boolean;
+
+{ start the screen saver }
+Function CONS_SAVERSTART(fd:longint;var param1 : longint):boolean;
+
+TYPE
+{ set/get font data }
+        fnt8        = record
+                        fnt8x8 : array[0..8*256-1] of char;
+                      end;
+
+        fnt8_t      = fnt8;
+
+        fnt14       = record
+                        fnt8x14: array[0..14*256-1] of char;
+                      end;
+
+        fnt14_t     = fnt14;
+
+        fnt16       = record
+                        fnt8x16: array[0..16*256-1] of char;
+                       end;
+        fnt16_t     = fnt16;
+
+Function PIO_FONT8x8(fd:longint;var param1 : fnt8_t):boolean;
+Function GIO_FONT8x8(fd:longint;var param1 : fnt8_t):boolean;
+Function PIO_FONT8x14(fd:longint;var param1 : fnt14_t):boolean;
+Function GIO_FONT8x14(fd:longint;var param1 : fnt14_t):boolean;
+Function PIO_FONT8x16(fd:longint;var param1 : fnt16_t):boolean;
+Function GIO_FONT8x16(fd:longint;var param1 : fnt16_t):boolean;
+
+
+{ get video mode information }
+type        colors = record
+                       fore : char;
+                       back : char;
+                      end;
+
+            vid_info = record
+                        _size         : short;
+                        m_num         : short;
+                        mv_row,
+                        mv_col        : ushort;
+                        mv_rsz,
+                        mv_csz        : ushort;
+                        mv_norm,
+                        mv_rev,
+                        mv_grfc       : colors;
+                        mv_ovscan     : uchar;
+                        mk_keylock    : uchar;
+                       end;
+        vid_info_t   = vid_info;
+
+Function CONS_GETINFO(fd:longint;var param1 : vid_info_t):boolean;
+
+{ get version }
+
+Function CONS_GETVERS(fd:longint;var param1 : longint):boolean;
+
+{ get the video adapter index (equivalent to FBIO_ADAPTER) }
+Function CONS_CURRENTADP(fd:longint;var param1 : longint):boolean;
+
+{ get the video adapter information (equivalent to FBIO_ADPINFO) }
+Function CONS_ADPINFO(fd:longint;var param1 : video_adapter_info_t):boolean;
+
+{ get the video mode information (equivalent to FBIO_MODEINFO) }
+Function CONS_MODEINFO(fd:longint;var param1 : video_info_t):boolean;
+
+{ find a video mode (equivalent to FBIO_FINDMODE) }
+Function CONS_FINDMODE(fd:longint;var param1 : video_info_t):boolean;
+
+{ set the frame buffer window origin (equivalent to FBIO_SETWINORG) }
+Function CONS_SETWINORG(fd:longint;param1 : longint):boolean;
+
+{ use the specified keyboard }
+Function CONS_SETKBD(fd:longint;param1 : longint):boolean;
+
+{ release the current keyboard }
+Function CONS_RELKBD(fd:longint):boolean;
+
+{ get/set the current terminal emulator info. }
+CONST
+        TI_NAME_LEN   = 32;
+        TI_DESC_LEN   = 64;
+
+TYPE
+        term_info     = record
+                          ti_index    : Longint;
+                          ti_flags    : longint;
+                          ti_name     : array[0..TI_NAME_LEN-1] of uchar;
+                          ti_desc     : array[0..TI_DESC_LEN-1] of uchar;
+                         end;
+        term_info_t   = term_info;
+
+Function CONS_GETTERM(fd:longint;var param1 : term_info_t):boolean;
+Function CONS_SETTERM(fd:longint;var param1 : term_info_t):boolean;
+
+{$ifdef PC98}
+Function ADJUST_CLOCK(fd:longint):boolean;
+{$endif}
+
+{
+* Vty switching FpIoctl commands.
+}
+
+{ get the next available vty }
+Function VT_OPENQRY(fd:longint;var param1 : longint):boolean;
+
+{ set/get vty switching mode }
+const
+        VT_AUTO     =0;       { switching is automatic   }
+        VT_PROCESS  =1;       { switching controlled by prog }
+        VT_KERNEL   =255;     { switching controlled in kernel }
+
+TYPE
+        vt_mode    = record
+                       mode     :   Char;
+                       waitv    :   char;    { not implemented yet  SOS }
+                       relsig   :   short;
+                       acqsig   :   short;
+                       frsig    :   short;   { not implemented yet  SOS }
+                      end;
+
+        vtmode_t  = vt_mode;
+
+
+Function VT_SETMODE(fd:longint;var param1 : vtmode_t):boolean;
+Function VT_GETMODE(fd:longint;var param1 : vtmode_t):boolean;
+
+
+{ acknowledge release or acquisition of a vty }
+const
+        VT_FALSE      = 0;
+        VT_TRUE       = 1;
+        VT_ACKACQ     = 2;
+
+Function VT_RELDISP(fd:longint;param1 : longint):boolean;
+
+{ activate the specified vty }
+Function VT_ACTIVATE(fd:longint;param1 : longint):boolean;
+
+{ wait until the specified vty is activate }
+Function VT_WAITACTIVE(fd:longint;param1 : longint):boolean;
+
+{ get the currently active vty }
+Function VT_GETACTIVE(fd:longint;var param1 : longint):boolean;
+
+{ get the index of the vty }
+Function VT_GETINDEX(fd:longint;var param1 : longint):boolean;
+
+{
+* Video mode switching FpIoctl.  See sys/fbio.h for mode numbers.
+}
+
+Function SW_B40x25(fd:longint):boolean;
+Function SW_C40x25(fd:longint):boolean;
+Function SW_B80x25(fd:longint):boolean;
+Function SW_C80x25(fd:longint):boolean;
+Function SW_BG320(fd:longint):boolean;
+Function SW_CG320(fd:longint):boolean;
+Function SW_BG640(fd:longint):boolean;
+Function SW_EGAMONO80x25(fd:longint):boolean;
+Function SW_CG320_D(fd:longint):boolean;
+Function SW_CG640_E(fd:longint):boolean;
+Function SW_EGAMONOAPA(fd:longint):boolean;
+Function SW_CG640x350(fd:longint):boolean;
+Function SW_ENH_MONOAPA2(fd:longint):boolean;
+Function SW_ENH_CG640(fd:longint):boolean;
+Function SW_ENH_B40x25(fd:longint):boolean;
+Function SW_ENH_C40x25(fd:longint):boolean;
+Function SW_ENH_B80x25(fd:longint):boolean;
+Function SW_ENH_C80x25(fd:longint):boolean;
+Function SW_ENH_B80x43(fd:longint):boolean;
+Function SW_ENH_C80x43(fd:longint):boolean;
+Function SW_MCAMODE(fd:longint):boolean;
+Function SW_VGA_C40x25(fd:longint):boolean;
+Function SW_VGA_C80x25(fd:longint):boolean;
+Function SW_VGA_C80x30(fd:longint):boolean;
+Function SW_VGA_C80x50(fd:longint):boolean;
+Function SW_VGA_C80x60(fd:longint):boolean;
+Function SW_VGA_M80x25(fd:longint):boolean;
+Function SW_VGA_M80x30(fd:longint):boolean;
+Function SW_VGA_M80x50(fd:longint):boolean;
+Function SW_VGA_M80x60(fd:longint):boolean;
+Function SW_VGA11(fd:longint):boolean;
+Function SW_BG640x480(fd:longint):boolean;
+Function SW_VGA12(fd:longint):boolean;
+Function SW_CG640x480(fd:longint):boolean;
+Function SW_VGA13(fd:longint):boolean;
+Function SW_VGA_CG320(fd:longint):boolean;
+Function SW_VGA_CG640(fd:longint):boolean;
+Function SW_VGA_MODEX(fd:longint):boolean;
+Function SW_PC98_80x25(fd:longint):boolean;
+Function SW_PC98_80x30(fd:longint):boolean;
+Function SW_PC98_EGC640x400(fd:longint):boolean;
+Function SW_PC98_PEGC640x400(fd:longint):boolean;
+Function SW_PC98_PEGC640x480(fd:longint):boolean;
+Function SW_VGA_C90x25(fd:longint):boolean;
+Function SW_VGA_M90x25(fd:longint):boolean;
+Function SW_VGA_C90x30(fd:longint):boolean;
+Function SW_VGA_M90x30(fd:longint):boolean;
+Function SW_VGA_C90x43(fd:longint):boolean;
+Function SW_VGA_M90x43(fd:longint):boolean;
+Function SW_VGA_C90x50(fd:longint):boolean;
+Function SW_VGA_M90x50(fd:longint):boolean;
+Function SW_VGA_C90x60(fd:longint):boolean;
+Function SW_VGA_M90x60(fd:longint):boolean;
+Function SW_TEXT_80x25(fd:longint):boolean;
+Function SW_TEXT_80x30(fd:longint):boolean;
+Function SW_TEXT_80x43(fd:longint):boolean;
+Function SW_TEXT_80x50(fd:longint):boolean;
+Function SW_TEXT_80x60(fd:longint):boolean;
+Function SW_TEXT_132x25(fd:longint):boolean;
+Function SW_TEXT_132x30(fd:longint):boolean;
+Function SW_TEXT_132x43(fd:longint):boolean;
+Function SW_TEXT_132x50(fd:longint):boolean;
+Function SW_TEXT_132x60(fd:longint):boolean;
+Function SW_VESA_CG640x400(fd:longint):boolean;
+Function SW_VESA_CG640x480(fd:longint):boolean;
+Function SW_VESA_800x600(fd:longint):boolean;
+Function SW_VESA_CG800x600(fd:longint):boolean;
+Function SW_VESA_1024x768(fd:longint):boolean;
+Function SW_VESA_CG1024x768(fd:longint):boolean;
+Function SW_VESA_1280x1024(fd:longint):boolean;
+Function SW_VESA_CG1280x1024(fd:longint):boolean;
+Function SW_VESA_C80x60(fd:longint):boolean;
+Function SW_VESA_C132x25(fd:longint):boolean;
+Function SW_VESA_C132x43(fd:longint):boolean;
+Function SW_VESA_C132x50(fd:longint):boolean;
+Function SW_VESA_C132x60(fd:longint):boolean;
+Function SW_VESA_32K_320(fd:longint):boolean;
+Function SW_VESA_64K_320(fd:longint):boolean;
+Function SW_VESA_FULL_320(fd:longint):boolean;
+Function SW_VESA_32K_640(fd:longint):boolean;
+Function SW_VESA_64K_640(fd:longint):boolean;
+Function SW_VESA_FULL_640(fd:longint):boolean;
+Function SW_VESA_32K_800(fd:longint):boolean;
+Function SW_VESA_64K_800(fd:longint):boolean;
+Function SW_VESA_FULL_800(fd:longint):boolean;
+Function SW_VESA_32K_1024(fd:longint):boolean;
+Function SW_VESA_64K_1024(fd:longint):boolean;
+Function SW_VESA_FULL_1024(fd:longint):boolean;
+Function SW_VESA_32K_1280(fd:longint):boolean;
+Function SW_VESA_64K_1280(fd:longint):boolean;
+Function SW_VESA_FULL_1280(fd:longint):boolean;
+
+{----------------------------- sys/kbio.h ----------------------------------}
+
+{ version packaged with FreeBSD 4.2-RELEASE
+Translation to FreePascal by Marco van de Voort. (2000-2001), original
+copyright follows: ( I assume BSD licensed)
+
+Based on
+ * $FreeBSD: src/sys/sys/kbio.h,v 1.5.2.1 2000/10/29 16:59:32 dwmalone Exp $
+}
+
+{ get/set keyboard I/O mode}
+const   K_RAW           =0;             { keyboard returns scancodes}
+        K_XLATE         =1;             { keyboard returns ascii}
+        K_CODE          =2;             { keyboard returns keycodes}
+
+{After each FpIoctl value, I've put the type of the parameters to be passed:
+     @int -> pass a pointer to an int.
+      int -> pass pointer(int)
+      -   -> nothing
+@keymap_t -> pass a pointer to a keymap_t
+ etc.
+}
+
+Function KDGKBMODE(fd:longint;var param1 : longint):boolean;
+Function KDSKBMODE(fd:longint;param1 : longint):boolean;
+
+
+{ make tone}
+Function KDMKTONE(fd:longint;param1 : longint):boolean;
+
+{ see console.h for the definitions of the following FpIoctls}
+{$ifndef definconsole}
+Function KDGETMODE(fd:longint;var param1 : longint):boolean;
+Function KDSETMODE(fd:longint;param1 : longint):boolean;
+Function KDSBORDER(fd:longint;param1 : longint):boolean;
+
+{$endif}
+const
+{ get/set keyboard lock state}
+        CLKED           =1;             { Caps locked}
+        NLKED           =2;             { Num locked}
+        SLKED           =4;             { Scroll locked}
+        ALKED           =8;             { AltGr locked}
+        LOCK_MASK       =CLKED or NLKED or SLKED or ALKED;
+
+Function KDGKBSTATE(fd:longint;var param1 : longint):boolean;
+Function KDSKBSTATE(fd:longint;param1 : longint):boolean;
+
+{ enable/disable I/O access}
+Function KDENABIO(fd:longint):boolean;
+Function KDDISABIO(fd:longint):boolean;
+
+{ make sound}
+Function KIOCSOUND(fd:longint;param1 : longint):boolean;
+
+Const
+{ get keyboard model}
+        KB_OTHER        =0;             { keyboard not known}
+        KB_84           =1;             { 'old' 84 key AT-keyboard}
+        KB_101          =2;             { MF-101 or MF-102 keyboard}
+Function KDGKBTYPE(fd:longint;var param1 : longint):boolean;
+
+const
+{ get/set keyboard LED state}
+        LED_CAP         =1;             { Caps lock LED}
+        LED_NUM         =2;             { Num lock LED}
+        LED_SCR         =4;             { Scroll lock LED}
+        LED_MASK        =LED_CAP or LED_NUM or LED_SCR;
+Function KDGETLED(fd:longint;var param1 : longint):boolean;
+Function KDSETLED(fd:longint;param1 : longint):boolean;
+
+{ set keyboard repeat rate (obsolete, use KDSETREPEAT below)}
+Function KDSETRAD(fd:longint;param1 : longint):boolean;
+
+{ see console.h for the definition of the following FpIoctl}
+{$ifndef definconsole}
+Function KDRASTER(fd:longint;var param1 : scr_size_t):boolean;
+
+{$endif}
+
+TYPE
+{ get keyboard information}
+  keyboard_info = Record
+                        kb_index : longint;     { kbdio index#}
+                        kb_name  : array[0..15] of char;        { driver name}
+                        kb_unit  : longint;     { unit#}
+                        kb_type  : longint;     { KB_84, KB_101, KB_OTHER,...}
+                        kb_config: longint;     { device configuration flags}
+                        kb_flags : longint;     { internal flags}
+                 end;
+  keyboard_info_t=keyboard_info;
+
+Function KDGKBINFO(fd:longint;var param1 : keyboard_info_t):boolean;
+
+Type
+{ set/get keyboard repeat rate (new interface)}
+ keyboard_repeat = record
+                    kb_repeat: array[0..1] of longint;
+                   end;
+
+keyboard_repeat_t = keyboard_repeat;
+
+Function KDSETREPEAT(fd:longint;var param1 : keyboard_repeat_t):boolean;
+Function KDGETREPEAT(fd:longint;var param1 : keyboard_repeat_t):boolean;
+
+{ get/set key map/accent map/function key strings}
+
+const
+        NUM_KEYS        =256;           { number of keys in table}
+        NUM_STATES      =8;             { states per key}
+        ALTGR_OFFSET    =128;           { offset for altlock keys}
+
+        NUM_DEADKEYS    =15;            { number of accent keys}
+        NUM_ACCENTCHARS =52;            { max number of accent chars}
+
+        NUM_FKEYS       =96;            { max number of function keys}
+        MAXFK           =16;            { max length of a function key str}
+
+type
+        keyent_t = record
+                        map  : array[0..NUM_STATES-1] of uchar;
+                        spcl : uchar;
+                        flgs : uchar;
+                   end;
+
+const
+        FLAG_LOCK_O     =0;
+        FLAG_LOCK_C     =1;
+        FLAG_LOCK_N     =2;
+
+type keymap = record
+                        n_keys : ushort;
+                        key    : array[0..NUM_KEYS-1] OF keyent_t;
+              end;
+
+     keymap_t= keymap;
+
+CONST
+{ defines for "special" keys (spcl bit set in keymap)}
+        NOP             =$00;           { nothing (dead key)}
+        LSH             =$02;           { left shift key}
+        RSH             =$03;           { right shift key}
+        CLK             =$04;           { caps lock key}
+        NLK             =$05;           { num lock key}
+        SLK             =$06;           { scroll lock key}
+        LALT            =$07;           { left alt key}
+        BTAB            =$08;           { backwards tab}
+        LCTR            =$09;           { left control key}
+        NEXT            =$0a;           { switch to next screen}
+        F_SCR           =$0b;           { switch to first screen}
+        L_SCR           =$1a;           { switch to last screen}
+        F_FN            =$1b;           { first function key}
+        L_FN            =$7a;           { last function key}
+{                        $7b-$7f          reserved do not use !}
+        RCTR            =$80;           { right control key}
+        RALT            =$81;           { right alt (altgr) key}
+        ALK             =$82;           { alt lock key}
+        ASH             =$83;           { alt shift key}
+        META            =$84;           { meta key}
+        RBT             =$85;           { boot machine}
+        DBG             =$86;           { call debugger}
+        SUSP            =$87;           { suspend power (APM)}
+        SPSC            =$88;           { toggle splash/text screen}
+
+        DGRA            =$89;           { grave}
+        F_ACC           =DGRA;          { first accent key}
+
+        DACU            =$8a;           { acute}
+        DCIR            =$8b;           { circumflex}
+        DTIL            =$8c;           { tilde}
+        DMAC            =$8d;           { macron}
+        DBRE            =$8e;           { breve}
+        DDOT            =$8f;           { dot}
+        DUML            =$90;           { umlaut/diaresis}
+        DDIA            =$90;           { diaresis}
+        DSLA            =$91;           { slash}
+        DRIN            =$92;           { ring}
+        DCED            =$93;           { cedilla}
+        DAPO            =$94;           { apostrophe}
+        DDAC            =$95;           { double acute}
+        DOGO            =$96;           { ogonek}
+        DCAR            =$97;           { caron}
+        L_ACC           =DCAR;          { last accent key}
+
+        STBY            =$98;           { Go into standby mode (apm)}
+        PREV            =$99;           { switch to previous screen}
+        PNC             =$9a;           { force system panic}
+        LSHA            =$9b;           { left shift key / alt lock}
+        RSHA            =$9c;           { right shift key / alt lock}
+        LCTRA           =$9d;           { left ctrl key / alt lock}
+        RCTRA           =$9e;           { right ctrl key / alt lock}
+        LALTA           =$9f;           { left alt key / alt lock}
+        RALTA           =$a0;           { right alt key / alt lock}
+        HALT            =$a1;           { halt machine}
+        PDWN            =$a2;           { halt machine and power down}
+
+function kbio_F(x:longint):longint;
+function kbio_S(x:longint):longint;
+function kbio_ACC(x:longint):longint;
+
+type acc_t           = record
+                        accchar : uchar;
+                        map : array[0..NUM_ACCENTCHARS-1,0..1] of uchar;
+                       end;
+
+   accentmap       = record
+                        n_accs : ushort;
+                        acc    : array[0..NUM_DEADKEYS-1] of acc_t
+                       end;
+
+      accentmap_t     =  accentmap ;
+
+     keyarg         = record
+                        keynum : ushort;
+                        key : keyent_t;
+                        end;
+
+       keyarg_t = keyarg;
+
+             fkeytab = record
+                        str : array [0..MAXFK-1] of uchar;
+                        len : uchar;
+                       end;
+             fkeytab_t = fkeytab;
+
+             fkeyarg =record
+                        keynum : ushort;
+                        keydef : array[0..MAXFK-1] of char;
+                        flen :char;
+                        end;
+
+         fkeyarg_t       = fkeyarg;
+
+Function GETFKEY(fd:longint;var param1 : fkeyarg_t):boolean;
+Function SETFKEY(fd:longint;var param1 : fkeyarg_t):boolean;
+
+{$ifndef definconsole}
+Function GIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+Function PIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+{$endif}
+Function GIO_KEYMAP(fd:longint;var param1 : keymap_t):boolean;
+Function PIO_KEYMAP(fd:longint;var param1 : keymap_t):boolean;
+Function GIO_DEADKEYMAP(fd:longint;var param1 : accentmap_t):boolean;
+Function PIO_DEADKEYMAP(fd:longint;var param1 : accentmap_t):boolean;
+Function GIO_KEYMAPENT(fd:longint;var param1 : keyarg_t):boolean;
+Function PIO_KEYMAPENT(fd:longint;var param1 : keyarg_t):boolean;
+
+{ flags set to the return value in the KD_XLATE mode}
+Const
+        NOKEY           =$100;          { no key pressed marker}
+        FKEY            =$200;          { function key marker}
+        MKEY            =$400;          { meta key marker (prepend ESC)}
+        BKEY            =$800;          { backtab (ESC [ Z)}
+
+        SPCLKEY         =$8000;         { special key}
+        RELKEY          =$4000;         { key released}
+        ERRKEY          =$2000;         { error}
+
+
+function KEYCHAR(c:longint):longint;
+
+function KEYFLAGS(c:longint):longint;
+
+{----------------------------- machine/mouse.h -------------------------------}
+
+{ Based on machine/mouse.h from FreeBSD release 4.2
+
+ * Copyright (c) 1992, 1993 Erik Forsberg.
+ * Copyright (c) 1996, 1997 Kazutaka YOKOTA
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
+ * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+ * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+ * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+ * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+ * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ * $FreeBSD: src/sys/i386/include/mouse.h,v 1.15.2.1 2000/03/21 14:44:10 yokota Exp $
+ }
+
+
+{ FpIoctls }
+
+
+{ mouse status block }
+
+type
+ mousestatus = record
+                 flags    : longint;            { state change flags }
+                 button   : longint;            { button status }
+                 obutton  : longint;            { previous button status }
+                 dx       : longint;            { x movement }
+                 dy       : longint;            { y movement }
+                 dz       : longint;            { z movement }
+                end;
+
+ mousestatus_t = mousestatus;
+
+CONST
+
+{ button }
+       MOUSE_BUTTON1DOWN        =$0001; { left }
+       MOUSE_BUTTON2DOWN        =$0002; { middle }
+       MOUSE_BUTTON3DOWN        =$0004; { right }
+       MOUSE_BUTTON4DOWN        =$0008;
+       MOUSE_BUTTON5DOWN        =$0010;
+       MOUSE_BUTTON6DOWN        =$0020;
+       MOUSE_BUTTON7DOWN        =$0040;
+       MOUSE_BUTTON8DOWN        =$0080;
+       MOUSE_MAXBUTTON          =31;
+       MOUSE_STDBUTTONS         =$0007;         { buttons 1-3 }
+       MOUSE_EXTBUTTONS         =$7ffffff8;     { the others (28 of them!) }
+       MOUSE_BUTTONS            =(MOUSE_STDBUTTONS or MOUSE_EXTBUTTONS);
+
+{ flags }
+       MOUSE_STDBUTTONSCHANGED  =MOUSE_STDBUTTONS;
+       MOUSE_EXTBUTTONSCHANGED  =MOUSE_EXTBUTTONS;
+       MOUSE_BUTTONSCHANGED     =MOUSE_BUTTONS;
+       MOUSE_POSCHANGED         =$80000000;
+
+type
+  mousehw =record
+         buttons : longint;             { -1 if unknown }
+         iftype  : longint;             { MOUSE_IF_XXX }
+         _type    : longint;            { mouse/track ball/pad... }
+         model   : longint;             { I/F dependent model ID: MOUSE_MODEL_XXX }
+         hwid    : longint;             { I/F dependent hardware ID}
+                                 { for the PS/2 mouse, it will be PSM_XXX_ID  }
+          end;
+
+   mousehw_t  = mousehw;
+
+const
+
+{ iftype }
+       MOUSE_IF_UNKNOWN         =(-1);
+       MOUSE_IF_SERIAL          =0;
+       MOUSE_IF_BUS             =1;
+       MOUSE_IF_INPORT          =2;
+       MOUSE_IF_PS2             =3;
+       MOUSE_IF_SYSMOUSE        =4;
+       MOUSE_IF_USB             =5;
+
+{ type }
+       MOUSE_UNKNOWN            =(-1);  { should be treated as a mouse }
+       MOUSE_MOUSE              =0;
+       MOUSE_TRACKBALL          =1;
+       MOUSE_STICK              =2;
+       MOUSE_PAD                =3;
+
+{ model }
+       MOUSE_MODEL_UNKNOWN              =(-1);
+       MOUSE_MODEL_GENERIC              =0;
+       MOUSE_MODEL_GLIDEPOINT           =1;
+       MOUSE_MODEL_NETSCROLL            =2;
+       MOUSE_MODEL_NET                  =3;
+       MOUSE_MODEL_INTELLI              =4;
+       MOUSE_MODEL_THINK                =5;
+       MOUSE_MODEL_EASYSCROLL           =6;
+       MOUSE_MODEL_MOUSEMANPLUS         =7;
+       MOUSE_MODEL_KIDSPAD              =8;
+       MOUSE_MODEL_VERSAPAD             =9;
+       MOUSE_MODEL_EXPLORER             =10;
+       MOUSE_MODEL_4D                   =11;
+       MOUSE_MODEL_4DPLUS               =12;
+
+type  mousemode = record
+                    protocol    : longint;              { MOUSE_PROTO_XXX }
+                    rate        : longint;              { report rate (per sec), -1 if unknown }
+                    resolution  : longint;              { MOUSE_RES_XXX, -1 if unknown }
+                    accelfactor : longint;              { accelation factor (must be 1 or greater) }
+                    level       : longint;              { driver operation level }
+                    packetsize  : longint;              { the length of the data packet }
+                    syncmask    : array[0..1] of uchar; { sync. data bits in the header byte }
+                  end;
+
+type mousemode_t = mousemode;
+
+{ protocol }
+{
+ * Serial protocols:
+ *   Microsoft, MouseSystems, Logitech, MM series, MouseMan, Hitachi Tablet,
+ *   GlidePoint, IntelliMouse, Thinking Mouse, MouseRemote, Kidspad,
+ *   VersaPad
+ * Bus mouse protocols:
+ *   bus, InPort
+ * PS/2 mouse protocol:
+ *   PS/2
+ }
+ const
+
+       MOUSE_PROTO_UNKNOWN      =(-1);
+       MOUSE_PROTO_MS           =0;     { Microsoft Serial, 3 bytes }
+       MOUSE_PROTO_MSC          =1;     { Mouse Systems, 5 bytes }
+       MOUSE_PROTO_LOGI         =2;     { Logitech, 3 bytes }
+       MOUSE_PROTO_MM           =3;     { MM series, 3 bytes }
+       MOUSE_PROTO_LOGIMOUSEMAN =4;     { Logitech MouseMan 3/4 bytes }
+       MOUSE_PROTO_BUS          =5;     { MS/Logitech bus mouse }
+       MOUSE_PROTO_INPORT       =6;     { MS/ATI InPort mouse }
+       MOUSE_PROTO_PS2          =7;     { PS/2 mouse, 3 bytes }
+       MOUSE_PROTO_HITTAB       =8;     { Hitachi Tablet 3 bytes }
+       MOUSE_PROTO_GLIDEPOINT   =9;     { ALPS GlidePoint, 3/4 bytes }
+       MOUSE_PROTO_INTELLI      =10;    { MS IntelliMouse, 4 bytes }
+       MOUSE_PROTO_THINK        =11;    { Kensignton Thinking Mouse, 3/4 bytes }
+       MOUSE_PROTO_SYSMOUSE     =12;    { /dev/sysmouse }
+       MOUSE_PROTO_X10MOUSEREM  =13;    { X10 MouseRemote, 3 bytes }
+       MOUSE_PROTO_KIDSPAD      =14;    { Genius Kidspad }
+       MOUSE_PROTO_VERSAPAD     =15;    { Interlink VersaPad, 6 bytes }
+
+       MOUSE_RES_UNKNOWN        =(-1);
+       MOUSE_RES_DEFAULT        =0;
+       MOUSE_RES_LOW            =(-2);
+       MOUSE_RES_MEDIUMLOW      =(-3);
+       MOUSE_RES_MEDIUMHIGH     =(-4);
+       MOUSE_RES_HIGH           =(-5);
+
+type  mousedata = record
+        len : longint;          { # of data in the buffer }
+        buf : array [0..15] of longint;         { data buffer }
+        end;
+
+ mousedata_t=mousedata;
+
+ mousevar  = record
+               _var : array[0..15] of longint;
+               end;
+
+type mousevar_t = mousevar;
+
+Function MOUSE_GETSTATUS(fd:longint;var param1 : mousestatus_t):boolean;
+Function MOUSE_GETHWINFO(fd:longint;var param1 : mousehw_t):boolean;
+Function MOUSE_GETMODE(fd:longint;var param1 : mousemode_t):boolean;
+Function MOUSE_SETMODE(fd:longint;var param1 : mousemode_t):boolean;
+Function MOUSE_GETLEVEL(fd:longint;var param1 : longint):boolean;
+Function MOUSE_SETLEVEL(fd:longint;var param1 : longint):boolean;
+Function MOUSE_GETVARS(fd:longint;var param1 : mousevar_t):boolean;
+Function MOUSE_SETVARS(fd:longint;var param1 : mousevar_t):boolean;
+Function MOUSE_READSTATE(fd:longint;var param1 : mousedata_t):boolean;
+Function MOUSE_READDATA(fd:longint;var param1 : mousedata_t):boolean;
+
+Function MOUSE_SETRESOLUTION(fd:longint;var param1 : longint):boolean;
+Function MOUSE_SETSCALING(fd:longint;var param1 : longint):boolean;
+Function MOUSE_SETRATE(fd:longint;var param1 : longint):boolean;
+Function MOUSE_GETHWID(fd:longint;var param1 : longint):boolean;
+
+
+
+const
+
+{ magic numbers in var[0] }
+       MOUSE_VARS_PS2_SIG       = $00325350;    { 'PS2' }
+       MOUSE_VARS_BUS_SIG       = $00535542;    { 'BUS' }
+       MOUSE_VARS_INPORT_SIG    = $00504e49;    { 'INP' }
+
+{ Microsoft Serial mouse data packet }
+       MOUSE_MSS_PACKETSIZE     = 3;
+       MOUSE_MSS_SYNCMASK       = $40;
+       MOUSE_MSS_SYNC           = $40;
+       MOUSE_MSS_BUTTONS        = $30;
+       MOUSE_MSS_BUTTON1DOWN    = $20;  { left }
+       MOUSE_MSS_BUTTON2DOWN    = $00;  { no middle button }
+       MOUSE_MSS_BUTTON3DOWN    = $10;  { right }
+
+{ Logitech MouseMan data packet (M+ protocol) }
+       MOUSE_LMAN_BUTTON2DOWN   = $20;  { middle button, the 4th byte }
+
+{ ALPS GlidePoint extention (variant of M+ protocol) }
+       MOUSE_ALPS_BUTTON2DOWN   = $20;  { middle button, the 4th byte }
+       MOUSE_ALPS_TAP           = $10;  { `tapping' action, the 4th byte }
+
+{ Kinsington Thinking Mouse extention (variant of M+ protocol) }
+       MOUSE_THINK_BUTTON2DOWN = $20;   { lower-left button, the 4th byte }
+       MOUSE_THINK_BUTTON4DOWN = $10;   { lower-right button, the 4th byte }
+
+{ MS IntelliMouse (variant of MS Serial) }
+       MOUSE_INTELLI_PACKETSIZE  = 4;
+       MOUSE_INTELLI_BUTTON2DOWN = $10; { middle button in the 4th byte }
+
+{ Mouse Systems Corp. mouse data packet }
+       MOUSE_MSC_PACKETSIZE     = 5;
+       MOUSE_MSC_SYNCMASK       = $f8;
+       MOUSE_MSC_SYNC           = $80;
+       MOUSE_MSC_BUTTONS        = $07;
+       MOUSE_MSC_BUTTON1UP      = $04;  { left }
+       MOUSE_MSC_BUTTON2UP      = $02;  { middle }
+       MOUSE_MSC_BUTTON3UP      = $01;  { right }
+       MOUSE_MSC_MAXBUTTON      = 3;
+
+{ MM series mouse data packet }
+       MOUSE_MM_PACKETSIZE      = 3;
+       MOUSE_MM_SYNCMASK        = $e0;
+       MOUSE_MM_SYNC            = $80;
+       MOUSE_MM_BUTTONS         = $07;
+       MOUSE_MM_BUTTON1DOWN     = $04;  { left }
+       MOUSE_MM_BUTTON2DOWN     = $02;  { middle }
+       MOUSE_MM_BUTTON3DOWN     = $01;  { right }
+       MOUSE_MM_XPOSITIVE       = $10;
+       MOUSE_MM_YPOSITIVE       = $08;
+
+{ PS/2 mouse data packet }
+       MOUSE_PS2_PACKETSIZE     = 3;
+       MOUSE_PS2_SYNCMASK       = $c8;
+       MOUSE_PS2_SYNC           = $08;
+       MOUSE_PS2_BUTTONS        = $07;  { = $03 for 2 button mouse }
+       MOUSE_PS2_BUTTON1DOWN    = $01;  { left }
+       MOUSE_PS2_BUTTON2DOWN    = $04;  { middle }
+       MOUSE_PS2_BUTTON3DOWN    = $02;  { right }
+       MOUSE_PS2_TAP            = MOUSE_PS2_SYNC; { GlidePoint (PS/2) `tapping'
+                                                * Yes! this is the same bit
+                                                * as SYNC!
+                                                }
+
+       MOUSE_PS2_XNEG           = $10;
+       MOUSE_PS2_YNEG           = $20;
+       MOUSE_PS2_XOVERFLOW      = $40;
+       MOUSE_PS2_YOVERFLOW      = $80;
+
+{ Logitech MouseMan+ (PS/2) data packet (PS/2++ protocol) }
+       MOUSE_PS2PLUS_SYNCMASK   = $48;
+       MOUSE_PS2PLUS_SYNC       = $48;
+       MOUSE_PS2PLUS_ZNEG       = $08;  { sign bit }
+       MOUSE_PS2PLUS_BUTTON4DOWN = $10; { 4th button on MouseMan+ }
+       MOUSE_PS2PLUS_BUTTON5DOWN = $20;
+
+{ IBM ScrollPoint (PS/2) also uses PS/2++ protocol }
+       MOUSE_SPOINT_ZNEG        = $80;  { sign bits }
+       MOUSE_SPOINT_WNEG        = $08;
+
+{ MS IntelliMouse (PS/2) data packet }
+       MOUSE_PS2INTELLI_PACKETSIZE = 4;
+{ some compatible mice have additional buttons }
+       MOUSE_PS2INTELLI_BUTTON4DOWN = $40;
+       MOUSE_PS2INTELLI_BUTTON5DOWN = $80;
+
+{ MS IntelliMouse Explorer (PS/2) data packet (variation of IntelliMouse) }
+       MOUSE_EXPLORER_ZNEG        = $08;        { sign bit }
+{ IntelliMouse Explorer has additional button data in the fourth byte }
+       MOUSE_EXPLORER_BUTTON4DOWN = $10;
+       MOUSE_EXPLORER_BUTTON5DOWN = $20;
+
+{ Interlink VersaPad (serial I/F) data packet }
+       MOUSE_VERSA_PACKETSIZE   = 6;
+       MOUSE_VERSA_IN_USE       = $04;
+       MOUSE_VERSA_SYNCMASK     = $c3;
+       MOUSE_VERSA_SYNC         = $c0;
+       MOUSE_VERSA_BUTTONS      = $30;
+       MOUSE_VERSA_BUTTON1DOWN  = $20;  { left }
+       MOUSE_VERSA_BUTTON2DOWN  = $00;  { middle }
+       MOUSE_VERSA_BUTTON3DOWN  = $10;  { right }
+       MOUSE_VERSA_TAP          = $08;
+
+{ Interlink VersaPad (PS/2 I/F) data packet }
+       MOUSE_PS2VERSA_PACKETSIZE        = 6;
+       MOUSE_PS2VERSA_IN_USE            = $10;
+       MOUSE_PS2VERSA_SYNCMASK          = $e8;
+       MOUSE_PS2VERSA_SYNC              = $c8;
+       MOUSE_PS2VERSA_BUTTONS           = $05;
+       MOUSE_PS2VERSA_BUTTON1DOWN       = $04;  { left }
+       MOUSE_PS2VERSA_BUTTON2DOWN       = $00;  { middle }
+       MOUSE_PS2VERSA_BUTTON3DOWN       = $01;  { right }
+       MOUSE_PS2VERSA_TAP               = $02;
+
+{ A4 Tech 4D Mouse (PS/2) data packet }
+       MOUSE_4D_PACKETSIZE              = 3;
+       MOUSE_4D_WHEELBITS               = $f0;
+
+{ A4 Tech 4D+ Mouse (PS/2) data packet }
+       MOUSE_4DPLUS_PACKETSIZE          = 3;
+       MOUSE_4DPLUS_ZNEG                = $04;  { sign bit }
+       MOUSE_4DPLUS_BUTTON4DOWN         = $08;
+
+{ sysmouse extended data packet }
+{
+ * /dev/sysmouse sends data in two formats, depending on the protocol
+ * level.  At the level 0, format is exactly the same as MousSystems'
+ * five byte packet.  At the level 1, the first five bytes are the same
+ * as at the level 0.  There are additional three bytes which shows
+ * `dz' and the states of additional buttons.  `dz' is expressed as the
+ * sum of the byte 5 and 6 which contain signed seven bit values.
+ * The states of the button 4 though 10 are in the bit 0 though 6 in
+ * the byte 7 respectively: 1 indicates the button is up.
+ }
+       MOUSE_SYS_PACKETSIZE     = 8;
+       MOUSE_SYS_SYNCMASK       = $f8;
+       MOUSE_SYS_SYNC           = $80;
+       MOUSE_SYS_BUTTON1UP      = $04;  { left, 1st byte }
+       MOUSE_SYS_BUTTON2UP      = $02;  { middle, 1st byte }
+       MOUSE_SYS_BUTTON3UP      = $01;  { right, 1st byte }
+       MOUSE_SYS_BUTTON4UP      = $0001;        { 7th byte }
+       MOUSE_SYS_BUTTON5UP      = $0002;
+       MOUSE_SYS_BUTTON6UP      = $0004;
+       MOUSE_SYS_BUTTON7UP      = $0008;
+       MOUSE_SYS_BUTTON8UP      = $0010;
+       MOUSE_SYS_BUTTON9UP      = $0020;
+       MOUSE_SYS_BUTTON10UP     = $0040;
+       MOUSE_SYS_MAXBUTTON      = 10;
+       MOUSE_SYS_STDBUTTONS     = $07;
+       MOUSE_SYS_EXTBUTTONS     = $7f;  { the others }
+
+{ Mouse remote socket }
+       _PATH_MOUSEREMOTE        ='/var/run/MouseRemote';
+
+
+{fbio FpIoctl numbers}
+           nr_FBIOGTYPE     =$40184600;
+           nr_FBIOGINFO     =$40184602;
+           nr_FBIOPUTCMAP     =$80144603;
+           nr_FBIOGETCMAP     =$80144604;
+           nr_FBIOGATTR     =$40584606;
+           nr_FBIOSVIDEO     =$80044607;
+           nr_FBIOGVIDEO     =$40044608;
+           nr_FBIOSCURSOR     =$802c4618;
+           nr_FBIOGCURSOR     =$c02c4619;
+           nr_FBIOSCURPOS     =$8004461a;
+           nr_FBIOGCURPOS     =$8004461b;
+           nr_FBIOGCURMAX     =$4004461c;
+           nr_FBIO_ADAPTER     =$40044664;
+           nr_FBIO_ADPTYPE     =$40044665;
+           nr_FBIO_ADPINFO     =$40a44666;
+           nr_FBIO_MODEINFO     =$c09c4667;
+           nr_FBIO_FINDMODE     =$c09c4668;
+           nr_FBIO_GETMODE     =$40044669;
+           nr_FBIO_SETMODE     =$8004466a;
+           nr_FBIO_GETWINORG     =$4004466b;
+           nr_FBIO_SETWINORG     =$8004466c;
+           nr_FBIO_GETDISPSTART     =$4008466d;
+           nr_FBIO_SETDISPSTART     =$8008466e;
+           nr_FBIO_GETLINEWIDTH     =$4004466f;
+           nr_FBIO_SETLINEWIDTH     =$80044670;
+           nr_FBIO_GETPALETTE     =$80184671;
+           nr_FBIO_SETPALETTE     =$80184672;
+
+{consio FpIoctl numbers}
+
+           nr_KDGETMODE     =$40044b09;
+           nr_KDSETMODE     =$20004b0a;
+           nr_KDSBORDER     =$20004b0d;
+           nr_KDRASTER     =$800c4b64;
+           nr_GIO_SCRNMAP     =$41006b02;
+           nr_PIO_SCRNMAP     =$81006b03;
+           nr_GIO_ATTR     =$40046100;
+           nr_GIO_COLOR     =$40046300;
+           nr_CONS_CURRENT     =$40046301;
+           nr_CONS_GET     =$40046302;
+           nr_CONS_IO     =$20006303;
+           nr_CONS_BLANKTIME     =$80046304;
+           nr_CONS_SSAVER     =$80186305;
+           nr_CONS_GSAVER     =$c0186306;
+           nr_CONS_CURSORTYPE     =$80046307;
+           nr_CONS_BELLTYPE     =$80046308;
+           nr_CONS_HISTORY     =$80046309;
+           nr_CONS_MOUSECTL     =$c014630a;
+           nr_CONS_IDLE     =$4004630b;
+           nr_CONS_SAVERMODE     =$8004630c;
+           nr_CONS_SAVERSTART     =$8004630d;
+           nr_PIO_FONT8x8     =$88006340;
+           nr_GIO_FONT8x8     =$48006341;
+           nr_PIO_FONT8x14     =$8e006342;
+           nr_GIO_FONT8x14     =$4e006343;
+           nr_PIO_FONT8x16     =$90006344;
+           nr_GIO_FONT8x16     =$50006345;
+           nr_CONS_GETINFO     =$c0146349;
+           nr_CONS_GETVERS     =$4004634a;
+           nr_CONS_CURRENTADP     =$40046364;
+           nr_CONS_ADPINFO     =$c0a46365;
+           nr_CONS_MODEINFO     =$c09c6366;
+           nr_CONS_FINDMODE     =$c09c6367;
+           nr_CONS_SETWINORG     =$20006368;
+           nr_CONS_SETKBD     =$2000636e;
+           nr_CONS_RELKBD     =$2000636f;
+           nr_CONS_GETTERM     =$c0686370;
+           nr_CONS_SETTERM     =$80686371;
+           nr_ADJUST_CLOCK     =$20007464;
+           nr_VT_OPENQRY     =$40047601;
+           nr_VT_SETMODE     =$80087602;
+           nr_VT_GETMODE     =$40087603;
+           nr_VT_RELDISP     =$20007604;
+           nr_VT_ACTIVATE     =$20007605;
+           nr_VT_WAITACTIVE     =$20007606;
+           nr_VT_GETACTIVE     =$40047607;
+           nr_VT_GETINDEX     =$40047608;
+           nr_SW_B40x25     =$20005300;
+           nr_SW_C40x25     =$20005301;
+           nr_SW_B80x25     =$20005302;
+           nr_SW_C80x25     =$20005303;
+           nr_SW_BG320     =$20005304;
+           nr_SW_CG320     =$20005305;
+           nr_SW_BG640     =$20005306;
+           nr_SW_EGAMONO80x25     =$20005307;
+           nr_SW_CG320_D     =$2000530d;
+           nr_SW_CG640_E     =$2000530e;
+           nr_SW_EGAMONOAPA     =$2000530f;
+           nr_SW_CG640x350     =$20005310;
+           nr_SW_ENH_MONOAPA2     =$20005311;
+           nr_SW_ENH_CG640     =$20005312;
+           nr_SW_ENH_B40x25     =$20005313;
+           nr_SW_ENH_C40x25     =$20005314;
+           nr_SW_ENH_B80x25     =$20005315;
+           nr_SW_ENH_C80x25     =$20005316;
+           nr_SW_ENH_B80x43     =$20005370;
+           nr_SW_ENH_C80x43     =$20005371;
+           nr_SW_MCAMODE     =$200053ff;
+           nr_SW_VGA_C40x25     =$20005317;
+           nr_SW_VGA_C80x25     =$20005318;
+           nr_SW_VGA_C80x30     =$20005320;
+           nr_SW_VGA_C80x50     =$2000531e;
+           nr_SW_VGA_C80x60     =$20005322;
+           nr_SW_VGA_M80x25     =$20005319;
+           nr_SW_VGA_M80x30     =$20005321;
+           nr_SW_VGA_M80x50     =$2000531f;
+           nr_SW_VGA_M80x60     =$20005323;
+           nr_SW_VGA11     =$2000531a;
+           nr_SW_BG640x480     =$2000531a;
+           nr_SW_VGA12     =$2000531b;
+           nr_SW_CG640x480     =$2000531b;
+           nr_SW_VGA13     =$2000531c;
+           nr_SW_VGA_CG320     =$2000531c;
+           nr_SW_VGA_CG640     =$20005324;
+           nr_SW_VGA_MODEX     =$20005325;
+           nr_SW_PC98_80x25     =$20005362;
+           nr_SW_PC98_80x30     =$20005363;
+           nr_SW_PC98_EGC640x400     =$20005364;
+           nr_SW_PC98_PEGC640x400     =$20005365;
+           nr_SW_PC98_PEGC640x480     =$20005366;
+           nr_SW_VGA_C90x25     =$20005328;
+           nr_SW_VGA_M90x25     =$20005329;
+           nr_SW_VGA_C90x30     =$2000532a;
+           nr_SW_VGA_M90x30     =$2000532b;
+           nr_SW_VGA_C90x43     =$2000532c;
+           nr_SW_VGA_M90x43     =$2000532d;
+           nr_SW_VGA_C90x50     =$2000532e;
+           nr_SW_VGA_M90x50     =$2000532f;
+           nr_SW_VGA_C90x60     =$20005330;
+           nr_SW_VGA_M90x60     =$20005331;
+           nr_SW_TEXT_80x25     =$200053c8;
+           nr_SW_TEXT_80x30     =$200053c9;
+           nr_SW_TEXT_80x43     =$200053ca;
+           nr_SW_TEXT_80x50     =$200053cb;
+           nr_SW_TEXT_80x60     =$200053cc;
+           nr_SW_TEXT_132x25     =$200053cd;
+           nr_SW_TEXT_132x30     =$200053ce;
+           nr_SW_TEXT_132x43     =$200053cf;
+           nr_SW_TEXT_132x50     =$200053d0;
+           nr_SW_TEXT_132x60     =$200053d1;
+           nr_SW_VESA_CG640x400     =$20005600;
+           nr_SW_VESA_CG640x480     =$20005601;
+           nr_SW_VESA_800x600     =$20005602;
+           nr_SW_VESA_CG800x600     =$20005603;
+           nr_SW_VESA_1024x768     =$20005604;
+           nr_SW_VESA_CG1024x768     =$20005605;
+           nr_SW_VESA_1280x1024     =$20005606;
+           nr_SW_VESA_CG1280x1024     =$20005607;
+           nr_SW_VESA_C80x60     =$20005608;
+           nr_SW_VESA_C132x25     =$20005609;
+           nr_SW_VESA_C132x43     =$2000560a;
+           nr_SW_VESA_C132x50     =$2000560b;
+           nr_SW_VESA_C132x60     =$2000560c;
+           nr_SW_VESA_32K_320     =$2000560d;
+           nr_SW_VESA_64K_320     =$2000560e;
+           nr_SW_VESA_FULL_320     =$2000560f;
+           nr_SW_VESA_32K_640     =$20005610;
+           nr_SW_VESA_64K_640     =$20005611;
+           nr_SW_VESA_FULL_640     =$20005612;
+           nr_SW_VESA_32K_800     =$20005613;
+           nr_SW_VESA_64K_800     =$20005614;
+           nr_SW_VESA_FULL_800     =$20005615;
+           nr_SW_VESA_32K_1024     =$20005616;
+           nr_SW_VESA_64K_1024     =$20005617;
+           nr_SW_VESA_FULL_1024     =$20005618;
+           nr_SW_VESA_32K_1280     =$20005619;
+           nr_SW_VESA_64K_1280     =$2000561a;
+           nr_SW_VESA_FULL_1280     =$2000561b;
+
+{kbdsio FpIoctl numbers}
+
+           nr_KDGKBMODE     =$40044b06;
+           nr_KDSKBMODE     =$20004b07;
+           nr_KDMKTONE     =$20004b08;
+{$ifndef definconsole}
+           nr_KDGETMODE     =$40044b09;
+           nr_KDSETMODE     =$20004b0a;
+           nr_KDSBORDER     =$20004b0d;
+{$endif}
+           nr_KDGKBSTATE     =$40044b13;
+           nr_KDSKBSTATE     =$20004b14;
+           nr_KDENABIO     =$20004b3c;
+           nr_KDDISABIO     =$20004b3d;
+           nr_KIOCSOUND     =$20004b3f;
+           nr_KDGKBTYPE     =$40044b40;
+           nr_KDGETLED     =$40044b41;
+           nr_KDSETLED     =$20004b42;
+           nr_KDSETRAD     =$20004b43;
+{$ifndef definconsole}
+           nr_KDRASTER     =$800c4b64;
+{$endif}
+           nr_KDGKBINFO     =$40244b65;
+           nr_KDSETREPEAT     =$80084b66;
+           nr_KDGETREPEAT     =$40084b67;
+           nr_GETFKEY     =$c0146b00;
+           nr_SETFKEY     =$c0146b01;
+{$ifndef definconsole}
+           nr_GIO_SCRNMAP     =$41006b02;
+           nr_PIO_SCRNMAP     =$81006b03;
+{$endif}
+           nr_GIO_KEYMAP     =$4a026b06;
+           nr_PIO_KEYMAP     =$8a026b07;
+           nr_GIO_DEADKEYMAP     =$462a6b08;
+           nr_PIO_DEADKEYMAP     =$862a6b09;
+           nr_GIO_KEYMAPENT     =$c00c6b0a;
+           nr_PIO_KEYMAPENT     =$800c6b0b;
+
+
+
+{mouse FpIoctl numbers}
+           nr_MOUSE_GETSTATUS     =$40184d00;
+           nr_MOUSE_GETHWINFO     =$40144d01;
+           nr_MOUSE_GETMODE     =$401c4d02;
+           nr_MOUSE_SETMODE     =$801c4d03;
+           nr_MOUSE_GETLEVEL     =$40044d04;
+           nr_MOUSE_SETLEVEL     =$80044d05;
+           nr_MOUSE_GETVARS     =$40404d06;
+           nr_MOUSE_SETVARS     =$80404d07;
+           nr_MOUSE_READSTATE     =$c0444d08;
+           nr_MOUSE_READDATA     =$c0444d09;
+           nr_MOUSE_SETRESOLUTION     =$80044d0a;
+           nr_MOUSE_SETSCALING     =$80044d0b;
+           nr_MOUSE_SETRATE     =$80044d0c;
+           nr_MOUSE_GETHWID     =$40044d0d;
+
+{------------- Added procedures ---------------}
+
+function physicalconsole(fd:longint) : boolean;
+
+IMPLEMENTATION
+
+Uses BaseUnix,termio;
+
+function physicalconsole(fd:longint) : boolean;
+
+var name:string;
+
+begin
+ if (isatty(fd)<>-1) then
+  begin
+   name:=ttyname(fd);
+   if Copy(name,1,8)<>'/dev/tty' then
+    physicalconsole:=false              {isatty is true, but not /dev/tty.
+                                           Could be /dev/pts support, but
+                                           I reserve the case}
+   else
+    begin
+     if name[9]='v' then                        {ttyv is phys console. see /etc/ttys}
+      physicalconsole:=true
+     else
+      physicalconsole:=false;
+    end;
+  end
+ else
+  physicalconsole:=false;       {Not a tty, then I don't know what it is}
+end;
+
+{other macros (not FpIoctl)}
+
+function KEYCHAR(c:longint):longint;
+
+begin
+  c:=c and $FF;
+end;
+
+function KEYFLAGS(c:longint):longint;
+
+begin
+  c:=c and NOT $FF;
+end;
+
+function kbio_F(x:longint):longint;
+begin
+ kbio_f:=x+F_FN-1;
+end;
+
+function kbio_S(x:longint):longint;
+begin
+ kbio_S:=x+F_SCR-1;
+end;
+
+function kbio_ACC(x:longint):longint;
+begin
+ kbio_ACC:=x+F_ACC;
+end;
+
+{fbio.h FpIoctl's}
+
+Function FBIOGTYPE(fd:longint;var param1 : fbtype):boolean;
+{IOR('F',0,sizeof(struct fbtype) }
+
+Begin
+ FBIOGTYPE:=FpIoctl(fd,nr_FBIOGTYPE,@param1)=0;
+end;
+
+Function FBIOGINFO(fd:longint;var param1 : fbinfo):boolean;
+{IOR('F',2,sizeof(struct fbinfo) }
+
+Begin
+ FBIOGINFO:=FpIoctl(fd,nr_FBIOGINFO,@param1)=0;
+end;
+
+Function FBIOPUTCMAP(fd:longint;var param1 : fbcmap):boolean;
+{IOW('F',3,sizeof(struct fbcmap) }
+
+Begin
+ FBIOPUTCMAP:=FpIoctl(fd,nr_FBIOPUTCMAP,@param1)=0;
+end;
+
+Function FBIOGETCMAP(fd:longint;var param1 : fbcmap):boolean;
+{IOW('F',4,sizeof(struct fbcmap) }
+
+Begin
+ FBIOGETCMAP:=FpIoctl(fd,nr_FBIOGETCMAP,@param1)=0;
+end;
+
+Function FBIOGATTR(fd:longint;var param1 : fbgattr):boolean;
+{IOR('F',6,sizeof(struct fbgattr) }
+
+Begin
+ FBIOGATTR:=FpIoctl(fd,nr_FBIOGATTR,@param1)=0;
+end;
+
+Function FBIOSVIDEO(fd:longint;var param1 : longint):boolean;
+{IOW('F',7,sizeof(int) }
+
+Begin
+ FBIOSVIDEO:=FpIoctl(fd,nr_FBIOSVIDEO,@param1)=0;
+end;
+
+Function FBIOGVIDEO(fd:longint;var param1 : longint):boolean;
+{IOR('F',8,sizeof(int) }
+
+Begin
+ FBIOGVIDEO:=FpIoctl(fd,nr_FBIOGVIDEO,@param1)=0;
+end;
+
+Function FBIOSCURSOR(fd:longint;var param1 : fbcursor):boolean;
+{IOW('F',24,sizeof(struct fbcursor) }
+
+Begin
+ FBIOSCURSOR:=FpIoctl(fd,nr_FBIOSCURSOR,@param1)=0;
+end;
+
+Function FBIOGCURSOR(fd:longint;var param1 : fbcursor):boolean;
+{IOWR('F',25,sizeof(struct fbcursor) }
+
+Begin
+ FBIOGCURSOR:=FpIoctl(fd,nr_FBIOGCURSOR,@param1)=0;
+end;
+
+Function FBIOSCURPOS(fd:longint;var param1 : fbcurpos):boolean;
+{IOW('F',26,sizeof(struct fbcurpos) }
+
+Begin
+ FBIOSCURPOS:=FpIoctl(fd,nr_FBIOSCURPOS,@param1)=0;
+end;
+
+Function FBIOGCURPOS(fd:longint;var param1 : fbcurpos):boolean;
+{IOW('F',27,sizeof(struct fbcurpos) }
+
+Begin
+ FBIOGCURPOS:=FpIoctl(fd,nr_FBIOGCURPOS,@param1)=0;
+end;
+
+Function FBIOGCURMAX(fd:longint;var param1 : fbcurpos):boolean;
+{IOR('F',28,sizeof(struct fbcurpos) }
+
+Begin
+ FBIOGCURMAX:=FpIoctl(fd,nr_FBIOGCURMAX,@param1)=0;
+end;
+
+Function FBIO_ADAPTER(fd:longint;var param1 : longint):boolean;
+{IOR('F',100,sizeof(int) }
+
+Begin
+ FBIO_ADAPTER:=FpIoctl(fd,nr_FBIO_ADAPTER,@param1)=0;
+end;
+
+Function FBIO_ADPTYPE(fd:longint;var param1 : longint):boolean;
+{IOR('F',101,sizeof(int) }
+
+Begin
+ FBIO_ADPTYPE:=FpIoctl(fd,nr_FBIO_ADPTYPE,@param1)=0;
+end;
+
+Function FBIO_ADPINFO(fd:longint;var param1 : video_adapter_info):boolean;
+{IOR('F',102,sizeof(struct video_adapter_info) }
+
+Begin
+ FBIO_ADPINFO:=FpIoctl(fd,nr_FBIO_ADPINFO,@param1)=0;
+end;
+
+Function FBIO_MODEINFO(fd:longint;var param1 : video_info):boolean;
+{IOWR('F',103,sizeof(struct video_info) }
+
+Begin
+ FBIO_MODEINFO:=FpIoctl(fd,nr_FBIO_MODEINFO,@param1)=0;
+end;
+
+Function FBIO_FINDMODE(fd:longint;var param1 : video_info):boolean;
+{IOWR('F',104,sizeof(struct video_info) }
+
+Begin
+ FBIO_FINDMODE:=FpIoctl(fd,nr_FBIO_FINDMODE,@param1)=0;
+end;
+
+Function FBIO_GETMODE(fd:longint;var param1 : longint):boolean;
+{IOR('F',105,sizeof(int) }
+
+Begin
+ FBIO_GETMODE:=FpIoctl(fd,nr_FBIO_GETMODE,@param1)=0;
+end;
+
+Function FBIO_SETMODE(fd:longint;var param1 : longint):boolean;
+{IOW('F',106,sizeof(int) }
+
+Begin
+ FBIO_SETMODE:=FpIoctl(fd,nr_FBIO_SETMODE,@param1)=0;
+end;
+
+Function FBIO_GETWINORG(fd:longint;var param1 : u_int):boolean;
+{IOR('F',107,sizeof(u_int) }
+
+Begin
+ FBIO_GETWINORG:=FpIoctl(fd,nr_FBIO_GETWINORG,@param1)=0;
+end;
+
+Function FBIO_SETWINORG(fd:longint;var param1 : u_int):boolean;
+{IOW('F',108,sizeof(u_int) }
+
+Begin
+ FBIO_SETWINORG:=FpIoctl(fd,nr_FBIO_SETWINORG,@param1)=0;
+end;
+
+Function FBIO_GETDISPSTART(fd:longint;var param1 : video_display_start_t):boolean;
+{IOR('F',109,sizeof(video_display_start_t) }
+
+Begin
+ FBIO_GETDISPSTART:=FpIoctl(fd,nr_FBIO_GETDISPSTART,@param1)=0;
+end;
+
+Function FBIO_SETDISPSTART(fd:longint;var param1 : video_display_start_t):boolean;
+{IOW('F',110,sizeof(video_display_start_t) }
+
+Begin
+ FBIO_SETDISPSTART:=FpIoctl(fd,nr_FBIO_SETDISPSTART,@param1)=0;
+end;
+
+Function FBIO_GETLINEWIDTH(fd:longint;var param1 : u_int):boolean;
+{IOR('F',111,sizeof(u_int) }
+
+Begin
+ FBIO_GETLINEWIDTH:=FpIoctl(fd,nr_FBIO_GETLINEWIDTH,@param1)=0;
+end;
+
+Function FBIO_SETLINEWIDTH(fd:longint;var param1 : u_int):boolean;
+{IOW('F',112,sizeof(u_int) }
+
+Begin
+ FBIO_SETLINEWIDTH:=FpIoctl(fd,nr_FBIO_SETLINEWIDTH,@param1)=0;
+end;
+
+Function FBIO_GETPALETTE(fd:longint;var param1 : video_color_palette_t):boolean;
+{IOW('F',113,sizeof(video_color_palette_t) }
+
+Begin
+ FBIO_GETPALETTE:=FpIoctl(fd,nr_FBIO_GETPALETTE,@param1)=0;
+end;
+
+Function FBIO_SETPALETTE(fd:longint;var param1 : video_color_palette_t):boolean;
+{IOW('F',114,sizeof(video_color_palette_t) }
+
+Begin
+ FBIO_SETPALETTE:=FpIoctl(fd,nr_FBIO_SETPALETTE,@param1)=0;
+end;
+
+
+{consio.h FpIoctl's}
+
+Function KDGETMODE(fd:longint;var param1 : longint):boolean;
+{IOR('K',9,sizeof(int) }
+
+Begin
+ KDGETMODE:=FpIoctl(fd,nr_KDGETMODE,@param1)=0;
+end;
+
+Function KDSETMODE(fd:longint;param1 : longint):boolean;
+{IO('K',10 /* int */));
+ }
+
+Begin
+ KDSETMODE:=FpIoctl(fd,nr_KDSETMODE,pointer(param1))=0;
+end;
+
+Function KDSBORDER(fd:longint;param1 : longint):boolean;
+{IO('K',13 /* int */));
+ }
+
+Begin
+ KDSBORDER:=FpIoctl(fd,nr_KDSBORDER,pointer(param1))=0;
+end;
+
+Function KDRASTER(fd:longint;var param1 : scr_size_t):boolean;
+{IOW('K',100,sizeof(scr_size_t) }
+
+Begin
+ KDRASTER:=FpIoctl(fd,nr_KDRASTER,@param1)=0;
+end;
+
+Function GIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+{IOR('k',2,sizeof(scrmap_t) }
+
+Begin
+ GIO_SCRNMAP:=FpIoctl(fd,nr_GIO_SCRNMAP,@param1)=0;
+end;
+
+Function PIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+{IOW('k',3,sizeof(scrmap_t) }
+
+Begin
+ PIO_SCRNMAP:=FpIoctl(fd,nr_PIO_SCRNMAP,@param1)=0;
+end;
+
+Function GIO_ATTR(fd:longint;var param1 : longint):boolean;
+{IOR('a',0,sizeof(int) }
+
+Begin
+ GIO_ATTR:=FpIoctl(fd,nr_GIO_ATTR,@param1)=0;
+end;
+
+Function GIO_COLOR(fd:longint;var param1 : longint):boolean;
+{IOR('c',0,sizeof(int) }
+
+Begin
+ GIO_COLOR:=FpIoctl(fd,nr_GIO_COLOR,@param1)=0;
+end;
+
+Function CONS_CURRENT(fd:longint;var param1 : longint):boolean;
+{IOR('c',1,sizeof(int) }
+
+Begin
+ CONS_CURRENT:=FpIoctl(fd,nr_CONS_CURRENT,@param1)=0;
+end;
+
+Function CONS_GET(fd:longint;var param1 : longint):boolean;
+{IOR('c',2,sizeof(int) }
+
+Begin
+ CONS_GET:=FpIoctl(fd,nr_CONS_GET,@param1)=0;
+end;
+
+Function CONS_IO(fd:longint):boolean;
+{IO('c',3));
+ }
+
+Begin
+ CONS_IO:=FpIoctl(fd,nr_CONS_IO,nil)=0;
+end;
+
+Function CONS_BLANKTIME(fd:longint;var param1 : longint):boolean;
+{IOW('c',4,sizeof(int) }
+
+Begin
+ CONS_BLANKTIME:=FpIoctl(fd,nr_CONS_BLANKTIME,@param1)=0;
+end;
+
+Function CONS_SSAVER(fd:longint;var param1 : ssaver_t):boolean;
+{IOW('c',5,sizeof(ssaver_t) }
+
+Begin
+ CONS_SSAVER:=FpIoctl(fd,nr_CONS_SSAVER,@param1)=0;
+end;
+
+Function CONS_GSAVER(fd:longint;var param1 : ssaver_t):boolean;
+{IOWR('c',6,sizeof(ssaver_t) }
+
+Begin
+ CONS_GSAVER:=FpIoctl(fd,nr_CONS_GSAVER,@param1)=0;
+end;
+
+Function CONS_CURSORTYPE(fd:longint;var param1 : longint):boolean;
+{IOW('c',7,sizeof(int) }
+
+Begin
+ CONS_CURSORTYPE:=FpIoctl(fd,nr_CONS_CURSORTYPE,@param1)=0;
+end;
+
+Function CONS_BELLTYPE(fd:longint;var param1 : longint):boolean;
+{IOW('c',8,sizeof(int) }
+
+Begin
+ CONS_BELLTYPE:=FpIoctl(fd,nr_CONS_BELLTYPE,@param1)=0;
+end;
+
+Function CONS_HISTORY(fd:longint;var param1 : longint):boolean;
+{IOW('c',9,sizeof(int) }
+
+Begin
+ CONS_HISTORY:=FpIoctl(fd,nr_CONS_HISTORY,@param1)=0;
+end;
+
+Function CONS_MOUSECTL(fd:longint;var param1 : mouse_info_t):boolean;
+{IOWR('c',10,sizeof(mouse_info_t) }
+
+Begin
+ CONS_MOUSECTL:=FpIoctl(fd,nr_CONS_MOUSECTL,@param1)=0;
+end;
+
+Function CONS_IDLE(fd:longint;var param1 : longint):boolean;
+{IOR('c',11,sizeof(int) }
+
+Begin
+ CONS_IDLE:=FpIoctl(fd,nr_CONS_IDLE,@param1)=0;
+end;
+
+Function CONS_SAVERMODE(fd:longint;var param1 : longint):boolean;
+{IOW('c',12,sizeof(int) }
+
+Begin
+ CONS_SAVERMODE:=FpIoctl(fd,nr_CONS_SAVERMODE,@param1)=0;
+end;
+
+Function CONS_SAVERSTART(fd:longint;var param1 : longint):boolean;
+{IOW('c',13,sizeof(int) }
+
+Begin
+ CONS_SAVERSTART:=FpIoctl(fd,nr_CONS_SAVERSTART,@param1)=0;
+end;
+
+Function PIO_FONT8x8(fd:longint;var param1 : fnt8_t):boolean;
+{IOW('c',64,sizeof(fnt8_t) }
+
+Begin
+ PIO_FONT8x8:=FpIoctl(fd,nr_PIO_FONT8x8,@param1)=0;
+end;
+
+Function GIO_FONT8x8(fd:longint;var param1 : fnt8_t):boolean;
+{IOR('c',65,sizeof(fnt8_t) }
+
+Begin
+ GIO_FONT8x8:=FpIoctl(fd,nr_GIO_FONT8x8,@param1)=0;
+end;
+
+Function PIO_FONT8x14(fd:longint;var param1 : fnt14_t):boolean;
+{IOW('c',66,sizeof(fnt14_t) }
+
+Begin
+ PIO_FONT8x14:=FpIoctl(fd,nr_PIO_FONT8x14,@param1)=0;
+end;
+
+Function GIO_FONT8x14(fd:longint;var param1 : fnt14_t):boolean;
+{IOR('c',67,sizeof(fnt14_t) }
+
+Begin
+ GIO_FONT8x14:=FpIoctl(fd,nr_GIO_FONT8x14,@param1)=0;
+end;
+
+Function PIO_FONT8x16(fd:longint;var param1 : fnt16_t):boolean;
+{IOW('c',68,sizeof(fnt16_t) }
+
+Begin
+ PIO_FONT8x16:=FpIoctl(fd,nr_PIO_FONT8x16,@param1)=0;
+end;
+
+Function GIO_FONT8x16(fd:longint;var param1 : fnt16_t):boolean;
+{IOR('c',69,sizeof(fnt16_t) }
+
+Begin
+ GIO_FONT8x16:=FpIoctl(fd,nr_GIO_FONT8x16,@param1)=0;
+end;
+
+Function CONS_GETINFO(fd:longint;var param1 : vid_info_t):boolean;
+{IOWR('c',73,sizeof(vid_info_t) }
+
+Begin
+ CONS_GETINFO:=FpIoctl(fd,nr_CONS_GETINFO,@param1)=0;
+end;
+
+Function CONS_GETVERS(fd:longint;var param1 : longint):boolean;
+{IOR('c',74,sizeof(int) }
+
+Begin
+ CONS_GETVERS:=FpIoctl(fd,nr_CONS_GETVERS,@param1)=0;
+end;
+
+Function CONS_CURRENTADP(fd:longint;var param1 : longint):boolean;
+{IOR('c',100,sizeof(int) }
+
+Begin
+ CONS_CURRENTADP:=FpIoctl(fd,nr_CONS_CURRENTADP,@param1)=0;
+end;
+
+Function CONS_ADPINFO(fd:longint;var param1 : video_adapter_info_t):boolean;
+{IOWR('c',101,sizeof(video_adapter_info_t) }
+
+Begin
+ CONS_ADPINFO:=FpIoctl(fd,nr_CONS_ADPINFO,@param1)=0;
+end;
+
+Function CONS_MODEINFO(fd:longint;var param1 : video_info_t):boolean;
+{IOWR('c',102,sizeof(video_info_t) }
+
+Begin
+ CONS_MODEINFO:=FpIoctl(fd,nr_CONS_MODEINFO,@param1)=0;
+end;
+
+Function CONS_FINDMODE(fd:longint;var param1 : video_info_t):boolean;
+{IOWR('c',103,sizeof(video_info_t) }
+
+Begin
+ CONS_FINDMODE:=FpIoctl(fd,nr_CONS_FINDMODE,@param1)=0;
+end;
+
+Function CONS_SETWINORG(fd:longint;param1 : longint):boolean;
+{IO('c',104 /* int */));
+ }
+
+Begin
+ CONS_SETWINORG:=FpIoctl(fd,nr_CONS_SETWINORG,pointer(param1))=0;
+end;
+
+Function CONS_SETKBD(fd:longint;param1 : longint):boolean;
+{IO('c',110 /* int */));
+ }
+
+Begin
+ CONS_SETKBD:=FpIoctl(fd,nr_CONS_SETKBD,pointer(param1))=0;
+end;
+
+Function CONS_RELKBD(fd:longint):boolean;
+{IO('c',111));
+ }
+
+Begin
+ CONS_RELKBD:=FpIoctl(fd,nr_CONS_RELKBD,nil)=0;
+end;
+
+Function CONS_GETTERM(fd:longint;var param1 : term_info_t):boolean;
+{IOWR('c',112,sizeof(term_info_t) }
+
+Begin
+ CONS_GETTERM:=FpIoctl(fd,nr_CONS_GETTERM,@param1)=0;
+end;
+
+Function CONS_SETTERM(fd:longint;var param1 : term_info_t):boolean;
+{IOW('c',113,sizeof(term_info_t) }
+
+Begin
+ CONS_SETTERM:=FpIoctl(fd,nr_CONS_SETTERM,@param1)=0;
+end;
+
+Function ADJUST_CLOCK(fd:longint):boolean;
+{IO('t',100));
+ }
+
+Begin
+ ADJUST_CLOCK:=FpIoctl(fd,nr_ADJUST_CLOCK,nil)=0;
+end;
+
+Function VT_OPENQRY(fd:longint;var param1 : longint):boolean;
+{IOR('v',1,sizeof(int) }
+
+Begin
+ VT_OPENQRY:=FpIoctl(fd,nr_VT_OPENQRY,@param1)=0;
+end;
+
+Function VT_SETMODE(fd:longint;var param1 : vtmode_t):boolean;
+{IOW('v',2,sizeof(vtmode_t) }
+
+Begin
+ VT_SETMODE:=FpIoctl(fd,nr_VT_SETMODE,@param1)=0;
+end;
+
+Function VT_GETMODE(fd:longint;var param1 : vtmode_t):boolean;
+{IOR('v',3,sizeof(vtmode_t) }
+
+Begin
+ VT_GETMODE:=FpIoctl(fd,nr_VT_GETMODE,@param1)=0;
+end;
+
+Function VT_RELDISP(fd:longint;param1 : longint):boolean;
+{IO('v',4 /* int */));
+ }
+
+Begin
+ VT_RELDISP:=FpIoctl(fd,nr_VT_RELDISP,pointer(param1))=0;
+end;
+
+Function VT_ACTIVATE(fd:longint;param1 : longint):boolean;
+{IO('v',5 /* int */));
+ }
+
+Begin
+ VT_ACTIVATE:=FpIoctl(fd,nr_VT_ACTIVATE,pointer(param1))=0;
+end;
+
+Function VT_WAITACTIVE(fd:longint;param1 : longint):boolean;
+{IO('v',6 /* int */));
+ }
+
+Begin
+ VT_WAITACTIVE:=FpIoctl(fd,nr_VT_WAITACTIVE,pointer(param1))=0;
+end;
+
+Function VT_GETACTIVE(fd:longint;var param1 : longint):boolean;
+{IOR('v',7,sizeof(int) }
+
+Begin
+ VT_GETACTIVE:=FpIoctl(fd,nr_VT_GETACTIVE,@param1)=0;
+end;
+
+Function VT_GETINDEX(fd:longint;var param1 : longint):boolean;
+{IOR('v',8,sizeof(int) }
+
+Begin
+ VT_GETINDEX:=FpIoctl(fd,nr_VT_GETINDEX,@param1)=0;
+end;
+
+Function SW_B40x25(fd:longint):boolean;
+{IO('S',M_B40x25));
+ }
+
+Begin
+ SW_B40x25:=FpIoctl(fd,nr_SW_B40x25,nil)=0;
+end;
+
+Function SW_C40x25(fd:longint):boolean;
+{IO('S',M_C40x25));
+ }
+
+Begin
+ SW_C40x25:=FpIoctl(fd,nr_SW_C40x25,nil)=0;
+end;
+
+Function SW_B80x25(fd:longint):boolean;
+{IO('S',M_B80x25));
+ }
+
+Begin
+ SW_B80x25:=FpIoctl(fd,nr_SW_B80x25,nil)=0;
+end;
+
+Function SW_C80x25(fd:longint):boolean;
+{IO('S',M_C80x25));
+ }
+
+Begin
+ SW_C80x25:=FpIoctl(fd,nr_SW_C80x25,nil)=0;
+end;
+
+Function SW_BG320(fd:longint):boolean;
+{IO('S',M_BG320));
+ }
+
+Begin
+ SW_BG320:=FpIoctl(fd,nr_SW_BG320,nil)=0;
+end;
+
+Function SW_CG320(fd:longint):boolean;
+{IO('S',M_CG320));
+ }
+
+Begin
+ SW_CG320:=FpIoctl(fd,nr_SW_CG320,nil)=0;
+end;
+
+Function SW_BG640(fd:longint):boolean;
+{IO('S',M_BG640));
+ }
+
+Begin
+ SW_BG640:=FpIoctl(fd,nr_SW_BG640,nil)=0;
+end;
+
+Function SW_EGAMONO80x25(fd:longint):boolean;
+{IO('S',M_EGAMONO80x25));
+ }
+
+Begin
+ SW_EGAMONO80x25:=FpIoctl(fd,nr_SW_EGAMONO80x25,nil)=0;
+end;
+
+Function SW_CG320_D(fd:longint):boolean;
+{IO('S',M_CG320_D));
+ }
+
+Begin
+ SW_CG320_D:=FpIoctl(fd,nr_SW_CG320_D,nil)=0;
+end;
+
+Function SW_CG640_E(fd:longint):boolean;
+{IO('S',M_CG640_E));
+ }
+
+Begin
+ SW_CG640_E:=FpIoctl(fd,nr_SW_CG640_E,nil)=0;
+end;
+
+Function SW_EGAMONOAPA(fd:longint):boolean;
+{IO('S',M_EGAMONOAPA));
+ }
+
+Begin
+ SW_EGAMONOAPA:=FpIoctl(fd,nr_SW_EGAMONOAPA,nil)=0;
+end;
+
+Function SW_CG640x350(fd:longint):boolean;
+{IO('S',M_CG640x350));
+ }
+
+Begin
+ SW_CG640x350:=FpIoctl(fd,nr_SW_CG640x350,nil)=0;
+end;
+
+Function SW_ENH_MONOAPA2(fd:longint):boolean;
+{IO('S',M_ENHMONOAPA2));
+ }
+
+Begin
+ SW_ENH_MONOAPA2:=FpIoctl(fd,nr_SW_ENH_MONOAPA2,nil)=0;
+end;
+
+Function SW_ENH_CG640(fd:longint):boolean;
+{IO('S',M_ENH_CG640));
+ }
+
+Begin
+ SW_ENH_CG640:=FpIoctl(fd,nr_SW_ENH_CG640,nil)=0;
+end;
+
+Function SW_ENH_B40x25(fd:longint):boolean;
+{IO('S',M_ENH_B40x25));
+ }
+
+Begin
+ SW_ENH_B40x25:=FpIoctl(fd,nr_SW_ENH_B40x25,nil)=0;
+end;
+
+Function SW_ENH_C40x25(fd:longint):boolean;
+{IO('S',M_ENH_C40x25));
+ }
+
+Begin
+ SW_ENH_C40x25:=FpIoctl(fd,nr_SW_ENH_C40x25,nil)=0;
+end;
+
+Function SW_ENH_B80x25(fd:longint):boolean;
+{IO('S',M_ENH_B80x25));
+ }
+
+Begin
+ SW_ENH_B80x25:=FpIoctl(fd,nr_SW_ENH_B80x25,nil)=0;
+end;
+
+Function SW_ENH_C80x25(fd:longint):boolean;
+{IO('S',M_ENH_C80x25));
+ }
+
+Begin
+ SW_ENH_C80x25:=FpIoctl(fd,nr_SW_ENH_C80x25,nil)=0;
+end;
+
+Function SW_ENH_B80x43(fd:longint):boolean;
+{IO('S',M_ENH_B80x43));
+ }
+
+Begin
+ SW_ENH_B80x43:=FpIoctl(fd,nr_SW_ENH_B80x43,nil)=0;
+end;
+
+Function SW_ENH_C80x43(fd:longint):boolean;
+{IO('S',M_ENH_C80x43));
+ }
+
+Begin
+ SW_ENH_C80x43:=FpIoctl(fd,nr_SW_ENH_C80x43,nil)=0;
+end;
+
+Function SW_MCAMODE(fd:longint):boolean;
+{IO('S',M_MCA_MODE));
+ }
+
+Begin
+ SW_MCAMODE:=FpIoctl(fd,nr_SW_MCAMODE,nil)=0;
+end;
+
+Function SW_VGA_C40x25(fd:longint):boolean;
+{IO('S',M_VGA_C40x25));
+ }
+
+Begin
+ SW_VGA_C40x25:=FpIoctl(fd,nr_SW_VGA_C40x25,nil)=0;
+end;
+
+Function SW_VGA_C80x25(fd:longint):boolean;
+{IO('S',M_VGA_C80x25));
+ }
+
+Begin
+ SW_VGA_C80x25:=FpIoctl(fd,nr_SW_VGA_C80x25,nil)=0;
+end;
+
+Function SW_VGA_C80x30(fd:longint):boolean;
+{IO('S',M_VGA_C80x30));
+ }
+
+Begin
+ SW_VGA_C80x30:=FpIoctl(fd,nr_SW_VGA_C80x30,nil)=0;
+end;
+
+Function SW_VGA_C80x50(fd:longint):boolean;
+{IO('S',M_VGA_C80x50));
+ }
+
+Begin
+ SW_VGA_C80x50:=FpIoctl(fd,nr_SW_VGA_C80x50,nil)=0;
+end;
+
+Function SW_VGA_C80x60(fd:longint):boolean;
+{IO('S',M_VGA_C80x60));
+ }
+
+Begin
+ SW_VGA_C80x60:=FpIoctl(fd,nr_SW_VGA_C80x60,nil)=0;
+end;
+
+Function SW_VGA_M80x25(fd:longint):boolean;
+{IO('S',M_VGA_M80x25));
+ }
+
+Begin
+ SW_VGA_M80x25:=FpIoctl(fd,nr_SW_VGA_M80x25,nil)=0;
+end;
+
+Function SW_VGA_M80x30(fd:longint):boolean;
+{IO('S',M_VGA_M80x30));
+ }
+
+Begin
+ SW_VGA_M80x30:=FpIoctl(fd,nr_SW_VGA_M80x30,nil)=0;
+end;
+
+Function SW_VGA_M80x50(fd:longint):boolean;
+{IO('S',M_VGA_M80x50));
+ }
+
+Begin
+ SW_VGA_M80x50:=FpIoctl(fd,nr_SW_VGA_M80x50,nil)=0;
+end;
+
+Function SW_VGA_M80x60(fd:longint):boolean;
+{IO('S',M_VGA_M80x60));
+ }
+
+Begin
+ SW_VGA_M80x60:=FpIoctl(fd,nr_SW_VGA_M80x60,nil)=0;
+end;
+
+Function SW_VGA11(fd:longint):boolean;
+{IO('S',M_VGA11));
+ }
+
+Begin
+ SW_VGA11:=FpIoctl(fd,nr_SW_VGA11,nil)=0;
+end;
+
+Function SW_BG640x480(fd:longint):boolean;
+{IO('S',M_VGA11));
+ }
+
+Begin
+ SW_BG640x480:=FpIoctl(fd,nr_SW_BG640x480,nil)=0;
+end;
+
+Function SW_VGA12(fd:longint):boolean;
+{IO('S',M_VGA12));
+ }
+
+Begin
+ SW_VGA12:=FpIoctl(fd,nr_SW_VGA12,nil)=0;
+end;
+
+Function SW_CG640x480(fd:longint):boolean;
+{IO('S',M_VGA12));
+ }
+
+Begin
+ SW_CG640x480:=FpIoctl(fd,nr_SW_CG640x480,nil)=0;
+end;
+
+Function SW_VGA13(fd:longint):boolean;
+{IO('S',M_VGA13));
+ }
+
+Begin
+ SW_VGA13:=FpIoctl(fd,nr_SW_VGA13,nil)=0;
+end;
+
+Function SW_VGA_CG320(fd:longint):boolean;
+{IO('S',M_VGA13));
+ }
+
+Begin
+ SW_VGA_CG320:=FpIoctl(fd,nr_SW_VGA_CG320,nil)=0;
+end;
+
+Function SW_VGA_CG640(fd:longint):boolean;
+{IO('S',M_VGA_CG640));
+ }
+
+Begin
+ SW_VGA_CG640:=FpIoctl(fd,nr_SW_VGA_CG640,nil)=0;
+end;
+
+Function SW_VGA_MODEX(fd:longint):boolean;
+{IO('S',M_VGA_MODEX));
+ }
+
+Begin
+ SW_VGA_MODEX:=FpIoctl(fd,nr_SW_VGA_MODEX,nil)=0;
+end;
+
+Function SW_PC98_80x25(fd:longint):boolean;
+{IO('S',M_PC98_80x25));
+ }
+
+Begin
+ SW_PC98_80x25:=FpIoctl(fd,nr_SW_PC98_80x25,nil)=0;
+end;
+
+Function SW_PC98_80x30(fd:longint):boolean;
+{IO('S',M_PC98_80x30));
+ }
+
+Begin
+ SW_PC98_80x30:=FpIoctl(fd,nr_SW_PC98_80x30,nil)=0;
+end;
+
+Function SW_PC98_EGC640x400(fd:longint):boolean;
+{IO('S',M_PC98_EGC640x400));
+ }
+
+Begin
+ SW_PC98_EGC640x400:=FpIoctl(fd,nr_SW_PC98_EGC640x400,nil)=0;
+end;
+
+Function SW_PC98_PEGC640x400(fd:longint):boolean;
+{IO('S',M_PC98_PEGC640x400));
+ }
+
+Begin
+ SW_PC98_PEGC640x400:=FpIoctl(fd,nr_SW_PC98_PEGC640x400,nil)=0;
+end;
+
+Function SW_PC98_PEGC640x480(fd:longint):boolean;
+{IO('S',M_PC98_PEGC640x480));
+ }
+
+Begin
+ SW_PC98_PEGC640x480:=FpIoctl(fd,nr_SW_PC98_PEGC640x480,nil)=0;
+end;
+
+Function SW_VGA_C90x25(fd:longint):boolean;
+{IO('S',M_VGA_C90x25));
+ }
+
+Begin
+ SW_VGA_C90x25:=FpIoctl(fd,nr_SW_VGA_C90x25,nil)=0;
+end;
+
+Function SW_VGA_M90x25(fd:longint):boolean;
+{IO('S',M_VGA_M90x25));
+ }
+
+Begin
+ SW_VGA_M90x25:=FpIoctl(fd,nr_SW_VGA_M90x25,nil)=0;
+end;
+
+Function SW_VGA_C90x30(fd:longint):boolean;
+{IO('S',M_VGA_C90x30));
+ }
+
+Begin
+ SW_VGA_C90x30:=FpIoctl(fd,nr_SW_VGA_C90x30,nil)=0;
+end;
+
+Function SW_VGA_M90x30(fd:longint):boolean;
+{IO('S',M_VGA_M90x30));
+ }
+
+Begin
+ SW_VGA_M90x30:=FpIoctl(fd,nr_SW_VGA_M90x30,nil)=0;
+end;
+
+Function SW_VGA_C90x43(fd:longint):boolean;
+{IO('S',M_VGA_C90x43));
+ }
+
+Begin
+ SW_VGA_C90x43:=FpIoctl(fd,nr_SW_VGA_C90x43,nil)=0;
+end;
+
+Function SW_VGA_M90x43(fd:longint):boolean;
+{IO('S',M_VGA_M90x43));
+ }
+
+Begin
+ SW_VGA_M90x43:=FpIoctl(fd,nr_SW_VGA_M90x43,nil)=0;
+end;
+
+Function SW_VGA_C90x50(fd:longint):boolean;
+{IO('S',M_VGA_C90x50));
+ }
+
+Begin
+ SW_VGA_C90x50:=FpIoctl(fd,nr_SW_VGA_C90x50,nil)=0;
+end;
+
+Function SW_VGA_M90x50(fd:longint):boolean;
+{IO('S',M_VGA_M90x50));
+ }
+
+Begin
+ SW_VGA_M90x50:=FpIoctl(fd,nr_SW_VGA_M90x50,nil)=0;
+end;
+
+Function SW_VGA_C90x60(fd:longint):boolean;
+{IO('S',M_VGA_C90x60));
+ }
+
+Begin
+ SW_VGA_C90x60:=FpIoctl(fd,nr_SW_VGA_C90x60,nil)=0;
+end;
+
+Function SW_VGA_M90x60(fd:longint):boolean;
+{IO('S',M_VGA_M90x60));
+ }
+
+Begin
+ SW_VGA_M90x60:=FpIoctl(fd,nr_SW_VGA_M90x60,nil)=0;
+end;
+
+Function SW_TEXT_80x25(fd:longint):boolean;
+{IO('S',M_TEXT_80x25));
+ }
+
+Begin
+ SW_TEXT_80x25:=FpIoctl(fd,nr_SW_TEXT_80x25,nil)=0;
+end;
+
+Function SW_TEXT_80x30(fd:longint):boolean;
+{IO('S',M_TEXT_80x30));
+ }
+
+Begin
+ SW_TEXT_80x30:=FpIoctl(fd,nr_SW_TEXT_80x30,nil)=0;
+end;
+
+Function SW_TEXT_80x43(fd:longint):boolean;
+{IO('S',M_TEXT_80x43));
+ }
+
+Begin
+ SW_TEXT_80x43:=FpIoctl(fd,nr_SW_TEXT_80x43,nil)=0;
+end;
+
+Function SW_TEXT_80x50(fd:longint):boolean;
+{IO('S',M_TEXT_80x50));
+ }
+
+Begin
+ SW_TEXT_80x50:=FpIoctl(fd,nr_SW_TEXT_80x50,nil)=0;
+end;
+
+Function SW_TEXT_80x60(fd:longint):boolean;
+{IO('S',M_TEXT_80x60));
+ }
+
+Begin
+ SW_TEXT_80x60:=FpIoctl(fd,nr_SW_TEXT_80x60,nil)=0;
+end;
+
+Function SW_TEXT_132x25(fd:longint):boolean;
+{IO('S',M_TEXT_132x25));
+ }
+
+Begin
+ SW_TEXT_132x25:=FpIoctl(fd,nr_SW_TEXT_132x25,nil)=0;
+end;
+
+Function SW_TEXT_132x30(fd:longint):boolean;
+{IO('S',M_TEXT_132x30));
+ }
+
+Begin
+ SW_TEXT_132x30:=FpIoctl(fd,nr_SW_TEXT_132x30,nil)=0;
+end;
+
+Function SW_TEXT_132x43(fd:longint):boolean;
+{IO('S',M_TEXT_132x43));
+ }
+
+Begin
+ SW_TEXT_132x43:=FpIoctl(fd,nr_SW_TEXT_132x43,nil)=0;
+end;
+
+Function SW_TEXT_132x50(fd:longint):boolean;
+{IO('S',M_TEXT_132x50));
+ }
+
+Begin
+ SW_TEXT_132x50:=FpIoctl(fd,nr_SW_TEXT_132x50,nil)=0;
+end;
+
+Function SW_TEXT_132x60(fd:longint):boolean;
+{IO('S',M_TEXT_132x60));
+ }
+
+Begin
+ SW_TEXT_132x60:=FpIoctl(fd,nr_SW_TEXT_132x60,nil)=0;
+end;
+
+Function SW_VESA_CG640x400(fd:longint):boolean;
+{IO('V',M_VESA_CG640x400 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_CG640x400:=FpIoctl(fd,nr_SW_VESA_CG640x400,nil)=0;
+end;
+
+Function SW_VESA_CG640x480(fd:longint):boolean;
+{IO('V',M_VESA_CG640x480 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_CG640x480:=FpIoctl(fd,nr_SW_VESA_CG640x480,nil)=0;
+end;
+
+Function SW_VESA_800x600(fd:longint):boolean;
+{IO('V',M_VESA_800x600 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_800x600:=FpIoctl(fd,nr_SW_VESA_800x600,nil)=0;
+end;
+
+Function SW_VESA_CG800x600(fd:longint):boolean;
+{IO('V',M_VESA_CG800x600 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_CG800x600:=FpIoctl(fd,nr_SW_VESA_CG800x600,nil)=0;
+end;
+
+Function SW_VESA_1024x768(fd:longint):boolean;
+{IO('V',M_VESA_1024x768 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_1024x768:=FpIoctl(fd,nr_SW_VESA_1024x768,nil)=0;
+end;
+
+Function SW_VESA_CG1024x768(fd:longint):boolean;
+{IO('V',M_VESA_CG1024x768 - M_VESA_BAS));
+ }
+
+Begin
+ SW_VESA_CG1024x768:=FpIoctl(fd,nr_SW_VESA_CG1024x768,nil)=0;
+end;
+
+Function SW_VESA_1280x1024(fd:longint):boolean;
+{IO('V',M_VESA_1280x1024 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_1280x1024:=FpIoctl(fd,nr_SW_VESA_1280x1024,nil)=0;
+end;
+
+Function SW_VESA_CG1280x1024(fd:longint):boolean;
+{IO('V',M_VESA_CG1280x1024 - M_VESA_BA));
+ }
+
+Begin
+ SW_VESA_CG1280x1024:=FpIoctl(fd,nr_SW_VESA_CG1280x1024,nil)=0;
+end;
+
+Function SW_VESA_C80x60(fd:longint):boolean;
+{IO('V',M_VESA_C80x60 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_C80x60:=FpIoctl(fd,nr_SW_VESA_C80x60,nil)=0;
+end;
+
+Function SW_VESA_C132x25(fd:longint):boolean;
+{IO('V',M_VESA_C132x25 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_C132x25:=FpIoctl(fd,nr_SW_VESA_C132x25,nil)=0;
+end;
+
+Function SW_VESA_C132x43(fd:longint):boolean;
+{IO('V',M_VESA_C132x43 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_C132x43:=FpIoctl(fd,nr_SW_VESA_C132x43,nil)=0;
+end;
+
+Function SW_VESA_C132x50(fd:longint):boolean;
+{IO('V',M_VESA_C132x50 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_C132x50:=FpIoctl(fd,nr_SW_VESA_C132x50,nil)=0;
+end;
+
+Function SW_VESA_C132x60(fd:longint):boolean;
+{IO('V',M_VESA_C132x60 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_C132x60:=FpIoctl(fd,nr_SW_VESA_C132x60,nil)=0;
+end;
+
+Function SW_VESA_32K_320(fd:longint):boolean;
+{IO('V',M_VESA_32K_320 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_32K_320:=FpIoctl(fd,nr_SW_VESA_32K_320,nil)=0;
+end;
+
+Function SW_VESA_64K_320(fd:longint):boolean;
+{IO('V',M_VESA_64K_320 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_64K_320:=FpIoctl(fd,nr_SW_VESA_64K_320,nil)=0;
+end;
+
+Function SW_VESA_FULL_320(fd:longint):boolean;
+{IO('V',M_VESA_FULL_320 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_FULL_320:=FpIoctl(fd,nr_SW_VESA_FULL_320,nil)=0;
+end;
+
+Function SW_VESA_32K_640(fd:longint):boolean;
+{IO('V',M_VESA_32K_640 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_32K_640:=FpIoctl(fd,nr_SW_VESA_32K_640,nil)=0;
+end;
+
+Function SW_VESA_64K_640(fd:longint):boolean;
+{IO('V',M_VESA_64K_640 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_64K_640:=FpIoctl(fd,nr_SW_VESA_64K_640,nil)=0;
+end;
+
+Function SW_VESA_FULL_640(fd:longint):boolean;
+{IO('V',M_VESA_FULL_640 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_FULL_640:=FpIoctl(fd,nr_SW_VESA_FULL_640,nil)=0;
+end;
+
+Function SW_VESA_32K_800(fd:longint):boolean;
+{IO('V',M_VESA_32K_800 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_32K_800:=FpIoctl(fd,nr_SW_VESA_32K_800,nil)=0;
+end;
+
+Function SW_VESA_64K_800(fd:longint):boolean;
+{IO('V',M_VESA_64K_800 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_64K_800:=FpIoctl(fd,nr_SW_VESA_64K_800,nil)=0;
+end;
+
+Function SW_VESA_FULL_800(fd:longint):boolean;
+{IO('V',M_VESA_FULL_800 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_FULL_800:=FpIoctl(fd,nr_SW_VESA_FULL_800,nil)=0;
+end;
+
+Function SW_VESA_32K_1024(fd:longint):boolean;
+{IO('V',M_VESA_32K_1024 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_32K_1024:=FpIoctl(fd,nr_SW_VESA_32K_1024,nil)=0;
+end;
+
+Function SW_VESA_64K_1024(fd:longint):boolean;
+{IO('V',M_VESA_64K_1024 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_64K_1024:=FpIoctl(fd,nr_SW_VESA_64K_1024,nil)=0;
+end;
+
+Function SW_VESA_FULL_1024(fd:longint):boolean;
+{IO('V',M_VESA_FULL_1024 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_FULL_1024:=FpIoctl(fd,nr_SW_VESA_FULL_1024,nil)=0;
+end;
+
+Function SW_VESA_32K_1280(fd:longint):boolean;
+{IO('V',M_VESA_32K_1280 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_32K_1280:=FpIoctl(fd,nr_SW_VESA_32K_1280,nil)=0;
+end;
+
+Function SW_VESA_64K_1280(fd:longint):boolean;
+{IO('V',M_VESA_64K_1280 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_64K_1280:=FpIoctl(fd,nr_SW_VESA_64K_1280,nil)=0;
+end;
+
+Function SW_VESA_FULL_1280(fd:longint):boolean;
+{IO('V',M_VESA_FULL_1280 - M_VESA_BASE));
+ }
+
+Begin
+ SW_VESA_FULL_1280:=FpIoctl(fd,nr_SW_VESA_FULL_1280,nil)=0;
+end;
+
+{----------------------------- kbio.h FpIoctl's ---------------------------}
+
+Function KDGKBMODE(fd:longint;var param1 : longint):boolean;
+{IOR('K',6,sizeof(int) }
+
+Begin
+ KDGKBMODE:=FpIoctl(fd,nr_KDGKBMODE,@param1)=0;
+end;
+
+Function KDSKBMODE(fd:longint;param1 : longint):boolean;
+{IO('K',7 /* int */));
+ }
+
+Begin
+ KDSKBMODE:=FpIoctl(fd,nr_KDSKBMODE,pointer(param1))=0;
+end;
+
+Function KDMKTONE(fd:longint;param1 : longint):boolean;
+{IO('K',8 /* int */));
+ }
+
+Begin
+ KDMKTONE:=FpIoctl(fd,nr_KDMKTONE,pointer(param1))=0;
+end;
+
+{$ifndef definconsole}
+Function KDGETMODE(fd:longint;var param1 : longint):boolean;
+{IOR('K',9,sizeof(int) }
+
+Begin
+ KDGETMODE:=FpIoctl(fd,nr_KDGETMODE,@param1)=0;
+end;
+
+Function KDSETMODE(fd:longint;param1 : longint):boolean;
+{IO('K',10 /* int */));
+ }
+
+Begin
+ KDSETMODE:=FpIoctl(fd,nr_KDSETMODE,pointer(param1))=0;
+end;
+
+Function KDSBORDER(fd:longint;param1 : longint):boolean;
+{IO('K',13 /* int */));
+ }
+
+Begin
+ KDSBORDER:=FpIoctl(fd,nr_KDSBORDER,pointer(param1))=0;
+end;
+{$endif}
+Function KDGKBSTATE(fd:longint;var param1 : longint):boolean;
+{IOR('K',19,sizeof(int) }
+
+Begin
+ KDGKBSTATE:=FpIoctl(fd,nr_KDGKBSTATE,@param1)=0;
+end;
+
+Function KDSKBSTATE(fd:longint;param1 : longint):boolean;
+{IO('K',20 /* int */));
+ }
+
+Begin
+ KDSKBSTATE:=FpIoctl(fd,nr_KDSKBSTATE,pointer(param1))=0;
+end;
+
+Function KDENABIO(fd:longint):boolean;
+{IO('K',60));
+ }
+
+Begin
+ KDENABIO:=FpIoctl(fd,nr_KDENABIO,nil)=0;
+end;
+
+Function KDDISABIO(fd:longint):boolean;
+{IO('K',61));
+ }
+
+Begin
+ KDDISABIO:=FpIoctl(fd,nr_KDDISABIO,nil)=0;
+end;
+
+Function KIOCSOUND(fd:longint;param1 : longint):boolean;
+{IO('K',63 /* int */));
+ }
+
+Begin
+ KIOCSOUND:=FpIoctl(fd,nr_KIOCSOUND,pointer(param1))=0;
+end;
+
+Function KDGKBTYPE(fd:longint;var param1 : longint):boolean;
+{IOR('K',64,sizeof(int) }
+
+Begin
+ KDGKBTYPE:=FpIoctl(fd,nr_KDGKBTYPE,@param1)=0;
+end;
+
+Function KDGETLED(fd:longint;var param1 : longint):boolean;
+{IOR('K',65,sizeof(int) }
+
+Begin
+ KDGETLED:=FpIoctl(fd,nr_KDGETLED,@param1)=0;
+end;
+
+Function KDSETLED(fd:longint;param1 : longint):boolean;
+{IO('K',66 /* int */));
+ }
+
+Begin
+ KDSETLED:=FpIoctl(fd,nr_KDSETLED,pointer(param1))=0;
+end;
+
+Function KDSETRAD(fd:longint;param1 : longint):boolean;
+{IO('K',67 /* int */));
+ }
+
+Begin
+ KDSETRAD:=FpIoctl(fd,nr_KDSETRAD,pointer(param1))=0;
+end;
+{$ifndef definconsole}
+
+Function KDRASTER(fd:longint;var param1 : scr_size_t):boolean;
+{IOW('K',100,sizeof(scr_size_t) }
+
+Begin
+ KDRASTER:=FpIoctl(fd,nr_KDRASTER,@param1)=0;
+end;
+{$endif}
+Function KDGKBINFO(fd:longint;var param1 : keyboard_info_t):boolean;
+{IOR('K',101,sizeof(keyboard_info_t) }
+
+Begin
+ KDGKBINFO:=FpIoctl(fd,nr_KDGKBINFO,@param1)=0;
+end;
+
+Function KDSETREPEAT(fd:longint;var param1 : keyboard_repeat_t):boolean;
+{IOW('K',102,sizeof(keyboard_repeat_t) }
+
+Begin
+ KDSETREPEAT:=FpIoctl(fd,nr_KDSETREPEAT,@param1)=0;
+end;
+
+Function KDGETREPEAT(fd:longint;var param1 : keyboard_repeat_t):boolean;
+{IOR('K',103,sizeof(keyboard_repeat_t) }
+
+Begin
+ KDGETREPEAT:=FpIoctl(fd,nr_KDGETREPEAT,@param1)=0;
+end;
+
+Function GETFKEY(fd:longint;var param1 : fkeyarg_t):boolean;
+{IOWR('k',0,sizeof(fkeyarg_t) }
+
+Begin
+ GETFKEY:=FpIoctl(fd,nr_GETFKEY,@param1)=0;
+end;
+
+Function SETFKEY(fd:longint;var param1 : fkeyarg_t):boolean;
+{IOWR('k',1,sizeof(fkeyarg_t) }
+
+Begin
+ SETFKEY:=FpIoctl(fd,nr_SETFKEY,@param1)=0;
+end;
+{$ifndef definconsole}
+Function GIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+{IOR('k',2,sizeof(scrmap_t) }
+
+Begin
+ GIO_SCRNMAP:=FpIoctl(fd,nr_GIO_SCRNMAP,@param1)=0;
+end;
+
+Function PIO_SCRNMAP(fd:longint;var param1 : scrmap_t):boolean;
+{IOW('k',3,sizeof(scrmap_t) }
+
+Begin
+ PIO_SCRNMAP:=FpIoctl(fd,nr_PIO_SCRNMAP,@param1)=0;
+end;
+{$endif}
+Function GIO_KEYMAP(fd:longint;var param1 : keymap_t):boolean;
+{IOR('k',6,sizeof(keymap_t) }
+
+Begin
+ GIO_KEYMAP:=FpIoctl(fd,nr_GIO_KEYMAP,@param1)=0;
+end;
+
+Function PIO_KEYMAP(fd:longint;var param1 : keymap_t):boolean;
+{IOW('k',7,sizeof(keymap_t) }
+
+Begin
+ PIO_KEYMAP:=FpIoctl(fd,nr_PIO_KEYMAP,@param1)=0;
+end;
+
+Function GIO_DEADKEYMAP(fd:longint;var param1 : accentmap_t):boolean;
+{IOR('k',8,sizeof(accentmap_t) }
+
+Begin
+ GIO_DEADKEYMAP:=FpIoctl(fd,nr_GIO_DEADKEYMAP,@param1)=0;
+end;
+
+Function PIO_DEADKEYMAP(fd:longint;var param1 : accentmap_t):boolean;
+{IOW('k',9,sizeof(accentmap_t) }
+
+Begin
+ PIO_DEADKEYMAP:=FpIoctl(fd,nr_PIO_DEADKEYMAP,@param1)=0;
+end;
+
+Function GIO_KEYMAPENT(fd:longint;var param1 : keyarg_t):boolean;
+{IOWR('k',10,sizeof(keyarg_t) }
+
+Begin
+ GIO_KEYMAPENT:=FpIoctl(fd,nr_GIO_KEYMAPENT,@param1)=0;
+end;
+
+Function PIO_KEYMAPENT(fd:longint;var param1 : keyarg_t):boolean;
+{IOW('k',11,sizeof(keyarg_t) }
+
+Begin
+ PIO_KEYMAPENT:=FpIoctl(fd,nr_PIO_KEYMAPENT,@param1)=0;
+end;
+
+
+
+{----------------------------- mouse.h FpIoctl's ---------------------------}
+
+Function MOUSE_GETSTATUS(fd:longint;var param1 : mousestatus_t):boolean;
+{IOR('M',0,sizeof(mousestatus_t)));
+}
+
+Begin
+ MOUSE_GETSTATUS:=FpIoctl(fd,nr_MOUSE_GETSTATUS,@param1)=0;
+end;
+
+Function MOUSE_GETHWINFO(fd:longint;var param1 : mousehw_t):boolean;
+{IOR('M',1,sizeof(mousehw_t)));
+}
+
+Begin
+ MOUSE_GETHWINFO:=FpIoctl(fd,nr_MOUSE_GETHWINFO,@param1)=0;
+end;
+
+Function MOUSE_GETMODE(fd:longint;var param1 : mousemode_t):boolean;
+{IOR('M',2,sizeof(mousemode_t)));
+}
+
+Begin
+ MOUSE_GETMODE:=FpIoctl(fd,nr_MOUSE_GETMODE,@param1)=0;
+end;
+
+Function MOUSE_SETMODE(fd:longint;var param1 : mousemode_t):boolean;
+{IOW('M',3,sizeof(mousemode_t)));
+}
+
+Begin
+ MOUSE_SETMODE:=FpIoctl(fd,nr_MOUSE_SETMODE,@param1)=0;
+end;
+
+Function MOUSE_GETLEVEL(fd:longint;var param1 : longint):boolean;
+{IOR('M',4,sizeof(int)));
+}
+
+Begin
+ MOUSE_GETLEVEL:=FpIoctl(fd,nr_MOUSE_GETLEVEL,@param1)=0;
+end;
+
+Function MOUSE_SETLEVEL(fd:longint;var param1 : longint):boolean;
+{IOW('M',5,sizeof(int)));
+}
+
+Begin
+ MOUSE_SETLEVEL:=FpIoctl(fd,nr_MOUSE_SETLEVEL,@param1)=0;
+end;
+
+Function MOUSE_GETVARS(fd:longint;var param1 : mousevar_t):boolean;
+{IOR('M',6,sizeof(mousevar_t)));
+}
+
+Begin
+ MOUSE_GETVARS:=FpIoctl(fd,nr_MOUSE_GETVARS,@param1)=0;
+end;
+
+Function MOUSE_SETVARS(fd:longint;var param1 : mousevar_t):boolean;
+{IOW('M',7,sizeof(mousevar_t)));
+}
+
+Begin
+ MOUSE_SETVARS:=FpIoctl(fd,nr_MOUSE_SETVARS,@param1)=0;
+end;
+
+Function MOUSE_READSTATE(fd:longint;var param1 : mousedata_t):boolean;
+{IOWR('M',8,sizeof(mousedata_t)));
+}
+
+Begin
+ MOUSE_READSTATE:=FpIoctl(fd,nr_MOUSE_READSTATE,@param1)=0;
+end;
+
+Function MOUSE_READDATA(fd:longint;var param1 : mousedata_t):boolean;
+{IOWR('M',9,sizeof(mousedata_t)));
+}
+
+Begin
+ MOUSE_READDATA:=FpIoctl(fd,nr_MOUSE_READDATA,@param1)=0;
+end;
+
+Function MOUSE_SETRESOLUTION(fd:longint;var param1 : longint):boolean;
+{IOW('M',10,sizeof(int)));
+}
+
+Begin
+ MOUSE_SETRESOLUTION:=FpIoctl(fd,nr_MOUSE_SETRESOLUTION,@param1)=0;
+end;
+
+Function MOUSE_SETSCALING(fd:longint;var param1 : longint):boolean;
+{IOW('M',11,sizeof(int)));
+}
+
+Begin
+ MOUSE_SETSCALING:=FpIoctl(fd,nr_MOUSE_SETSCALING,@param1)=0;
+end;
+
+Function MOUSE_SETRATE(fd:longint;var param1 : longint):boolean;
+{IOW('M',12,sizeof(int)));
+}
+
+Begin
+ MOUSE_SETRATE:=FpIoctl(fd,nr_MOUSE_SETRATE,@param1)=0;
+end;
+
+Function MOUSE_GETHWID(fd:longint;var param1 : longint):boolean;
+{IOR('M',13,sizeof(int)));
+}
+
+Begin
+ MOUSE_GETHWID:=FpIoctl(fd,nr_MOUSE_GETHWID,@param1)=0;
+end;
+
+end.
diff -ur --unidirectional-new-file rtl/dragonfly.null/errno.inc rtl/dragonfly/errno.inc
--- rtl/dragonfly.null/errno.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/errno.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,143 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Michael Van Canneyt,
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+{
+
+  Errno.inc : define all error numbers
+
+}
+Const
+
+
+        ESysEPERM               = 1;            { Operation not permitted }
+        ESysENOENT              = 2;            { No such file or directory }
+        ESysESRCH               = 3;            { No such process }
+        ESysEINTR               = 4;            { Interrupted system call }
+        ESysEIO                 = 5;            { Input/output error }
+        ESysENXIO               = 6;            { Device not configured }
+        ESysE2BIG               = 7;            { Argument list too long }
+        ESysENOEXEC             = 8;            { Exec format error }
+        ESysEBADF               = 9;            { Bad file descriptor }
+        ESysECHILD              = 10;           { No child processes }
+        ESysEDEADLK             = 11;           { Resource deadlock avoided }
+        ESysENOMEM              = 12;           { Cannot allocate memory }
+        ESysEACCES              = 13;           { Permission denied }
+        ESysEFAULT              = 14;           { Bad address }
+        ESysENOTBLK             = 15;           { Block device required }
+        ESysEBUSY               = 16;           { Device busy }
+        ESysEEXIST              = 17;           { File exists }
+        ESysEXDEV               = 18;           { Cross-device link }
+        ESysENODEV              = 19;           { Operation not supported by device }
+        ESysENOTDIR             = 20;           { Not a directory }
+        ESysEISDIR              = 21;           { Is a directory }
+        ESysEINVAL              = 22;           { Invalid argument }
+        ESysENFILE              = 23;           { Too many open files in system }
+        ESysEMFILE              = 24;           { Too many open files }
+        ESysENOTTY              = 25;           { Inappropriate ioctl for device }
+        ESysETXTBSY             = 26;           { Text file busy }
+        ESysEFBIG               = 27;           { File too large }
+        ESysENOSPC              = 28;           { No space left on device }
+        ESysESPIPE              = 29;           { Illegal seek }
+        ESysEROFS               = 30;           { Read-only file system }
+        ESysEMLINK              = 31;           { Too many links }
+        ESysEPIPE               = 32;           { Broken pipe }
+
+{ math software }
+        ESysEDOM                = 33;           { Numerical argument out of domain }
+        ESysERANGE              = 34;           { Result too large }
+
+{ non-blocking and interrupt i/o }
+        ESysEAGAIN              = 35;           { Resource temporarily unavailable }
+        ESysEWOULDBLOCK         = ESysEAGAIN;   { Operation would block }
+        ESysEINPROGRESS         = 36;           { Operation now in progress }
+        ESysEALREADY            = 37;           { Operation already in progress }
+
+{ ipc/network software -  - argument errors }
+        ESysENOTSOCK            = 38;           { Socket operation on non-socket }
+        ESysEDESTADDRREQ        = 39;           { Destination address required }
+        ESysEMSGSIZE            = 40;           { Message too long }
+        ESysEPROTOTYPE          = 41;           { Protocol wrong type for socket }
+        ESysENOPROTOOPT         = 42;           { Protocol not available }
+        ESysEPROTONOSUPPORT     = 43;           { Protocol not supported }
+        ESysESOCKTNOSUPPORT     = 44;           { Socket type not supported }
+        ESysEOPNOTSUPP          = 45;           { Operation not supported }
+        ESysENOTSUP             = ESysEOPNOTSUPP;       { Operation not supported }
+        ESysEPFNOSUPPORT        = 46;           { Protocol family not supported }
+        ESysEAFNOSUPPORT        = 47;           { Address family not supported by protocol family }
+        ESysEADDRINUSE          = 48;           { Address already in use }
+        ESysEADDRNOTAVAIL       = 49;           { Can't assign requested address }
+
+{ ipc/network software -  - operational errors }
+        ESysENETDOWN            = 50;           { Network is down }
+        ESysENETUNREACH         = 51;           { Network is unreachable }
+        ESysENETRESET           = 52;           { Network dropped connection on reset }
+        ESysECONNABORTED        = 53;           { Software caused connection abort }
+        ESysECONNRESET          = 54;           { Connection reset by peer }
+        ESysENOBUFS             = 55;           { No buffer space available }
+        ESysEISCONN             = 56;           { Socket is already connected }
+        ESysENOTCONN            = 57;           { Socket is not connected }
+        ESysESHUTDOWN           = 58;           { Can't send after socket shutdown }
+        ESysETOOMANYREFS        = 59;           { Too many references: can't splice }
+        ESysETIMEDOUT           = 60;           { Operation timed out }
+        ESysECONNREFUSED        = 61;           { Connection refused }
+
+        ESysELOOP               = 62;           { Too many levels of symbolic links }
+        ESysENAMETOOLONG        = 63;           { File name too long }
+
+{ should be rearranged }
+        ESysEHOSTDOWN           = 64;           { Host is down }
+        ESysEHOSTUNREACH        = 65;           { No route to host }
+        ESysENOTEMPTY           = 66;           { Directory not empty }
+
+{ quotas & mush }
+        ESysEPROCLIM            = 67;           { Too many processes }
+        ESysEUSERS              = 68;           { Too many users }
+        ESysEDQUOT              = 69;           { Disc quota exceeded }
+
+{ Network File System }
+        ESysESTALE              = 70;           { Stale NFS file handle }
+        ESysEREMOTE             = 71;           { Too many levels of remote in path }
+        ESysEBADRPC             = 72;           { RPC struct is bad }
+        ESysERPCMISMATCH        = 73;           { RPC version wrong }
+        ESysEPROGUNAVAIL        = 74;           { RPC prog. not avail }
+        ESysEPROGMISMATCH       = 75;           { Program version wrong }
+        ESysEPROCUNAVAIL        = 76;           { Bad procedure for program }
+
+        ESysENOLCK              = 77;           { No locks available }
+        ESysENOSYS              = 78;           { Function not implemented }
+
+        ESysEFTYPE              = 79;           { Inappropriate file type or format }
+        ESysEAUTH               = 80;           { Authentication error }
+        ESysENEEDAUTH           = 81;           { Need authenticator }
+        ESysEIDRM               = 82;           { Identifier removed }
+        ESysENOMSG              = 83;           { No message of desired type }
+        ESysEOVERFLOW           = 84;           { Value too large to be stored in data type }
+        ESysECANCELED           = 85;           { Operation canceled }
+        ESysEILSEQ              = 86;           { Illegal byte sequence }
+        ESysNOATTR              = 87;           { Attribute not found }
+        ESysEDOOFUS             = 88;           { Programming Error }
+
+        ESysBADMSG              = 89;           { Bad message }
+	ESysMULTIHOP            = 90;           { Multihop attempted }
+        ESysNOLINK              = 91;           { Link has been severed }
+        ESysPROTO               = 92;           { Protocol error }
+
+        ESysNOMEDIUM            = 93;           { linux }
+        ESysUNUSED94            = 94;
+        ESysUNUSED95            = 95;
+        ESysUNUSED96            = 96;
+        ESysUNUSED97            = 97;
+        ESysUNUSED98            = 98;
+
+        ESysASYNC               = 99;           { XXX }
+        ESysELAST               = 99;           { Must be equal largest errno }
diff -ur --unidirectional-new-file rtl/dragonfly.null/errnostr.inc rtl/dragonfly/errnostr.inc
--- rtl/dragonfly.null/errnostr.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/errnostr.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,119 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 2005 by Ales Katona
+
+    Contains BSD specific errors for error.pp in rtl/unix
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+const
+  sys_errn=100;
+  sys_errlist:array[0..sys_errn-1] of pchar = (
+        'Success',                              { 0 }
+        'Operation not permitted',              { EPERM }
+        'No such file or directory',            { ENOENT }
+        'No such process',                      { ESRCH }
+        'Interrupted system call',              { EINTR }
+        'I/O error',                            { EIO }
+        'No such device or address',            { ENXIO }
+        'Arg list too long',                    { E2BIG }
+        'Exec format error',                    { ENOEXEC }
+        'Bad file number',                      { EBADF }
+        'No child processes',                   { ECHILD }
+        'Resource deadlock avoided',            { EDEADLK }
+        'Out of memory',                        { ENOMEM }
+        'Permission denied',                    { EACCES }
+        'Bad address',                          { EFAULT }
+        'Block device required',                { ENOTBLK }
+        'Device or resource busy',              { EBUSY }
+        'File exists',                          { EEXIST }
+        'Cross-device link',                    { EXDEV }
+        'No such device',                       { ENODEV }
+        'Not a directory',                      { ENOTDIR }
+        'Is a directory',                       { EISDIR }
+        'Invalid argument',                     { EINVAL }
+        'File table overflow',                  { ENFILE }
+        'Too many open files',                  { EMFILE }
+        'Not a typewriter',                     { ENOTTY }
+        'Text (code segment) file busy',        { ETXTBSY }
+        'File too large',                       { EFBIG }
+        'No space left on device',              { ENOSPC }
+        'Illegal seek',                         { ESPIPE }
+        'Read-only file system',                { EROFS }
+        'Too many links',                       { EMLINK }
+        'Broken pipe',                          { EPIPE }
+        'Math argument out of domain of func',  { EDOM }
+        'Math result not representable',        { ERANGE }
+        'Resource temporarily unavailable',     { EAGAIN }
+        'Operation now in progress',            { EINPROGRESS }
+        'Operation already in progress',        { EALREADY }
+        'Socket operation on non-socket',       { ENOTSOCK }
+        'Destination address required',         { EDESTADDRREQ }
+        'Message too long',                     { EMSGSIZE }
+        'Protocol wrong type for socket',       { EPROTOTYPE }
+        'Protocol not available',               { ENOPROTOOPT }
+        'Protocol not supported',               { EPROTONOSUPPORT }
+        'Socket type not supported',            { ESOCKTNOSUPPORT }
+        'Operation not supported',              { EOPNOTSUPP }
+        'Protocol family not supported',        { EPFNOSUPPORT }
+        'Address family not supported by protocol family',  { EAFNOSUPPORT }
+        'Address already in use',               { EADDRINUSE }
+        'Can''t assign requested address',      { EADDRNOTAVAIL }
+        'Network is down',                      { ENETDOWN }
+        'Network is unreachable',               { ENETUNREACH }
+        'Network dropped connection on reset',  { ENETRESET }
+        'Software caused connection abort',     { ECONNABORTED }
+        'Connection reset by peer',             { ECONNRESET }
+        'No buffer space available',            { ENOBUFS }
+        'Socket is already connected',          { EISCONN }
+        'Socket is not connected',              { ENOTCONN }
+        'Can''t send after socket shutdown',    { ESHUTDOWN }
+        'Too many references: can''t splice',   { ETOOMANYREFS }
+        'Operation timed out',                  { ETIMEDOUT }
+        'Connection refused',                   { ECONNREFUSED }
+        'Too many levels of symbolic links',    { ELOOP }
+        'File name too long',                   { ENAMETOOLONG }
+        'Host is down',                         { EHOSTDOWN }
+        'No route to host',                     { EHOSTUNREACH }
+        'Directory not empty',                  { ENOTEMPTY }
+        'Too many processes',                   { EPROCLIM }
+        'Too many users',                       { EUSERS }
+        'Disc quota exceeded',                  { EDQUOT }
+        'Stale NFS file handle',                { ESTALE }
+        'Too many levels of remote in path',    { EREMOTE }
+        'RPC struct is bad',                    { EBADRPC }
+        'RPC version wrong',                    { ERPCMISMATCH }
+        'RPC prog. not avail',                  { EPROGUNAVAIL }
+        'Program version wrong',                { EPROGMISMATCH }
+        'Bad procedure for program',            { EPROCUNAVAIL }
+        'No locks available',                   { ENOLCK }
+        'Function not implemented',             { ENOSYS }
+        'Inappropriate file type or format',    { EFTYPE }
+        'Authentication error',                 { EAUTH }
+        'Need authenticator',                   { ENEEDAUTH }
+        'Identifier removed',                   { EIDRM }
+        'No message of desired type',           { ENOMSG }
+        'Value too large to be stored in data type', { EOVERFLOW }
+        'Operation canceled',                   { ECANCELED }
+        'Illegal byte sequence',                { EILSEQ }
+        'Attribute not found',                  { ENOATTR }
+        'Programming error',                    { EDOOFUS }
+        'Bad message',                          { EBADMSG }
+        'Multihop attempted',                   { EMULTIHOP }
+        'Link has been severed',                { ENOLINK }
+        'Protocol error',                       { EPROTO }
+	'No medium found',                      { ENOMEDIUM }
+        'Unused 94',                            { EUNUSED94 }
+        'Unused 95',                            { EUNUSED95 }
+        'Unused 96',                            { EUNUSED96 }
+        'Unused 97',                            { EUNUSED97 }
+        'Unused 98',                            { EUNUSED98 }
+        'XXX'                                   { EASYNC }
+);
diff -ur --unidirectional-new-file rtl/dragonfly.null/pmutext.inc rtl/dragonfly/pmutext.inc
--- rtl/dragonfly.null/pmutext.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/pmutext.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,18 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Peter Vreman
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+{ definition of pthread_mutex_t, because needed in both ptypes.inc and }
+{ in sysosh.inc                                                        }
+
+pointer;
diff -ur --unidirectional-new-file rtl/dragonfly.null/pthread.inc rtl/dragonfly/pthread.inc
--- rtl/dragonfly.null/pthread.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/pthread.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,120 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Peter Vreman
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This file contains a pthread.h headerconversion,
+    and should contain an interface to the threading library to be
+    used by systhrd, preferably in a somewhat compatible notation
+    (compared to the other OSes).
+
+    As a start, I simply used libc_r
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+CONST PTHREAD_EXPLICIT_SCHED       = 0;
+      PTHREAD_CREATE_DETACHED      = 1;
+      PTHREAD_SCOPE_PROCESS        = 0;
+      SEM_SAFE = 255;
+
+ TYPE
+    ppthread_t      = ^pthread_t;
+    ppthread_key_t  = ^pthread_key_t;
+    ppthread_mutex_t= ^pthread_mutex_t;
+    ppthread_attr_t = ^pthread_attr_t;
+    ppthread_cond_t            = ^pthread_cond_t;
+    ppthread_condattr_t        = ^pthread_condattr_t;
+
+    __destr_func_t  = procedure (p :pointer);cdecl;
+    __startroutine_t= function (p :pointer):pointer;cdecl;
+    ppthread_mutexattr_t = ^pthread_mutexattr_t;
+    ppthread_mutex_attr_t = ^pthread_mutexattr_t;
+
+{
+  From FreeBSD 8.2 sys/_semaphore.h
+}
+
+(*
+struct sem {
+#define SEM_MAGIC       ((u_int32_t) 0x09fa4012)
+        u_int32_t       magic;
+        pthread_mutex_t lock;
+        pthread_cond_t  gtzero;
+        u_int32_t       count;
+        u_int32_t       nwaiters;
+#define SEM_USER        (NULL)
+        semid_t         semid;  /* semaphore id if kernel (shared) semaphore */
+        int             syssem; /* 1 if kernel (shared) semaphore */
+        LIST_ENTRY(sem) entry;
+        struct sem      **backpointer;
+}; *)
+    semid_t        = pointer;
+    psem_t         = ^sem_t;
+    ppsem_t        = ^psem_t;
+    sem_t = record
+       magic   : cuint32;
+       lock    : pthread_mutex_t;
+       gtzero  : pthread_cond_t;
+       count   : cuint32;
+       nwaiters: cuint32;
+       semid   : semid_t;
+       sysse   : cint;
+       entry   : psem_t;
+       backpointer : ppsem_t;
+       spare   : array[0..SEM_SAFE] of char;
+
+    end;
+
+    TSemaphore         = sem_t;
+    PSemaphore         = ^TSemaphore;
+
+function  pthread_getspecific      (t : pthread_key_t):pointer; cdecl; external;
+function  pthread_setspecific      (t : pthread_key_t;p:pointer):cint; cdecl; external;
+function  pthread_key_create       (p : ppthread_key_t;f: __destr_func_t):cint; cdecl;external;
+function  pthread_attr_init           (p : ppthread_attr_t):cint; cdecl; external;
+function  pthread_attr_setinheritsched(p : ppthread_attr_t;i:cint):cint; cdecl; external;
+function  pthread_attr_setscope      (p : ppthread_attr_t;i:cint):cint;cdecl;external;
+function  pthread_attr_setdetachstate (p : ppthread_attr_t;i:cint):cint;cdecl;external;
+function  pthread_attr_setstacksize(p: ppthread_attr_t; stacksize: size_t):cint;cdecl;external;
+function  pthread_create ( p: ppthread_t;attr : ppthread_attr_t;f:__startroutine_t;arg:pointer):cint;cdecl;external;
+procedure pthread_exit  ( p: pointer); cdecl;external;
+function  pthread_self:pthread_t; cdecl;external;
+function  pthread_mutex_init (p:ppthread_mutex_t;o:ppthread_mutex_attr_t):cint; cdecl;external;
+function  pthread_mutex_destroy (p:ppthread_mutex_attr_t):cint; cdecl;external;
+function  pthread_mutex_lock    (p:ppthread_mutex_attr_t):cint; cdecl;external;
+function  pthread_mutex_trylock    (p:ppthread_mutex_attr_t):cint; cdecl;external;
+function  pthread_mutex_unlock  (p:ppthread_mutex_attr_t):cint; cdecl;external;
+function  pthread_cancel(_para1:pthread_t):cint;cdecl;external;
+function  pthread_detach(_para1:pthread_t):cint;cdecl;external;
+function  pthread_join(_para1:pthread_t; _para2:Ppointer):cint;cdecl;external;
+function pthread_cond_destroy(_para1:Ppthread_cond_t):cint;cdecl;external;
+function pthread_cond_init(_para1:Ppthread_cond_t;_para2:Ppthread_condattr_t):cint;cdecl;external;
+function pthread_cond_signal(_para1:Ppthread_cond_t):cint;cdecl;external;
+function pthread_cond_broadcast(_para1:Ppthread_cond_t):cint;cdecl;external;
+function pthread_cond_wait(_para1:Ppthread_cond_t;_para2:Ppthread_mutex_t):cint;cdecl;external;
+function pthread_kill(__thread:pthread_t; __signo:cint):cint;cdecl;external;
+function pthread_sigmask(how: cint; nset: psigset; oset: psigset): cint; cdecl; external;
+
+function sem_init(__sem:Psem_t; __pshared:cint;__value:dword):cint;cdecl; external;
+function sem_destroy(__sem:Psem_t):cint;cdecl;external ;
+function sem_close(__sem:Psem_t):cint;cdecl;external ;
+function sem_unlink(__name:Pchar):cint;cdecl;external ;
+function sem_wait(__sem:Psem_t):cint;cdecl;external ;
+function sem_trywait(__sem:Psem_t):cint;cdecl;external ;
+function sem_post(__sem:Psem_t):cint;cdecl;external ;
+function sem_getvalue(__sem:Psem_t; __sval:Pcint):cint;cdecl;external;
+function pthread_mutexattr_init(_para1:Ppthread_mutexattr_t):cint;cdecl;external;
+function pthread_mutexattr_destroy(_para1:Ppthread_mutexattr_t):cint;cdecl;external;
+function pthread_mutexattr_gettype(_para1:Ppthread_mutexattr_t; _para2:Pcint):cint;cdecl;external;
+function pthread_mutexattr_settype(_para1:Ppthread_mutexattr_t; _para2:cint):cint;cdecl;external;
+function pthread_cond_timedwait(__cond:ppthread_cond_t; __mutex:ppthread_mutex_t; __abstime:ptimespec):longint;cdecl;external;
+
+
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/ptypes.inc rtl/dragonfly/ptypes.inc
--- rtl/dragonfly.null/ptypes.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/ptypes.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,236 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 2001 by Free Pascal development team
+
+    This file implements all the base types and limits required
+    for a minimal POSIX compliant subset required to port the compiler
+    to a new OS.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+{***********************************************************************}
+{                       POSIX TYPE DEFINITIONS                          }
+{***********************************************************************}
+
+{$I ctypes.inc}
+{$packrecords c}
+
+const 
+    SEM_SAFE=255;
+type
+
+    dev_t    = cuint32;         { used for device numbers      }
+    TDev     = dev_t;
+    pDev     = ^dev_t;
+
+    gid_t    = cuint32;         { used for group IDs           }
+    TGid     = gid_t;
+    pGid     = ^gid_t;
+    TIOCtlRequest = cuLong;
+
+    ino_t    = cuint64;         { used for inode numbers       }
+    TIno     = ino_t;
+    pIno     = ^ino_t;
+
+    mode_t   = cuint16;         { used for file attributes     }
+    TMode    = mode_t;
+    pMode    = ^mode_t;
+
+    nlink_t  = cuint32;         { used for link counts         }
+    TnLink   = nlink_t;
+    pnLink   = ^nlink_t;
+
+    off_t    = cint64;          { used for file sizes          }
+    TOff     = off_t;
+    pOff     = ^off_t;
+
+    pid_t    = cint32;          { used as process identifier   }
+    TPid     = pid_t;
+    pPid     = ^pid_t;
+
+{$ifdef CPU64}
+    size_t   = cuint64;
+{$else}
+    size_t   = cuint32;         { as definied in the C standard}
+{$endif}
+    TSize    = size_t;
+    pSize    = ^size_t;
+    pSize_t  = ^size_t;
+
+{$ifdef CPU64}
+    ssize_t  = cint64;          { used by function for returning number of bytes }
+{$else}
+    ssize_t  = cint32;          { used by function for returning number of bytes}
+{$endif}
+
+    TsSize   = ssize_t;
+    psSize   = ^ssize_t;
+
+    uid_t    = cuint32;         { used for user ID type        }
+    TUid     = Uid_t;
+    pUid     = ^Uid_t;
+
+    wint_t    = cint32;
+    wchar_t   = cint32;
+    pwchar_t  = ^wchar_t;
+
+
+    clock_t  = culong;
+    TClock   = clock_t;
+    pClock   = ^clock_t;
+
+    time_t   = clong;           { used for returning the time }
+    pTime    = ^time_t;
+    ptime_t =  ^time_t;
+
+    socklen_t= cuint32;
+    TSocklen = socklen_t;
+    pSocklen = ^socklen_t;
+
+  timeval  = packed record
+    tv_sec,tv_usec:clong;
+  end;
+  ptimeval = ^timeval;
+  TTimeVal = timeval;
+
+  timespec = packed record
+    tv_sec   : time_t;                  // should be time_t, bug compability
+    tv_nsec  : clong;
+  end;
+  ptimespec= ^timespec;
+  Ttimespec= timespec;
+
+   pthread_t_rec        = record end;
+   pthread_attr_t_rec   = record end;
+//   pthread_mutex_t_rec   = record end;
+   pthread_mutexattr_t_rec   = record end;
+   pthread_cond_t_rec   = record end;
+   pthread_condattr_t_rec   = record end;
+   pthread_rwlock_t_rec   = record end;
+   pthread_rwlockattr_t_rec   = record end;
+
+   pthread_t            = ^pthread_t_rec;
+   pthread_attr_t       = ^pthread_attr_t_rec;
+   pthread_mutex_t      = {$i pmutext.inc}
+   pthread_mutexattr_t  = ^pthread_mutexattr_t_rec;
+   pthread_cond_t       = ^pthread_cond_t_rec;
+   pthread_condattr_t   = ^pthread_condattr_t_rec;
+   pthread_key_t        = cint;
+   pthread_rwlock_t     = ^pthread_rwlock_t_rec;
+   pthread_rwlockattr_t = ^pthread_rwlockattr_t_rec;
+  
+   psem_t = ^sem_t;
+   ppsem_t= ^psem_t;
+   semid_t= pointer;
+   sem_t = record
+       magic   : cuint32;
+       lock    : pthread_mutex_t;
+       gtzero  : pthread_cond_t;
+       count   : cuint32;
+       nwaiters: cuint32;
+       semid   : semid_t;
+       sysse   : cint;
+       entry   : psem_t;
+       backpointer : ppsem_t;
+       spare   : array[0..SEM_SAFE] of char;
+
+    end;
+
+   rlim_t		= int64;
+   TRlim		= rlim_t;
+  {
+     Mutex types (Single UNIX Specification, Version 2, 1997).
+
+     Note that a mutex attribute with one of the following types:
+
+     PTHREAD_MUTEX_NORMAL
+     PTHREAD_MUTEX_RECURSIVE
+     MUTEX_TYPE_FAST (deprecated)
+     MUTEX_TYPE_COUNTING_FAST (deprecated)
+
+       will deviate from POSIX specified semantics.
+      }
+
+  pthread_mutextype = (
+    { Default POSIX mutex  }
+    _PTHREAD_MUTEX_ERRORCHECK := 1,
+    { Recursive mutex  }
+    _PTHREAD_MUTEX_RECURSIVE := 2,
+    { No error checking  }
+    _PTHREAD_MUTEX_NORMAL    := 3,
+    _MUTEX_TYPE_MAX
+  );
+
+type
+  fsid_t  = array[0..1] of cint32;
+
+Const
+     MNAMELEN   = 80;
+     MFSNAMELEN = 16;	
+
+Type TStatFS = Record
+        spare2       : clong;          { placeholder }
+        bsize        : clong;          { fundamental filesystem fragment size }
+        iosize       : clong;          { optimal transfer block size }
+        blocks       : clong;          { total data blocks in filesystem }
+        bfree        : clong;          { free blocks in filesystem }
+        bavail       : clong;          { free blocks avail to non-superuser }
+        files        : clong;          { total file nodes in filesystem }
+        ffree        : clong;          { free file nodes in filesystem }
+        fsid         : fsid_t;         { filesystem id }
+        fowner       : tuid;           { user that mounted the filesystem }
+        ftype        : cint32;         { type of filesystem }
+	fflags       : cint32;         { copy of mount exported flags }
+        fsyncwrites  : clong;          { count of sync writes since mount }
+        fasyncwrites : clong;          { count of async writes since mount }
+        fstypename   : array[0..MFSNAMELEN-1] of char; { filesystem type name }
+        mntonname    : array[0..  MNAMELEN-1] of char; { directory on which mounted }
+        fsyncreads   : clong;          { count of sync reads since mount }
+        fasyncreads  : clong;          { count of async reads since mount }
+        fspares1     : cshort;         { unused spare }
+        mntfromname  : array[0..  MNAMELEN-1] of char; { mounted filesystem }
+        fspares2     : cshort;         { unused spare }
+        fspares3     : clong;          { unused spare }
+        fspares4     : clong;          { unused spare }
+     end; 
+     PStatFS=^TStatFS;
+
+  mbstate_t = record
+      case byte of
+        0: (__mbstate8: array[0..127] of char);
+        1: (_mbstateL: cint64); { for alignment }
+    end;
+    pmbstate_t = ^mbstate_t;
+
+  ITimerVal= Record
+              It_Interval,
+              It_Value      : TimeVal;
+             end;
+
+const
+  _PTHREAD_MUTEX_DEFAULT     = _PTHREAD_MUTEX_ERRORCHECK;
+  _MUTEX_TYPE_FAST          = _PTHREAD_MUTEX_NORMAL;
+  _MUTEX_TYPE_COUNTING_FAST = _PTHREAD_MUTEX_RECURSIVE;
+
+  _PTHREAD_KEYS_MAX              = 256;
+  _PTHREAD_STACK_MIN             = 1024;
+
+   { System limits, POSIX value in parentheses, used for buffer and stack allocation }
+    ARG_MAX    = 262144;  {4096}  { Maximum number of argument size     }
+    NAME_MAX   = 255;     {14}    { Maximum number of bytes in filename }
+    PATH_MAX   = 1024;    {255}   { Maximum number of bytes in pathname }
+    SYS_NMLN   = 32;              { BSD utsname struct limit, kernel mode }
+    SIG_MAXSIG = 128;             { highest signal version }
+
+  { For getting/setting priority }
+   Prio_Process = 0;
+   Prio_PGrp    = 1;
+   Prio_User    = 2;
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/si_crt.pp rtl/dragonfly/si_crt.pp
--- rtl/dragonfly.null/si_crt.pp	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/si_crt.pp	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,26 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 2005 by Michael Van Canneyt, Peter Vreman,
+    & Daniel Mantione, members of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+unit si_crt;
+
+interface
+
+{$i si_intf.inc}
+
+implementation
+
+{$i sysnr.inc}
+{$i si_crt.inc}
+
+end.
diff -ur --unidirectional-new-file rtl/dragonfly.null/si_intf.inc rtl/dragonfly/si_intf.inc
--- rtl/dragonfly.null/si_intf.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/si_intf.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,7 @@
+{$SMARTLINK OFF}
+
+var
+  initialstkptr: pointer; public name '__stkptr';
+  operatingsystem_parameter_envp: ppchar; public name 'operatingsystem_parameter_envp';
+  operatingsystem_parameter_argc: ptruint; public name 'operatingsystem_parameter_argc';
+  operatingsystem_parameter_argv: ppchar; public name 'operatingsystem_parameter_argv';
diff -ur --unidirectional-new-file rtl/dragonfly.null/sysctlh.inc rtl/dragonfly/sysctlh.inc
--- rtl/dragonfly.null/sysctlh.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/sysctlh.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,898 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 2001 by Marco van de Voort
+
+    The OS dependant sysctl constants.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+
+CONST
+
+{
+ * Definitions for sysctl call.  The sysctl call uses a hierarchical name
+ * for objects that can be examined or modified.  The name is expressed as
+ * a sequence of integers.  Like a file path name, the meaning of each
+ * component depends on its place in the hierarchy.  The top-level and kern
+ * identifiers are defined here, and other identifiers are defined in the
+ * respective subsystem header files.
+}
+
+        CTL_MAXNAME     = 12;   {  largest number of components supported }
+
+{
+ * Each subsystem defined by sysctl defines a list of variables
+ * for that subsystem. Each name is either a node with further
+ * levels defined below it, or it is a leaf of some particular
+ * type given below. Each sysctl level defines a set of name/type
+ * pairs to be used by sysctl(1) in manipulating the subsystem.
+}
+
+Type
+    ctlname = record
+                ctl_name : pchar;       {  subsystem name }
+                ctl_type : cint         {  type of name }
+               End;
+
+Const
+        CTLTYPE         = $f;   {  Mask for the type }
+        CTLTYPE_NODE    = 1;    {  name is a node }
+        CTLTYPE_INT     = 2;    {  name describes an integer }
+        CTLTYPE_STRING  = 3;    {  name describes a string }
+        CTLTYPE_QUAD    = 4;    {  name describes a 64-bit number }
+        CTLTYPE_OPAQUE  = 5;    {  name describes a structure }
+        CTLTYPE_STRUCT  = CTLTYPE_OPAQUE;       {  name describes a structure }
+        CTLTYPE_UINT    = 6;    {  name describes an unsigned integer }
+        CTLTYPE_LONG    = 7;    {  name describes a long }
+        CTLTYPE_ULONG   = 8;    {  name describes an unsigned long }
+        CTLTYPE_UQUAD   = 9;    {  name describes an unsigned 64-bit number }
+
+        CTLFLAG_RD      = $80000000;    {  Allow reads of variable }
+        CTLFLAG_WR      = $40000000;    {  Allow writes to the variable }
+        CTLFLAG_RW      = (CTLFLAG_RD OR CTLFLAG_WR);
+        CTLFLAG_NOLOCK  = $20000000;    {  XXX Don't Lock }
+        CTLFLAG_ANYBODY = $10000000;    {  All users can set this var }
+        CTLFLAG_SECURE  = $8000000;     {  Permit set only if securelevel<=0 }
+        CTLFLAG_PRISON  = $4000000;     {  Prisoned roots can fiddle }
+        CTLFLAG_DYN     = $2000000;     {  Dynamic oid - can be freed }
+        CTLFLAG_SKIP    = $1000000;     {  Skip this sysctl when listing }
+        CTLMASK_SECURE  = $F00000;      {  Secure level }
+        CTLFLAG_DYING   = $1000;        {  Oid is being removed }
+
+{
+ * USE THIS instead of a hardwired number from the categories below
+ * to get dynamically assigned sysctl entries using the linker-set
+ * technology. This is the way nearly all new sysctl variables should
+ * be implemented.
+ * e.g. SYSCTL_INT(_parent, OID_AUTO, name, CTLFLAG_RW, &variable, 0, "");
+ }
+        OID_AUTO        = (-1);
+
+{
+ * Top-level identifiers
+ }
+        CTL_UNSPEC      = 0;
+        CTL_KERN        = 1;            {  "high kernel": proc, limits }
+        CTL_VM          = 2;            {  virtual memory }
+        CTL_VFS         = 3;            {  file system, mount type is next }
+        CTL_NET         = 4;            {  network, see socket.h }
+        CTL_DEBUG       = 5;            {  debugging parameters }
+        CTL_HW          = 6;            {  generic cpu/io }
+        CTL_MACHDEP     = 7;            {  machine dependent }
+        CTL_USER        = 8;            {  user-level }
+        CTL_P1003_1B    = 9;            {  POSIX 1003.1B }
+        CTL_LWKT        = 10;           {  light-weight kernel threads }
+        CTL_MAXID       = 11;           {  number of top-level ids }
+
+
+{
+ * CTL_KERN identifiers
+ }
+        KERN_OSTYPE             =  1;   {  string: system version }
+        KERN_OSRELEASE          =  2;   {  string: system release }
+        KERN_OSREV              =  3;   {  int: system revision }
+        KERN_VERSION            =  4;   {  string: compile time info }
+        KERN_MAXVNODES          =  5;   {  int: max vnodes }
+        KERN_MAXPROC            =  6;   {  int: max processes }
+        KERN_MAXFILES           =  7;   {  int: max open files }
+        KERN_ARGMAX             =  8;   {  int: max arguments to exec }
+        KERN_SECURELVL          =  9;   {  int: system security level }
+        KERN_HOSTNAME           = 10;   {  string: hostname }
+        KERN_HOSTID             = 11;   {  int: host identifier }
+        KERN_CLOCKRATE          = 12;   {  struct: struct clockrate }
+        KERN_VNODE              = 13;   {  struct: vnode structures }
+        KERN_PROC               = 14;   {  struct: process entries }
+        KERN_FILE               = 15;   {  struct: file entries }
+        KERN_PROF               = 16;   {  node: kernel profiling info }
+        KERN_POSIX1             = 17;   {  int: POSIX.1 version }
+        KERN_NGROUPS            = 18;   {  int: # of supplemental group ids }
+        KERN_JOB_CONTROL        = 19;   {  int: is job control available }
+        KERN_SAVED_IDS          = 20;   {  int: saved set-user/group-ID }
+        KERN_BOOTTIME           = 21;   {  struct: time kernel was booted }
+        KERN_NISDOMAINNAME      = 22;   {  string: YP domain name }
+        KERN_UPDATEINTERVAL     = 23;   {  int: update process sleep time }
+        KERN_OSRELDATE          = 24;   {  int: OS release date }
+        KERN_NTP_PLL            = 25;   {  node: NTP PLL control }
+        KERN_BOOTFILE           = 26;   {  string: name of booted kernel }
+        KERN_MAXFILESPERPROC    = 27;   {  int: max open files per proc }
+        KERN_MAXPROCPERUID      = 28;   {  int: max processes per uid }
+        KERN_DUMPDEV            = 29;   {  dev_t: device to dump on }
+        KERN_IPC                = 30;   {  node: anything related to IPC }
+        KERN_DUMMY              = 31;   {  unused }
+        KERN_PS_STRINGS         = 32;   {  int: address of PS_STRINGS }
+        KERN_USRSTACK           = 33;   {  int: address of USRSTACK }
+        KERN_LOGSIGEXIT         = 34;   {  int: do we log sigexit procs? }
+        KERN_IOV_MAX            = 35;   {  int: value of UIO_MAXIOV }
+        KERN_MAXPOSIXLOCKSPERUID= 36;   {  int: max POSIX locks per uid }
+        KERN_MAXID              = 37;   {  number of valid kern ids }
+
+
+{
+ * KERN_PROC subtypes
+ }
+        KERN_PROC_ALL           = 0;    {  everything }
+        KERN_PROC_PID           = 1;    {  by process id }
+        KERN_PROC_PGRP          = 2;    {  by process group id }
+        KERN_PROC_SESSION       = 3;    {  by session of pid }
+        KERN_PROC_TTY           = 4;    {  by controlling tty }
+        KERN_PROC_UID           = 5;    {  by effective uid }
+        KERN_PROC_RUID          = 6;    {  by real uid }
+        KERN_PROC_ARGS          = 7;    {  get/set arguments/proctitle }
+ 	KERN_PROC_CWD           = 8;    {  get cwd }
+        KERN_PROC_PATHNAME      = 9;    {  path to executable }
+
+{
+ * KERN_IPC identifiers
+ }
+        KIPC_MAXSOCKBUF         = 1;    {  int: max size of a socket buffer }
+        KIPC_SOCKBUF_WASTE      = 2;    {  int: wastage factor in sockbuf }
+        KIPC_SOMAXCONN          = 3;    {  int: max length of connection q }
+        KIPC_MAX_LINKHDR        = 4;    {  int: max length of link header }
+        KIPC_MAX_PROTOHDR       = 5;    {  int: max length of network header }
+        KIPC_MAX_HDR            = 6;    {  int: max total length of headers }
+        KIPC_MAX_DATALEN        = 7;    {  int: max length of data? }
+        KIPC_MBSTAT             = 8;    {  struct: mbuf usage statistics }
+        KIPC_NMBCLUSTERS        = 9;    {  int: maximum mbuf clusters }
+
+{
+ * CTL_HW identifiers
+ }
+        HW_MACHINE          =  1;       {  string: machine class }
+        HW_MODEL            =  2;       {  string: specific machine model }
+        HW_NCPU             =  3;       {  int: number of cpus }
+        HW_BYTEORDER        =  4;       {  int: machine byte order }
+        HW_PHYSMEM          =  5;       {  int: total memory }
+        HW_USERMEM          =  6;       {  int: non-kernel memory }
+        HW_PAGESIZE         =  7;       {  int: software page size }
+        HW_DISKNAMES        =  8;       {  strings: disk drive names }
+        HW_DISKSTATS        =  9;       {  struct: diskstats[] }
+        HW_FLOATINGPT       = 10;       {  int: has HW floating point? }
+        HW_MACHINE_ARCH     = 11;       {  string: machine architecture }
+        HW_MACHINE_PLATFORM = 12;       {  string: platform architecture }
+        HW_SENSORS          = 13;       {  node: hardware sensors }
+        HW_MAXID            = 14;       {  number of valid hw ids }
+
+
+{
+ * CTL_USER definitions
+ }
+        USER_CS_PATH            =  1;   {  string: _CS_PATH }
+        USER_BC_BASE_MAX        =  2;   {  int: BC_BASE_MAX }
+        USER_BC_DIM_MAX         =  3;   {  int: BC_DIM_MAX }
+        USER_BC_SCALE_MAX       =  4;   {  int: BC_SCALE_MAX }
+        USER_BC_STRING_MAX      =  5;   {  int: BC_STRING_MAX }
+        USER_COLL_WEIGHTS_MAX   =  6;   {  int: COLL_WEIGHTS_MAX }
+        USER_EXPR_NEST_MAX      =  7;   {  int: EXPR_NEST_MAX }
+        USER_LINE_MAX           =  8;   {  int: LINE_MAX }
+        USER_RE_DUP_MAX         =  9;   {  int: RE_DUP_MAX }
+        USER_POSIX2_VERSION     = 10;   {  int: POSIX2_VERSION }
+        USER_POSIX2_C_BIND      = 11;   {  int: POSIX2_C_BIND }
+        USER_POSIX2_C_DEV       = 12;   {  int: POSIX2_C_DEV }
+        USER_POSIX2_CHAR_TERM   = 13;   {  int: POSIX2_CHAR_TERM }
+        USER_POSIX2_FORT_DEV    = 14;   {  int: POSIX2_FORT_DEV }
+        USER_POSIX2_FORT_RUN    = 15;   {  int: POSIX2_FORT_RUN }
+        USER_POSIX2_LOCALEDEF   = 16;   {  int: POSIX2_LOCALEDEF }
+        USER_POSIX2_SW_DEV      = 17;   {  int: POSIX2_SW_DEV }
+        USER_POSIX2_UPE         = 18;   {  int: POSIX2_UPE }
+        USER_STREAM_MAX         = 19;   {  int: POSIX2_STREAM_MAX }
+        USER_TZNAME_MAX         = 20;   {  int: POSIX2_TZNAME_MAX }
+        USER_MAXID              = 21;   {  number of valid user ids }
+
+
+        CTL_P1003_1B_ASYNCHRONOUS_IO            = 1 ;   {  boolean }
+        CTL_P1003_1B_MAPPED_FILES               = 2 ;   {  boolean }
+        CTL_P1003_1B_MEMLOCK                    = 3 ;   {  boolean }
+        CTL_P1003_1B_MEMLOCK_RANGE              = 4 ;   {  boolean }
+        CTL_P1003_1B_MEMORY_PROTECTION          = 5 ;   {  boolean }
+        CTL_P1003_1B_MESSAGE_PASSING            = 6 ;   {  boolean }
+        CTL_P1003_1B_PRIORITIZED_IO             = 7 ;   {  boolean }
+        CTL_P1003_1B_PRIORITY_SCHEDULING        = 8 ;   {  boolean }
+        CTL_P1003_1B_REALTIME_SIGNALS           = 9 ;   {  boolean }
+        CTL_P1003_1B_SEMAPHORES                 = 10;   {  boolean }
+        CTL_P1003_1B_FSYNC                      = 11;   {  boolean }
+        CTL_P1003_1B_SHARED_MEMORY_OBJECTS      = 12;   {  boolean }
+        CTL_P1003_1B_SYNCHRONIZED_IO            = 13;   {  boolean }
+        CTL_P1003_1B_TIMERS                     = 14;   {  boolean }
+        CTL_P1003_1B_AIO_LISTIO_MAX             = 15;   {  int }
+        CTL_P1003_1B_AIO_MAX                    = 16;   {  int }
+        CTL_P1003_1B_AIO_PRIO_DELTA_MAX         = 17;   {  int }
+        CTL_P1003_1B_DELAYTIMER_MAX             = 18;   {  int }
+        CTL_P1003_1B_MQ_OPEN_MAX                = 19;   {  int }
+        CTL_P1003_1B_PAGESIZE                   = 20;   {  int }
+        CTL_P1003_1B_RTSIG_MAX                  = 21;   {  int }
+        CTL_P1003_1B_SEM_NSEMS_MAX              = 22;   {  int }
+        CTL_P1003_1B_SEM_VALUE_MAX              = 23;   {  int }
+        CTL_P1003_1B_SIGQUEUE_MAX               = 24;   {  int }
+        CTL_P1003_1B_TIMER_MAX                  = 25;   {  int }
+
+        CTL_P1003_1B_MAXID                      = 26;
+
+{       LongestStringInCtlNames = 21;}
+
+
+Const
+
+        CTL_NAMES : Array[0..10] OF CtlNameRec =  (
+        ( Name: '';  CtlType: 0 ),
+        ( Name: 'kern';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'vm';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'vfs';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'net';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'debug';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'hw';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'machdep';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'user';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'p1003_1b';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'lwkt'; CtlType : CTLTYPE_NODE));
+
+        CTL_KERN_NAME : Array[0..35] OF CtlNameRec = (
+        ( Name: ''; CtlType: 0 ),
+        ( Name: 'ostype';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'osrelease';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'osrevision';  CtlType : CTLTYPE_INT ),
+        ( Name: 'version';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'maxvnodes';  CtlType : CTLTYPE_INT ),
+        ( Name: 'maxproc';  CtlType : CTLTYPE_INT ),
+        ( Name: 'maxfiles';  CtlType : CTLTYPE_INT ),
+        ( Name: 'argmax';  CtlType : CTLTYPE_INT ),
+        ( Name: 'securelevel';  CtlType : CTLTYPE_INT ),
+        ( Name: 'hostname';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'hostid';  CtlType : CTLTYPE_UINT ),
+        ( Name: 'clockrate';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'vnode';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'proc';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'file';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'profiling';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'posix1version';  CtlType : CTLTYPE_INT ),
+        ( Name: 'ngroups';  CtlType : CTLTYPE_INT ),
+        ( Name: 'job_control';  CtlType : CTLTYPE_INT ),
+        ( Name: 'saved_ids';  CtlType : CTLTYPE_INT ),
+        ( Name: 'boottime';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'nisdomainname';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'update';  CtlType : CTLTYPE_INT ),
+        ( Name: 'osreldate';  CtlType : CTLTYPE_INT ),
+        ( Name: 'ntp_pll';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'bootfile';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'maxfilesperproc';  CtlType : CTLTYPE_INT ),
+        ( Name: 'maxprocperuid';  CtlType : CTLTYPE_INT ),
+        ( Name: 'dumpdev';  CtlType : CTLTYPE_STRUCT ), {  we lie; don't print as int }
+        ( Name: 'ipc';  CtlType : CTLTYPE_NODE ),
+        ( Name: 'dummy';  CtlType : CTLTYPE_INT ),
+        ( Name: 'ps_strings';  CtlType : CTLTYPE_INT ),
+        ( Name: 'usrstack';  CtlType : CTLTYPE_INT ),
+        ( Name: 'iov_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'maxposixlocksperuid';  CtlType : CTLTYPE_INT ));
+
+{
+ * CTL_VFS identifiers
+}
+        CTL_VFS_NAMES : array[0..0] of CTLNameRec = (
+        ( Name: 'vfsconf';  CtlType : CTLTYPE_STRUCT ));
+
+
+        CTL_HW_NAMES : array[0..13] of CTLNameRec = (
+        ( Name: ''; CtlType: 0 ),
+        ( Name: 'machine';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'model';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'ncpu';  CtlType : CTLTYPE_INT ),
+        ( Name: 'byteorder';  CtlType : CTLTYPE_INT ),
+        ( Name: 'physmem';  CtlType : CTLTYPE_UINT ),
+        ( Name: 'usermem';  CtlType : CTLTYPE_UINT ),
+        ( Name: 'pagesize';  CtlType : CTLTYPE_INT ),
+        ( Name: 'disknames';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'diskstats';  CtlType : CTLTYPE_STRUCT ),
+        ( Name: 'floatingpoint';  CtlType : CTLTYPE_INT ),
+        ( Name: 'arch';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'platform';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'sensors';  CtlType : CTLTYPE_NODE ));
+
+
+        CTL_USER_NAMES  : array[0..20] of CTLNameRec = (
+        ( Name :''; CtlType: 0 ),
+        ( Name: 'cs_path';  CtlType : CTLTYPE_STRING ),
+        ( Name: 'bc_base_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'bc_dim_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'bc_scale_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'bc_string_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'coll_weights_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'expr_nest_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'line_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 're_dup_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_version';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_c_bind';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_c_dev';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_char_term';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_fort_dev';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_fort_run';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_localedef';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_sw_dev';  CtlType : CTLTYPE_INT ),
+        ( Name: 'posix2_upe';  CtlType : CTLTYPE_INT ),
+        ( Name: 'stream_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'tzname_max';  CtlType : CTLTYPE_INT ));
+
+        CTL_P1003_1B_NAMES  : array[0..25] of CTLNameRec = (
+        ( Name: ''; CtlType: 0 ),
+        ( Name: 'asynchronous_io';  CtlType : CTLTYPE_INT ),
+        ( Name: 'mapped_files';  CtlType : CTLTYPE_INT ),
+        ( Name: 'memlock';  CtlType : CTLTYPE_INT ),
+        ( Name: 'memlock_range';  CtlType : CTLTYPE_INT ),
+        ( Name: 'memory_protection';  CtlType : CTLTYPE_INT ),
+        ( Name: 'message_passing';  CtlType : CTLTYPE_INT ),
+        ( Name: 'prioritized_io';  CtlType : CTLTYPE_INT ),
+        ( Name: 'priority_scheduling';  CtlType : CTLTYPE_INT ),
+        ( Name: 'realtime_signals';  CtlType : CTLTYPE_INT ),
+        ( Name: 'semaphores';  CtlType : CTLTYPE_INT ),
+        ( Name: 'fsync';  CtlType : CTLTYPE_INT ),
+        ( Name: 'shared_memory_objects';  CtlType : CTLTYPE_INT ),
+        ( Name: 'synchronized_io';  CtlType : CTLTYPE_INT ),
+        ( Name: 'timers';  CtlType : CTLTYPE_INT ),
+        ( Name: 'aio_listio_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'aio_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'aio_prio_delta_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'delaytimer_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'mq_open_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'pagesize';  CtlType : CTLTYPE_INT ),
+        ( Name: 'rtsig_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'nsems_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'sem_value_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'sigqueue_max';  CtlType : CTLTYPE_INT ),
+        ( Name: 'timer_max';  CtlType : CTLTYPE_INT ));
+
+
+const
+{
+ * Types
+}
+        SOCK_STREAM     = 1;            { stream socket }
+        SOCK_DGRAM      = 2;            { datagram socket }
+        SOCK_RAW        = 3;            { raw-protocol interface }
+        SOCK_RDM        = 4;            { reliably-delivered message }
+        SOCK_SEQPACKET  = 5;            { sequenced packet stream }
+
+{
+ * Address families.
+}
+        AF_UNSPEC       = 0;            { unspecified }
+        AF_LOCAL        = 1;            { local to host (Name:pipes;CtlType: portals) }
+        AF_UNIX         = AF_LOCAL;     { backward compatibility }
+        AF_INET         = 2;            { internetwork: UDP, TCP, etc. }
+        AF_IMPLINK      = 3;            { arpanet imp addresses }
+        AF_PUP          = 4;            { pup protocols: e.g. BSP }
+        AF_CHAOS        = 5;            { mit CHAOS protocols }
+        AF_NS           = 6;            { XEROX NS protocols }
+        AF_ISO          = 7;            { ISO protocols }
+        AF_OSI          = AF_ISO;
+        AF_ECMA         = 8;            { European computer manufacturers }
+        AF_DATAKIT      = 9;            { datakit protocols }
+        AF_CCITT        = 10;           { CCITT protocols, X.25 etc }
+        AF_SNA          = 11;           { IBM SNA }
+        AF_DECnet       = 12;           { DECnet }
+        AF_DLI          = 13;           { DEC Direct data link interface }
+        AF_LAT          = 14;           { LAT }
+        AF_HYLINK       = 15;           { NSC Hyperchannel }
+        AF_APPLETALK    = 16;           { Apple Talk }
+        AF_ROUTE        = 17;           { Internal Routing Protocol }
+        AF_LINK         = 18;           { Link layer interface }
+        pseudo_AF_XTP   = 19;           { eXpress Transfer Protocol (Name:no AF) }
+        AF_COIP         = 20;           { connection-oriented IP, aka ST II }
+        AF_CNT          = 21;           { Computer Network Technology }
+        pseudo_AF_RTIP  = 22;           { Help Identify RTIP packets }
+        AF_IPX          = 23;           { Novell Internet Protocol }
+        AF_SIP          = 24;           { Simple Internet Protocol }
+        pseudo_AF_PIP   = 25;           { Help Identify PIP packets }
+        AF_ISDN         = 26;           { Integrated Services Digital Network}
+        AF_E164         = AF_ISDN;      { CCITT E.164 recommendation }
+        pseudo_AF_KEY   = 27;           { Internal key-management function }
+        AF_INET6        = 28;           { IPv6 }
+        AF_NATM         = 29;           { native ATM access }
+        AF_ATM          = 30;           { ATM }
+        pseudo_AF_HDRCMPLT = 31;        { Used by BPF to not rewrite headers }
+        AF_NETGRAPH     = 32;           { Netgraph sockets }
+        AF_BLUETOOTH    = 33;           { Bluetooth }
+        AF_MPLS         = 34;           { Multi-Protocol Label Switching }
+        AF_IEEE80211    = 35;           { IEEE 802.11 protocol }
+
+        AF_MAX          = 36;
+
+{
+ * Protocol families, same as address families for now.
+}
+
+{
+ * Definitions for network related sysctl, CTL_NET.
+ *
+ * Second level is protocol family.
+ * Third level is protocol number.
+ *
+ * Further levels are defined by the individual families below.
+}
+        NET_MAXID       = AF_MAX;
+
+        CTL_NET_NAMES  : Array[0..33] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'unix';CtlType: CTLTYPE_NODE ),
+        (Name: 'inet';CtlType: CTLTYPE_NODE ),
+        (Name: 'implink';CtlType: CTLTYPE_NODE ),
+        (Name: 'pup';CtlType: CTLTYPE_NODE ),
+        (Name: 'chaos';CtlType: CTLTYPE_NODE ),
+        (Name: 'xerox_ns';CtlType: CTLTYPE_NODE ),
+        (Name: 'iso';CtlType: CTLTYPE_NODE ),
+        (Name: 'emca';CtlType: CTLTYPE_NODE ),
+        (Name: 'datakit';CtlType: CTLTYPE_NODE ),
+        (Name: 'ccitt';CtlType: CTLTYPE_NODE ),
+        (Name: 'ibm_sna';CtlType: CTLTYPE_NODE ),
+        (Name: 'decnet';CtlType: CTLTYPE_NODE ),
+        (Name: 'dec_dli';CtlType: CTLTYPE_NODE ),
+        (Name: 'lat';CtlType: CTLTYPE_NODE ),
+        (Name: 'hylink';CtlType: CTLTYPE_NODE ),
+        (Name: 'appletalk';CtlType: CTLTYPE_NODE ),
+        (Name: 'route';CtlType: CTLTYPE_NODE ),
+        (Name: 'link_layer';CtlType: CTLTYPE_NODE ),
+        (Name: 'xtp';CtlType: CTLTYPE_NODE ),
+        (Name: 'coip';CtlType: CTLTYPE_NODE ),
+        (Name: 'cnt';CtlType: CTLTYPE_NODE ),
+        (Name: 'rtip';CtlType: CTLTYPE_NODE ),
+        (Name: 'ipx';CtlType: CTLTYPE_NODE ),
+        (Name: 'sip';CtlType: CTLTYPE_NODE ),
+        (Name: 'pip';CtlType: CTLTYPE_NODE ),
+        (Name: 'isdn';CtlType: CTLTYPE_NODE ),
+        (Name: 'key';CtlType: CTLTYPE_NODE ),
+        (Name: 'inet6';CtlType: CTLTYPE_NODE ),
+        (Name: 'natm';CtlType: CTLTYPE_NODE ),
+        (Name: 'atm';CtlType: CTLTYPE_NODE ),
+        (Name: 'hdrcomplete';CtlType: CTLTYPE_NODE ),
+        (Name: 'netgraph';CtlType: CTLTYPE_NODE ),
+        (Name: 'bluetooth';CtlType: CTLTYPE_NODE ));
+
+{
+ * PF_ROUTE - Routing table
+ *
+ * Three additional levels are defined:
+ *      Fourth: address family, 0 is wildcard
+ *      Fifth: type of info, defined below
+ *      Sixth: flag(Name:s) to mask with for NET_RT_FLAGS
+}
+        NET_RT_DUMP     = 1;            { dump; may limit to a.f. }
+        NET_RT_FLAGS    = 2;            { by flags, e.g. RESOLVING }
+        NET_RT_IFLIST   = 3;            { survey interface list }
+        NET_RT_MAXID    = 4;
+
+        CTL_NET_RT_NAMES  : Array[0..3] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'dump';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'flags';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'iflist';CtlType: CTLTYPE_STRUCT ));
+
+{
+ * Possible states of profiling.
+}
+        GMON_PROF_ON    = 0;
+        GMON_PROF_BUSY  = 1;
+        GMON_PROF_ERROR = 2;
+        GMON_PROF_OFF   = 3;
+        GMON_PROF_HIRES = 4;
+
+{
+ * Sysctl definitions for extracting profiling information from the kernel.
+}
+        GPROF_STATE     = 0;    { int: profiling enabling variable }
+        GPROF_COUNT     = 1;    { struct: profile tick count buffer }
+        GPROF_FROMS     = 2;    { struct: from location hash bucket }
+        GPROF_TOS       = 3;    { struct: destination/count structure }
+        GPROF_GMONPARAM = 4;    { struct: profiling parameters (Name:see above) }
+
+{
+ * CTL_VM identifiers
+}
+        VM_METER                = 1;    { struct vmmeter }
+        VM_LOADAVG              = 2;    { struct loadavg }
+        VM_V_FREE_MIN           = 3;    { cnt.v_free_min }
+        VM_V_FREE_TARGET        = 4;    { cnt.v_free_target }
+        VM_V_FREE_RESERVED      = 5;    { cnt.v_free_reserved }
+        VM_V_INACTIVE_TARGET    = 6;    { cnt.v_inactive_target }
+        VM_V_CACHE_MIN          = 7;    { cnt.v_cache_max }
+        VM_V_CACHE_MAX          = 8;    { cnt.v_cache_min }
+        VM_V_PAGEOUT_FREE_MIN   = 9;    { cnt.v_pageout_free_min }
+        VM_PAGEOUT_ALGORITHM    = 10;   { pageout algorithm }
+        VM_SWAPPING_ENABLED     = 11;   { swapping enabled }
+        VM_MAXID                = 12;   { number of valid vm ids }
+
+        CTL_VM_NAMES  : Array[0..11] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'vmmeter';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'loadavg';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'v_free_min';CtlType: CTLTYPE_INT ),
+        (Name: 'v_free_target';CtlType: CTLTYPE_INT ),
+        (Name: 'v_free_reserved';CtlType: CTLTYPE_INT ),
+        (Name: 'v_inactive_target';CtlType: CTLTYPE_INT ),
+        (Name: 'v_cache_min';CtlType: CTLTYPE_INT ),
+        (Name: 'v_cache_max';CtlType: CTLTYPE_INT ),
+        (Name: 'v_pageout_free_min';CtlType: CTLTYPE_INT),
+        (Name: 'pageout_algorithm';CtlType: CTLTYPE_INT),
+        (Name: 'swapping_enabled';CtlType: CTLTYPE_INT));
+
+{
+ * Protocols (Name:RFC 1700)
+}
+        IPPROTO_IP              = 0;            { dummy for IP }
+        IPPROTO_HOPOPTS         = 0;            { IP6 hop-by-hop options }
+        IPPROTO_ICMP            = 1;            { control message protocol }
+        IPPROTO_IGMP            = 2;            { group mgmt protocol }
+        IPPROTO_GGP             = 3;            { gateway^2 (Name:deprecated) }
+        IPPROTO_IPV4            = 4;            { IPv4 encapsulation }
+        IPPROTO_IPIP            = IPPROTO_IPV4; { for compatibility }
+        IPPROTO_TCP             = 6;            { tcp }
+        IPPROTO_ST              = 7;            { Stream protocol II }
+        IPPROTO_EGP             = 8;            { exterior gateway protocol }
+        IPPROTO_PIGP            = 9;            { private interior gateway }
+        IPPROTO_RCCMON          = 10;           { BBN RCC Monitoring }
+        IPPROTO_NVPII           = 11;           { network voice protocol}
+        IPPROTO_PUP             = 12;           { pup }
+        IPPROTO_ARGUS           = 13;           { Argus }
+        IPPROTO_EMCON           = 14;           { EMCON }
+        IPPROTO_XNET            = 15;           { Cross Net Debugger }
+        IPPROTO_CHAOS           = 16;           { Chaos}
+        IPPROTO_UDP             = 17;           { user datagram protocol }
+        IPPROTO_MUX             = 18;           { Multiplexing }
+        IPPROTO_MEAS            = 19;           { DCN Measurement Subsystems }
+        IPPROTO_HMP             = 20;           { Host Monitoring }
+        IPPROTO_PRM             = 21;           { Packet Radio Measurement }
+        IPPROTO_IDP             = 22;           { xns idp }
+        IPPROTO_TRUNK1          = 23;           { Trunk-1 }
+        IPPROTO_TRUNK2          = 24;           { Trunk-2 }
+        IPPROTO_LEAF1           = 25;           { Leaf-1 }
+        IPPROTO_LEAF2           = 26;           { Leaf-2 }
+        IPPROTO_RDP             = 27;           { Reliable Data }
+        IPPROTO_IRTP            = 28;           { Reliable Transaction }
+        IPPROTO_TP              = 29;           { tp-4 w/ class negotiation }
+        IPPROTO_BLT             = 30;           { Bulk Data Transfer }
+        IPPROTO_NSP             = 31;           { Network Services }
+        IPPROTO_INP             = 32;           { Merit Internodal }
+        IPPROTO_SEP             = 33;           { Sequential Exchange }
+        IPPROTO_3PC             = 34;           { Third Party Connect }
+        IPPROTO_IDPR            = 35;           { InterDomain Policy Routing }
+        IPPROTO_XTP             = 36;           { XTP }
+        IPPROTO_DDP             = 37;           { Datagram Delivery }
+        IPPROTO_CMTP            = 38;           { Control Message Transport }
+        IPPROTO_TPXX            = 39;           { TP++ Transport }
+        IPPROTO_IL              = 40;           { IL transport protocol }
+        IPPROTO_IPV6            = 41;           { IP6 header }
+        IPPROTO_SDRP            = 42;           { Source Demand Routing }
+        IPPROTO_ROUTING         = 43;           { IP6 routing header }
+        IPPROTO_FRAGMENT        = 44;           { IP6 fragmentation header }
+        IPPROTO_IDRP            = 45;           { InterDomain Routing}
+        IPPROTO_RSVP            = 46;           { resource reservation }
+        IPPROTO_GRE             = 47;           { General Routing Encap. }
+        IPPROTO_MHRP            = 48;           { Mobile Host Routing }
+        IPPROTO_BHA             = 49;           { BHA }
+        IPPROTO_ESP             = 50;           { IP6 Encap Sec. Payload }
+        IPPROTO_AH              = 51;           { IP6 Auth Header }
+        IPPROTO_INLSP           = 52;           { Integ. Net Layer Security }
+        IPPROTO_SWIPE           = 53;           { IP with encryption }
+        IPPROTO_NHRP            = 54;           { Next Hop Resolution }
+{ 55-57: Unassigned }
+        IPPROTO_ICMPV6          = 58;           { ICMP6 }
+        IPPROTO_NONE            = 59;           { IP6 no next header }
+        IPPROTO_DSTOPTS         = 60;           { IP6 destination option }
+        IPPROTO_AHIP            = 61;           { any host internal protocol }
+        IPPROTO_CFTP            = 62;           { CFTP }
+        IPPROTO_HELLO           = 63;           { 'hello' routing protocol }
+        IPPROTO_SATEXPAK        = 64;           { SATNET/Backroom EXPAK }
+        IPPROTO_KRYPTOLAN       = 65;           { Kryptolan }
+        IPPROTO_RVD             = 66;           { Remote Virtual Disk }
+        IPPROTO_IPPC            = 67;           { Pluribus Packet Core }
+        IPPROTO_ADFS            = 68;           { Any distributed FS }
+        IPPROTO_SATMON          = 69;           { Satnet Monitoring }
+        IPPROTO_VISA            = 70;           { VISA Protocol }
+        IPPROTO_IPCV            = 71;           { Packet Core Utility }
+        IPPROTO_CPNX            = 72;           { Comp. Prot. Net. Executive }
+        IPPROTO_CPHB            = 73;           { Comp. Prot. HeartBeat }
+        IPPROTO_WSN             = 74;           { Wang Span Network }
+        IPPROTO_PVP             = 75;           { Packet Video Protocol }
+        IPPROTO_BRSATMON        = 76;           { BackRoom SATNET Monitoring }
+        IPPROTO_ND              = 77;           { Sun net disk proto (Name:temp.) }
+        IPPROTO_WBMON           = 78;           { WIDEBAND Monitoring }
+        IPPROTO_WBEXPAK         = 79;           { WIDEBAND EXPAK }
+        IPPROTO_EON             = 80;           { ISO cnlp }
+        IPPROTO_VMTP            = 81;           { VMTP }
+        IPPROTO_SVMTP           = 82;           { Secure VMTP }
+        IPPROTO_VINES           = 83;           { Banyon VINES }
+        IPPROTO_TTP             = 84;           { TTP }
+        IPPROTO_IGP             = 85;           { NSFNET-IGP }
+        IPPROTO_DGP             = 86;           { dissimilar gateway prot. }
+        IPPROTO_TCF             = 87;           { TCF }
+        IPPROTO_IGRP            = 88;           { Cisco/GXS IGRP }
+        IPPROTO_OSPFIGP         = 89;           { OSPFIGP }
+        IPPROTO_SRPC            = 90;           { Strite RPC protocol }
+        IPPROTO_LARP            = 91;           { Locus Address Resoloution }
+        IPPROTO_MTP             = 92;           { Multicast Transport }
+        IPPROTO_AX25            = 93;           { AX.25 Frames }
+        IPPROTO_IPEIP           = 94;           { IP encapsulated in IP }
+        IPPROTO_MICP            = 95;           { Mobile Int.ing control }
+        IPPROTO_SCCSP           = 96;           { Semaphore Comm. security }
+        IPPROTO_ETHERIP         = 97;           { Ethernet IP encapsulation }
+        IPPROTO_ENCAP           = 98;           { encapsulation header }
+        IPPROTO_APES            = 99;           { any private encr. scheme }
+        IPPROTO_GMTP            = 100;          { GMTP}
+        IPPROTO_IPCOMP          = 108;          { payload compression (Name:IPComp) }
+{ 101-254: Partly Unassigned }
+        IPPROTO_PIM             = 103;          { Protocol Independent Mcast }
+        IPPROTO_PGM             = 113;          { PGM }
+{ 255: Reserved }
+{ BSD Private, local use, namespace incursion }
+        IPPROTO_DIVERT          = 254;          { divert pseudo-protocol }
+        IPPROTO_RAW             = 255;          { raw IP packet }
+        IPPROTO_MAX             = 256;
+
+{ last return value of *_input(Name:);CtlType: meaning 'all job for this pkt is done'.  }
+        IPPROTO_DONE            = 257;
+
+
+{
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+}
+        IP_OPTIONS              = 1;    { buf/ip_opts; set/get IP options }
+        IP_HDRINCL              = 2;    { int; header is included with data }
+        IP_TOS                  = 3;    { int; IP type of service and preced. }
+        IP_TTL                  = 4;    { int; IP time to live }
+        IP_RECVOPTS             = 5;    { bool; receive all IP opts w/dgram }
+        IP_RECVRETOPTS          = 6;    { bool; receive IP opts for response }
+        IP_RECVDSTADDR          = 7;    { bool; receive IP dst addr w/dgram }
+        IP_RETOPTS              = 8;    { ip_opts; set/get IP options }
+        IP_MULTICAST_IF         = 9;    { u_char; set/get IP multicast i/f  }
+        IP_MULTICAST_TTL        = 10;   { u_char; set/get IP multicast ttl }
+        IP_MULTICAST_LOOP       = 11;   { u_char; set/get IP multicast loopback }
+        IP_ADD_MEMBERSHIP       = 12;   { ip_mreq; add an IP group membership }
+        IP_DROP_MEMBERSHIP      = 13;   { ip_mreq; drop an IP group membership }
+        IP_MULTICAST_VIF        = 14;   { set/get IP mcast virt. iface }
+        IP_RSVP_ON              = 15;   { enable RSVP in kernel }
+        IP_RSVP_OFF             = 16;   { disable RSVP in kernel }
+        IP_RSVP_VIF_ON          = 17;   { set RSVP per-vif socket }
+        IP_RSVP_VIF_OFF         = 18;   { unset RSVP per-vif socket }
+        IP_PORTRANGE            = 19;   { int; range to choose for unspec port }
+        IP_RECVIF               = 20;   { bool; receive reception if w/dgram }
+{ for IPSEC }
+        IP_IPSEC_POLICY         = 21;   { int; set/get security policy }
+        IP_FAITH                = 22;   { bool; accept FAITH'ed connections }
+
+        IP_FW_ADD               = 50;   { add a firewall rule to chain }
+        IP_FW_DEL               = 51;   { delete a firewall rule from chain }
+        IP_FW_FLUSH             = 52;   { flush firewall rule chain }
+        IP_FW_ZERO              = 53;   { clear single/all firewall counter(Name:s) }
+        IP_FW_GET               = 54;   { get entire firewall rule chain }
+        IP_FW_RESETLOG          = 55;   { reset logging counters }
+
+        IP_DUMMYNET_CONFIGURE   = 60;   { add/configure a dummynet pipe }
+        IP_DUMMYNET_DEL         = 61;   { delete a dummynet pipe from chain }
+        IP_DUMMYNET_FLUSH       = 62;   { flush dummynet }
+        IP_DUMMYNET_GET         = 64;   { get entire dummynet pipes }
+
+        IP_RECVTTL              = 65;   { bool; receive IP TTL }
+        IP_MINTTL               = 66;   { minimum TTL for packet or drop }
+
+{
+ * Defaults and limits for options
+}
+        IP_DEFAULT_MULTICAST_TTL  = 1;  { normally limit m'casts to 1 hop  }
+        IP_DEFAULT_MULTICAST_LOOP = 1;  { normally hear sends if a member  }
+        IP_MAX_MEMBERSHIPS        = 20; { per socket }
+
+{
+ * Argument for IP_PORTRANGE:
+ * - which range to search when port is unspecified at bind(Name:) or connect()
+}
+        IP_PORTRANGE_DEFAULT    = 0;    { default range }
+        IP_PORTRANGE_HIGH       = 1;    { 'high' - request firewall bypass }
+        IP_PORTRANGE_LOW        = 2;    { 'low' - vouchsafe security }
+
+{
+ * Definitions for inet sysctl operations.
+ *
+ * Third level is protocol number.
+ * Fourth level is desired variable within that protocol.
+}
+        IPPROTO_MAXID = (IPPROTO_AH + 1);       { don't list to IPPROTO_MAX }
+
+        CTL_IPPROTO_NAMES  : Array[0..51] OF CtlNameRec =  (
+        (Name: 'ip';CtlType: CTLTYPE_NODE ),
+        (Name: 'icmp';CtlType: CTLTYPE_NODE ),
+        (Name: 'igmp';CtlType: CTLTYPE_NODE ),
+        (Name: 'ggp';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'tcp';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'egp';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'pup';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'udp';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'idp';CtlType: CTLTYPE_NODE ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'ipsec';CtlType: CTLTYPE_NODE ));
+
+{
+ * Names for IP sysctl objects
+}
+        IPCTL_FORWARDING        = 1;    { act as router }
+        IPCTL_SENDREDIRECTS     = 2;    { may send redirects when forwarding }
+        IPCTL_DEFTTL            = 3;    { default TTL }
+{$ifdef notyettunable}
+        IPCTL_DEFMTU            = 4;    { default MTU }
+{$endif}
+        IPCTL_RTEXPIRE          = 5;    { cloned route expiration time }
+        IPCTL_RTMINEXPIRE       = 6;    { min value for expiration time }
+        IPCTL_RTMAXCACHE        = 7;    { trigger level for dynamic expire }
+        IPCTL_SOURCEROUTE       = 8;    { may perform source routes }
+        IPCTL_DIRECTEDBROADCAST = 9;    { may re-broadcast received packets }
+        IPCTL_INTRQMAXLEN       = 10;   { max length of netisr queue }
+        IPCTL_INTRQDROPS        = 11;   { number of netisr q drops }
+        IPCTL_STATS             = 12;   { ipstat structure }
+        IPCTL_ACCEPTSOURCEROUTE = 13;   { may accept source routed packets }
+        IPCTL_FASTFORWARDING    = 14;   { use fast IP forwarding code }
+        IPCTL_KEEPFAITH         = 15;   { FAITH IPv4->IPv6 translater ctl }
+        IPCTL_GIF_TTL           = 16;   { default TTL for gif encap packet }
+        IPCTL_MAXID             = 17;
+
+        IPCTL_NAMES  : Array[0..14] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'forwarding';CtlType: CTLTYPE_INT ),
+        (Name: 'redirect';CtlType: CTLTYPE_INT ),
+        (Name: 'ttl';CtlType: CTLTYPE_INT ),
+        (Name: 'mtu';CtlType: CTLTYPE_INT ),
+        (Name: 'rtexpire';CtlType: CTLTYPE_INT ),
+        (Name: 'rtminexpire';CtlType: CTLTYPE_INT ),
+        (Name: 'rtmaxcache';CtlType: CTLTYPE_INT ),
+        (Name: 'sourceroute';CtlType: CTLTYPE_INT ),
+        (Name: 'directed-broadcast';CtlType: CTLTYPE_INT ),
+        (Name: 'intr-queue-maxlen';CtlType: CTLTYPE_INT ),
+        (Name: 'intr-queue-drops';CtlType: CTLTYPE_INT ),
+        (Name: 'stats';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'accept_sourceroute';CtlType: CTLTYPE_INT ),
+        (Name: 'fastforwarding';CtlType: CTLTYPE_INT ));
+
+{
+ * Names for ICMP sysctl objects
+}
+        ICMPCTL_MASKREPL        = 1;    { allow replies to netmask requests }
+        ICMPCTL_STATS           = 2;    { statistics (Name:read-only) }
+        ICMPCTL_ICMPLIM         = 3;
+        ICMPCTL_MAXID           = 4;
+
+        ICMPCTL_NAMES  : Array[0..3] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'maskrepl';CtlType: CTLTYPE_INT ),
+        (Name: 'stats';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'icmplim';CtlType: CTLTYPE_INT ));
+
+{
+ * Names for ICMP sysctl objects
+}
+        ICMPV6CTL_STATS         = 1;
+        ICMPV6CTL_REDIRACCEPT   = 2;    { accept/process redirects }
+        ICMPV6CTL_REDIRTIMEOUT  = 3;    { redirect cache time }
+{$ifdef obsolete}       {obsoleted}
+        ICMPV6CTL_ERRRATELIMIT  = 5;    { ICMPv6 error rate limitation }
+{$endif}
+        ICMPV6CTL_ND6_PRUNE     = 6;
+        ICMPV6CTL_ND6_DELAY     = 8;
+        ICMPV6CTL_ND6_UMAXTRIES = 9;
+        ICMPV6CTL_ND6_MMAXTRIES         = 10;
+        ICMPV6CTL_ND6_USELOOPBACK       = 11;
+//define ICMPV6CTL_ND6_PROXYALL = 12;   obsoleted, do not reuse here
+        ICMPV6CTL_NODEINFO      = 13;
+        ICMPV6CTL_ERRPPSLIMIT   = 14;   { ICMPv6 error pps limitation }
+        ICMPV6CTL_ND6_MAXNUDHINT= 15;
+        ICMPV6CTL_MTUDISC_HIWAT = 16;
+        ICMPV6CTL_MTUDISC_LOWAT = 17;
+        ICMPV6CTL_ND6_DEBUG     = 18;
+        ICMPV6CTL_ND6_DRLIST    = 19;
+        ICMPV6CTL_ND6_PRLIST    = 20;
+        ICMPV6CTL_MAXID         = 21;
+
+        ICMPV6CTL_NAMES  : Array[0..20] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'rediraccept';CtlType: CTLTYPE_INT ),
+        (Name: 'redirtimeout';CtlType: CTLTYPE_INT ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'nd6_prune';CtlType: CTLTYPE_INT ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'nd6_delay';CtlType: CTLTYPE_INT ),
+        (Name: 'nd6_umaxtries';CtlType: CTLTYPE_INT ),
+        (Name: 'nd6_mmaxtries';CtlType: CTLTYPE_INT ),
+        (Name: 'nd6_useloopback';CtlType: CTLTYPE_INT ),
+        (Name: '';CtlType: 0 ),
+        (Name: 'nodeinfo';CtlType: CTLTYPE_INT ),
+        (Name: 'errppslimit';CtlType: CTLTYPE_INT ),
+        (Name: 'nd6_maxnudhint';CtlType: CTLTYPE_INT ),
+        (Name: 'mtudisc_hiwat';CtlType: CTLTYPE_INT ),
+        (Name: 'mtudisc_lowat';CtlType: CTLTYPE_INT ),
+        (Name: 'nd6_debug';CtlType: CTLTYPE_INT ),
+        (Name: '';CtlType: 0 ),
+        (Name: '';CtlType: 0 ));
+
+
+{
+ * Names for UDP sysctl objects
+}
+        UDPCTL_CHECKSUM         = 1;    { checksum UDP packets }
+        UDPCTL_STATS            = 2;    { statistics (Name:read-only) }
+        UDPCTL_MAXDGRAM         = 3;    { max datagram size }
+        UDPCTL_RECVSPACE        = 4;    { default receive buffer space }
+        UDPCTL_PCBLIST          = 5;    { list of PCBs for UDP sockets }
+        UDPCTL_MAXID            = 6;
+
+        UDPCTL_NAMES  : Array[0..5] OF CtlNameRec =  (
+        (Name: '';CtlType: 0 ),
+        (Name: 'checksum';CtlType: CTLTYPE_INT ),
+        (Name: 'stats';CtlType: CTLTYPE_STRUCT ),
+        (Name: 'maxdgram';CtlType: CTLTYPE_INT ),
+        (Name: 'recvspace';CtlType: CTLTYPE_INT ),
+        (Name: 'pcblist';CtlType: CTLTYPE_STRUCT ));
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/sysnr.inc rtl/dragonfly/sysnr.inc
--- rtl/dragonfly.null/sysnr.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/sysnr.inc	2014-11-19 01:13:55.000000000 +0100
@@ -0,0 +1,343 @@
+{
+    This file is part of the Free Pascal run time library.
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+const
+ syscall_nr_exit                        =   1;
+ syscall_nr_fork                        =   2;
+ syscall_nr_read                        =   3;
+ syscall_nr_write                       =   4;
+ syscall_nr_open                        =   5;
+ syscall_nr_close                       =   6;
+ syscall_nr_waitpid                     =   7;
+                                        {   8  is old creat }
+ syscall_nr_link                        =   9;
+ syscall_nr_unlink                      =  10;
+                                        {  11  obsolete execv }
+ syscall_nr_chdir                       =  12;
+ syscall_nr_fchdir                      =  13;
+ syscall_nr_mknod                       =  14;
+ syscall_nr_chmod                       =  15;
+ syscall_nr_chown                       =  16;
+ syscall_nr_break                       =  17;
+ syscall_nr_getfsstat                   =  18;  
+                                        {  19  is old lseek }
+ syscall_nr_getpid                      =  20;
+ syscall_nr_mount                       =  21;
+ syscall_nr_umount                      =  22;
+ syscall_nr_setuid                      =  23;
+ syscall_nr_getuid                      =  24;
+ syscall_nr_geteuid                     =  25;
+ syscall_nr_ptrace                      =  26;
+ syscall_nr_recvmsg                     =  27;
+ syscall_nr_sendmsg                     =  28;
+ syscall_nr_recvfrom                    =  29;
+ syscall_nr_accept                      =  30;
+ syscall_nr_getpeername                 =  31;
+ syscall_nr_getsockname                 =  32;
+ syscall_nr_access                      =  33;
+ syscall_nr_chflags                     =  34;
+ syscall_nr_fchflags                    =  35;
+ syscall_nr_sync                        =  36;
+ syscall_nr_kill                        =  37;
+                                        {  38  is old stat }
+ syscall_nr_getppid                     =  39;
+                                        {  40  is old lstat }
+ syscall_nr_dup                         =  41;
+ syscall_nr_pipe                        =  42;
+ syscall_nr_getegid                     =  43;
+ syscall_nr_profil                      =  44;
+ syscall_nr_ktrace                      =  45;
+                                        {  46  is obsolete fbsd3_sigaction }
+ syscall_nr_getgid                      =  47;
+                                        {  48  is obsolete fbsd3_sigprocmask }
+ syscall_nr_getlogin                    =  49;
+ syscall_nr_setlogin                    =  50;
+ syscall_nr_acct                        =  51;
+                                        {  52  is obsolete fbsd3_sigpending }
+ syscall_nr_sigaltstack                 =  53;
+ syscall_nr_ioctl                       =  54;
+ syscall_nr_reboot                      =  55;
+ syscall_nr_revoke                      =  56;
+ syscall_nr_symlink                     =  57;
+ syscall_nr_readlink                    =  58;
+ syscall_nr_execve                      =  59;
+ syscall_nr_umask                       =  60;
+ syscall_nr_chroot                      =  61;
+                                        {  62  is old fstat }
+                                        {  63  is old getkerninfo }
+                                        {  64  is old getpagesize }
+ syscall_nr_msync                       =  65;
+ syscall_nr_vfork                       =  66;
+                                        {  67  is obsolete vread }
+                                        {  68  is obsolete vwrite }
+ syscall_nr_sbrk                        =  69;
+ syscall_nr_sstk                        =  70;
+                                        {  71  is old map }
+                                        {  72  is old vadvise }
+ syscall_nr_munmap                      =  73;
+ syscall_nr_mprotect                    =  74;
+ syscall_nr_madvise                     =  75;
+                                        {  76  is obsolete vhangup }
+                                        {  77  is obsolete vlimit }
+ syscall_nr_mincore                     =  78;
+ syscall_nr_getgroups                   =  79;
+ syscall_nr_setgroups                   =  80;
+ syscall_nr_getpgrp                     =  81;
+ syscall_nr_setpgid                     =  82;
+ syscall_nr_setitimer                   =  83;
+                                        {  84  is old wait }
+ syscall_nr_swapon                      =  85;
+ syscall_nr_getitimer                   =  86;
+                                        {  87  is old gethostname }
+                                        {  88  is old sethostname }
+ syscall_nr_getdtablesize               =  89;
+ syscall_nr_dup2                        =  90;
+                                        {  91  empty }
+ syscall_nr_fcntl                       =  92;
+ syscall_nr_select                      =  93;
+                                        {  94  empty }
+ syscall_nr_fsync                       =  95;
+ syscall_nr_setpriority                 =  96;
+ syscall_nr_socket                      =  97;
+ syscall_nr_connect                     =  98;
+                                        {  99  is old accept }
+ syscall_nr_getpriority                 = 100;
+                                        { 101  is old send }
+                                        { 102  is old recv }
+                                        { 103  is obsolete fbsd3_sigreturn }
+ syscall_nr_bind                        = 104;
+ syscall_nr_setsockopt                  = 105;
+ syscall_nr_listen                      = 106;
+                                        { 107  is obsolete vtimes }
+                                        { 108  is old sigvec }
+                                        { 109  is old sigblock }
+                                        { 110  is old sigsetmask }
+                                        { 111  is old fbsd3_sigsuspend }
+                                        { 112  is old sigstack }
+                                        { 113  is old recvmsg }
+                                        { 114  is old sendmsg }
+                                        { 115  is obsolete vtract }
+ syscall_nr_gettimeofday                = 116;
+ syscall_nr_getrusage                   = 117;
+ syscall_nr_getsockopt                  = 118;
+                                        { 119  empty }
+ syscall_nr_readv                       = 120;
+ syscall_nr_writev                      = 121;
+ syscall_nr_settimeofday                = 122;
+ syscall_nr_fchown                      = 123;
+ syscall_nr_fchmod                      = 124;
+                                        { 125  is old recfrom }
+ syscall_nr_setreuid                    = 126;
+ syscall_nr_setregid                    = 127;
+ syscall_nr_rename                      = 128;
+                                        { 129  is old truncate }
+                                        { 130  is old ftruncate }
+ syscall_nr_flock                       = 131;
+ syscall_nr_mkfifo                      = 132;
+ syscall_nr_sendto                      = 133;
+ syscall_nr_shutdown                    = 134;
+ syscall_nr_socketpair                  = 135;
+ syscall_nr_mkdir                       = 136;
+ syscall_nr_rmdir                       = 137;
+ syscall_nr_utimes                      = 138;
+                                        { 139  is obsolete 4.2 sigreturn }
+ syscall_nr_adjtime                     = 140;
+                                        { 141  is old getpeername }
+                                        { 142  is old gethostid }
+                                        { 143  is old sethostid }
+                                        { 144  is old getrlimit }
+                                        { 145  is old setrlimit }
+                                        { 146  is old killpg }
+ syscall_nr_setsid                      = 147;
+ syscall_nr_quotactl                    = 148;
+                                        { 149  is old quota }
+                                        { 150  is old getsockname }
+                                        { 151  -- 154 empty }
+ syscall_nr_nfssvc                      = 155;
+                                        { 156  is old getdirentries }
+ syscall_nr_statfs                      = 157;
+ syscall_nr_fstatfs                     = 158;
+                                        { 159  empty }
+                                        { 160  empty }
+ syscall_nr_getfh                       = 161;
+ syscall_nr_getdomainname               = 162;
+ syscall_nr_setdomainname               = 163;
+ syscall_nr_uname                       = 164;
+ syscall_nr_sysarch                     = 165;
+                                        { 166  --- 168 empty }
+                                        { 169  is old semsys }
+                                        { 170  is old msgsys }
+                                        { 171  is old shmsys }
+                                        { 172  empty }
+ syscall_nr_pread                       = 173; { extpread }
+ syscall_nr_pwrite                      = 174; { extpwrite }
+                                        { 175  empty }
+ syscall_nr_ntp_adjtime                 = 176;
+                                        { 180  empty }
+ syscall_nr_setgid                      = 181;
+ syscall_nr_setegid                     = 182;
+ syscall_nr_seteuid                     = 183;
+                                        { 184  --- 187 empty }
+                                        { 188  is old stat }
+                                        { 189  is old fstat }
+                                        { 190  is old lstat }
+ syscall_nr_pathconf                    = 191;
+ syscall_nr_fpathconf                   = 192;
+                                        { 193  empty }
+ syscall_nr_getrlimit                   = 194;
+ syscall_nr_setrlimit                   = 195;
+                                        { 196  is old getdirentries }
+ syscall_nr_mmap                        = 197;
+ syscall_nr___syscall                   = 198;
+ syscall_nr_lseek                       = 199;
+ syscall_nr_truncate                    = 200;
+ syscall_nr_ftruncate                   = 201;
+ syscall_nr___sysctl                    = 202;
+ syscall_nr_mlock                       = 203;
+ syscall_nr_munlock                     = 204;
+ syscall_nr_undelete                    = 205;
+ syscall_nr_futimes                     = 206;
+ syscall_nr_getpgid                     = 207;
+                                        { 208  empty }
+ syscall_nr_poll                        = 209;
+                                        { 210  ---  219 empty }
+ syscall_nr___semctl                    = 220;
+ syscall_nr_semget                      = 221;
+ syscall_nr_semop                       = 222;
+                                        { 223  empty }
+ syscall_nr_msgctl                      = 224;
+ syscall_nr_msgget                      = 225;
+ syscall_nr_msgsnd                      = 226;
+ syscall_nr_msgrcv                      = 227;
+ syscall_nr_shmat                       = 228;
+ syscall_nr_shmctl                      = 229;
+ syscall_nr_shmdt                       = 230;
+ syscall_nr_shmget                      = 231;
+ syscall_nr_clock_gettime               = 232;
+ syscall_nr_clock_settime               = 233;
+ syscall_nr_clock_getres                = 234;
+                                        { 235  ---  239 empty }
+ syscall_nr_nanosleep                   = 240;
+                                        { 241  ---  249 empty }
+ syscall_nr_minherit                    = 250;
+ syscall_nr_rfork                       = 251;
+ syscall_nr_openbsd_poll                = 252;
+ syscall_nr_issetugid                   = 253;
+ syscall_nr_lchown                      = 254;
+                                        { 255  ---  271 empty }
+                                        { 272  is old getdents }
+                                        { 273  empty }
+ syscall_nr_lchmod                      = 274;
+ syscall_nr_netbsd_lchown               = 275;
+ syscall_nr_lutimes                     = 276;
+ syscall_nr_netbsd_msync                = 277;
+                                        { 278  ---  288 empty }
+ syscall_nr_extpreadv                   = 289;
+ syscall_nr_extwritev                   = 290;
+                                        { 291  ---  296 empty }
+ syscall_nr_fhstatfs                    = 297;
+ syscall_nr_fhopen                      = 298;
+                                        { 299  is old fhstat }
+ syscall_nr_modnext                     = 300;
+ syscall_nr_modstat                     = 301;
+ syscall_nr_modfnext                    = 302;
+ syscall_nr_modofind                    = 303;
+ syscall_nr_kldload                     = 304;
+ syscall_nr_kldunload                   = 305;
+ syscall_nr_kldfind                     = 306;
+ syscall_nr_kldnext                     = 307;
+ syscall_nr_kldstat                     = 308;
+ syscall_nr_kldfirstmod                 = 309;
+ syscall_nr_getsid			= 310;
+ syscall_nr_setresuid                   = 311;
+ syscall_nr_setresgid                   = 312;
+                                        { 313  is obsolete signanosleep }
+                                        { 314  --  320  aio/lio syscalls }
+ syscall_nr_yield                       = 321;
+                                        { 322  -- 323 empty }
+ syscall_nr_mlockall                    = 324;
+ syscall_nr_munlockall                  = 325;
+ syscall_nr___getcwd                    = 326;
+                                        { 327  -- 334 scheduler syscalls }
+ syscall_nr_utrace                      = 335;
+                                        { 336  is obsolete fbsd4_sendfile }
+ syscall_nr_kldsym                      = 337;
+ syscall_nr_jail                        = 338;
+                                        { 339  empty }
+ syscall_nr_sigprocmask                 = 340;
+ syscall_nr_sigsuspend                  = 341;
+ syscall_nr_sigaction                   = 342;
+ syscall_nr_sigpending                  = 343;
+ syscall_nr_sigreturn                   = 344;
+ syscall_nr_sigtimedwait                = 345;
+ syscall_nr_sigwaitinfo                 = 346;
+                                        { 347  ---  354 acl syscalls }
+                                        { 355  ---  358 extattr syscalls }
+ syscall_nr_aio_waitcomplete            = 359;
+ syscall_nr_getresuid                   = 360;
+ syscall_nr_getresgid                   = 361;
+ syscall_nr_kqueue 			= 362;
+ syscall_nr_kevent 			= 363;
+ syscall_nr_sctp_peeloff                = 364;
+                                        { 365  ---  390 empty }
+ syscall_lchflags                       = 391;
+ syscall_nr_uuidgen			= 392;
+ syscall_nr_sendfile 			= 393;
+                                        { 394  ---  449 empty }
+                                        { 450  ---  452 varsym syscalls }
+                                        { 453  ---  464 obsolete caps }
+ syscall_nr_exec_sys_register           = 465;
+ syscall_nr_exec_sys_unregister         = 466;
+ syscall_nr_sys_checkpoint              = 467;
+ syscall_nr_mountctl                    = 468;
+ syscall_nr_umtx_sleep                  = 469;
+ syscall_nr_umtx_wakeup                 = 470;
+ syscall_nr_jail_attach                 = 471;
+ syscall_nr_set_tls_area                = 472;
+ syscall_nr_get_tls_area                = 473;
+ syscall_nr_closefrom                   = 474;
+ syscall_nr_stat                        = 475;
+ syscall_nr_fstat                       = 476;
+ syscall_nr_lstat                       = 477;
+ syscall_nr_fhstat                      = 478;
+ syscall_nr_getdirentries               = 479;
+ syscall_nr_getdents                    = 480;
+ syscall_nr_usched_set                  = 481;
+ syscall_nr_extaccept                   = 482;
+ syscall_nr_extconnect                  = 483;
+                                        { 484  is obsolete syslink }
+                                        { 485  ---  498 vmspace/lwp syscalls }
+ syscall_nr_pselect                     = 499;
+ syscall_nr_statvfs                     = 500;
+ syscall_nr_fstatvfs                    = 501;
+ syscall_nr_fhstatvfs                   = 502;
+ syscall_nr_getvfsstat                  = 503;
+ syscall_nr_openat                      = 504;
+ syscall_nr_fstatat                     = 505;
+ syscall_nr_fchmodat                    = 506;
+ syscall_nr_fchownat                    = 507;
+ syscall_nr_unlinkat                    = 508;
+ syscall_nr_faccessat                   = 509;
+                                        { 510  ---  521 mq/ioprio syscalls }
+ syscall_nr_chroot_kernel               = 522;
+ syscall_nr_renameat                    = 523;
+ syscall_nr_mkdirat                     = 524;
+ syscall_nr_mkfifoat                    = 525;
+ syscall_nr_mknodat                     = 526;
+ syscall_nr_readlinkat                  = 527;
+ syscall_nr_symlinkat                   = 528;
+ syscall_nr_swapoff                     = 529;
+ syscall_nr_vquotactl                   = 530;
+ syscall_nr_linkat                      = 531;
+ syscall_nr_eaccess                     = 532;
+ syscall_nr_lpathconf                   = 533;
diff -ur --unidirectional-new-file rtl/dragonfly.null/termio.pp rtl/dragonfly/termio.pp
--- rtl/dragonfly.null/termio.pp	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/termio.pp	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,41 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Peter Vreman
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This file contains the termios interface.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+unit termio;
+
+interface
+{$inline on}
+Uses BaseUnix;          // load base unix typing
+
+// load types + consts
+
+{$i termios.inc}
+
+// load default prototypes from unix dir.
+
+{$i termiosh.inc}
+
+implementation
+
+{$i textrec.inc}
+
+// load implementation for prototypes from current dir.
+{$i termiosproc.inc}
+
+// load ttyname from unix dir.
+{$i ttyname.inc}
+
+end.
diff -ur --unidirectional-new-file rtl/dragonfly.null/termios.inc rtl/dragonfly/termios.inc
--- rtl/dragonfly.null/termios.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/termios.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,375 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   Termios header for FreeBSD
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+CONST
+
+{
+ * Special Control Characters
+ *
+ * Index into c_cc[] character array.
+ *
+ *      Name         Subscript  Enabled by
+ }
+ VEOF           =0;
+ VEOL           =1;
+ VEOL2          =2;
+ VERASE         =3;
+ VWERASE        =4;
+ VKILL          =5;
+ VREPRINT       =6;
+{               =7;        spare 1 }
+ VINTR          =8;
+ VQUIT          =9;
+ VSUSP          =10;
+ VDSUSP         =11;
+ VSTART         =12;
+ VSTOP          =13;
+ VLNEXT         =14;
+ VDISCARD       =15;
+ VMIN           =16;
+ VTIME          =17;
+ VSTATUS        =18;
+{               =19        spare 2 }
+ NCCS           =20;
+
+Type
+  winsize = packed record
+    ws_row,
+    ws_col,
+    ws_xpixel,
+    ws_ypixel : word;
+  end;
+  TWinSize=winsize;
+
+
+type
+  Termios = packed record
+    c_iflag,
+    c_oflag,
+    c_cflag,
+    c_lflag  : longint;
+//    c_line   : char;
+    c_cc     : array[0..NCCS-1] of byte;
+   {$IFDEF BSD}
+    c_ispeed,
+    c_ospeed : longint;
+   {$endif}
+  end;
+  TTermios=Termios;
+
+CONST
+
+
+ POSIX_VDISABLE=Chr($ff);
+{
+
+#define CCEQ(val, c)    ((c) == (val) ? (val) != _POSIX_VDISABLE : 0)
+}
+
+{ * Input flags - software input processing}
+
+        IGNBRK          =       $1;     { ignore BREAK condition }
+        BRKINT          =       $2;     { map BREAK to SIGINTR }
+        IGNPAR          =       $4;     { ignore (discard) parity errors }
+        PARMRK          =       $8;     { mark parity and framing errors }
+        INPCK           =      $10;     { enable checking of parity errors }
+        ISTRIP          =      $20;     { strip 8th bit off chars }
+        INLCR           =      $40;     { map NL into CR }
+        IGNCR           =      $80;     { ignore CR }
+        ICRNL           =     $100;     { map CR to NL (ala CRMOD) }
+        IXON            =     $200;     { enable output flow control }
+        IXOFF           =     $400;     { enable input flow control }
+        IXANY           =     $800;     { any char will restart after stop }
+        IMAXBEL         =    $2000;     { ring bell on input queue full }
+
+{
+ * Output flags - software output processing
+}
+        OPOST           =       $1;     { enable following output processing }
+        ONLCR           =       $2;     { map NL to CR-NL (ala CRMOD) }
+        OXTABS          =       $4;     { expand tabs to spaces }
+        ONOEOT          =       $8;     { discard EOT's (^D) on output) }
+
+{
+ * Control flags - hardware control of terminal
+}
+        CIGNORE         =       $1;     { ignore control flags }
+        CSIZE           =     $300;     { character size mask }
+        CS5             =       $0;         { 5 bits (pseudo) }
+        CS6             =     $100;         { 6 bits }
+        CS7             =     $200;         { 7 bits }
+        CS8             =     $300;         { 8 bits }
+        CSTOPB          =     $400;     { send 2 stop bits }
+        CREAD           =     $800;     { enable receiver }
+        PARENB          =    $1000;     { parity enable }
+        PARODD          =    $2000;     { odd parity, else even }
+        HUPCL           =    $4000;     { hang up on last close }
+        CLOCAL          =    $8000;     { ignore modem status lines }
+        CCTS_OFLOW      =   $10000;     { CTS flow control of output }
+        CRTS_IFLOW      =   $20000;     { RTS flow control of input }
+        CRTSCTS         =   (CCTS_OFLOW or CRTS_IFLOW);
+        CDTR_IFLOW      =   $40000;     { DTR flow control of input }
+        CDSR_OFLOW      =   $80000;     { DSR flow control of output }
+        CCAR_OFLOW      =  $100000;     { DCD flow control of output }
+        MDMBUF          =  $100000;     { old name for CCAR_OFLOW }
+
+{
+ * "Local" flags - dumping ground for other state
+ *
+ * Warning: some flags in this structure begin with
+ * the letter "I" and look like they belong in the
+ * input flag.
+ }
+
+        ECHOKE          =       $1;     { visual erase for line kill }
+        ECHOE           =       $2;     { visually erase chars }
+        ECHOK           =       $4;     { echo NL after line kill }
+        ECHO            =       $8;     { enable echoing }
+        ECHONL          =      $10;     { echo NL even if ECHO is off }
+        ECHOPRT         =      $20;     { visual erase mode for hardcopy }
+        ECHOCTL         =      $40;     { echo control chars as ^(Char) }
+        ISIG            =      $80;     { enable signals INTR, QUIT, [D]SUSP }
+        ICANON          =     $100;     { canonicalize input lines }
+        ALTWERASE       =     $200;     { use alternate WERASE algorithm }
+        IEXTEN          =     $400;     { enable DISCARD and LNEXT }
+        EXTPROC         =     $800;      { external processing }
+        TOSTOP          =  $400000;     { stop background jobs from output }
+        FLUSHO          =  $800000;     { output being flushed (state) }
+        NOKERNINFO      = $2000000;     { no kernel output from VSTATUS }
+        PENDIN          =$20000000;     { XXX retype pending input (state) }
+        NOFLSH          =$80000000;     { don't flush after interrupt }
+
+
+
+{
+ * Commands passed to tcsetattr() for setting the termios structure.
+}
+
+CONST
+
+        TCSANOW         =0;             { make change immediate }
+        TCSADRAIN       =1;             { drain output, then change }
+        TCSAFLUSH       =2;             { drain output, flush input }
+        TCSASOFT        =$10;           { flag - don't alter h.w. state }
+
+{
+ * Standard speeds
+}
+        B0      =     0;
+        B50     =    50;
+        B75     =    75;
+        B110    =   110;
+        B134    =   134;
+        B150    =   150;
+        B200    =   200;
+        B300    =   300;
+        B600    =   600;
+        B1200   =  1200;
+        B1800   =  1800;
+        B2400   =  2400;
+        B4800   =  4800;
+        B9600   =  9600;
+        B19200  = 19200;
+        B38400  = 38400;
+        B7200   =  7200;
+        B14400  = 14400;
+        B28800  = 28800;
+        B57600  = 57600;
+        B76800  = 76800;
+        B115200 =115200;
+        B230400 =230400;
+        B460800 =460800;
+        B921600 =921600;
+        EXTA    = 19200;
+        EXTB    = 38400;
+
+        TCIFLUSH        =1;
+        TCOFLUSH        =2;
+        TCIOFLUSH       =3;
+        TCOOFF          =1;
+        TCOON           =2;
+        TCIOFF          =3;
+        TCION           =4;
+
+{
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+speed_t cfgetispeed __P((const struct termios *));
+speed_t cfgetospeed __P((const struct termios *));
+int     cfsetispeed __P((struct termios *, speed_t));
+int     cfsetospeed __P((struct termios *, speed_t));
+int     tcgetattr __P((int, struct termios *));
+int     tcsetattr __P((int, int, const struct termios *));
+int     tcdrain __P((int));
+int     tcflow __P((int, int));
+int     tcflush __P((int, int));
+int     tcsendbreak __P((int, int));
+
+#ifndef _POSIX_SOURCE
+void    cfmakeraw __P((struct termios *));
+int     cfsetspeed __P((struct termios *, speed_t));
+#endif { !_POSIX_SOURCE }
+__END_DECLS
+
+#endif { !_KERNEL }
+
+
+
+struct winsize {
+        unsigned short  ws_row;         { rows, in characters }
+        unsigned short  ws_col;         { columns, in characters }
+        unsigned short  ws_xpixel;      { horizontal size, pixels }
+        unsigned short  ws_ypixel;      { vertical size, pixels }
+};
+
+}
+       IOCTLREAD        = $40000000;
+       IOCTLWRITE       = $80000000;
+       IOCTLVOID        = $20000000;
+
+        TIOCMODG        = IOCTLREAD+$47400+ 3;  { get modem control state }
+        TIOCMODS        = IOCTLWRITE+$47400+ 4; { set modem control state }
+                TIOCM_LE        =$0001;         { line enable }
+                TIOCM_DTR       =$0002;         { data terminal ready }
+                TIOCM_RTS       =$0004;         { request to send }
+                TIOCM_ST        =$0010;         { secondary transmit }
+                TIOCM_SR        =$0020;         { secondary receive }
+                TIOCM_CTS       =$0040;         { clear to send }
+                TIOCM_CAR       =$0100;         { carrier detect }
+                TIOCM_CD        =TIOCM_CAR;
+                TIOCM_RNG       =$0200;         { ring }
+                TIOCM_RI        =TIOCM_RNG;
+                TIOCM_DSR       =$0400;         { data set ready }
+                                                { 8-10 compat }
+        TIOCEXCL         =IOCTLVOID+$7400+ 13;          { set exclusive use of tty }
+        TIOCNXCL         =IOCTLVOID+$7400+ 14;          { reset exclusive use of tty }
+                                                { 15 unused }
+        TIOCFLUSH        =IOCTLWRITE+$47400+ 16;        { flush buffers }
+                                                { 17-18 compat }
+        TIOCGETA         =IOCTLREAD+$2C7400+ 19; { get termios struct }
+        TIOCSETA         =IOCTLWRITE+$2C7400+ 20; { set termios struct }
+        TIOCSETAW        =IOCTLWRITE+$2C7400+ 21; { drain output, set }
+        TIOCSETAF        =IOCTLWRITE+$2C7400+ 22; { drn out, fls in, set }
+        TIOCGETD         =IOCTLREAD+$47400+ 26; { get line discipline }
+        TIOCSETD         =IOCTLWRITE+$47400+ 27;        { set line discipline }
+                                                { 127-124 compat }
+        TIOCSBRK         =IOCTLVOID+$7400+ 123;         { set break bit }
+        TIOCCBRK         =IOCTLVOID+$7400+ 122;         { clear break bit }
+        TIOCSDTR         =IOCTLVOID+$7400+ 121;         { set data terminal ready }
+        TIOCCDTR         =IOCTLVOID+$7400+ 120;         { clear data terminal ready }
+        TIOCGPGRP        =IOCTLREAD+$47400+ 119;        { get pgrp of tty }
+        TIOCSPGRP        =IOCTLWRITE+$47400+ 118;       { set pgrp of tty }
+                                                { 117-116 compat }
+        TIOCOUTQ         =IOCTLREAD+$47400+ 115;        { output queue size }
+        TIOCSTI          =IOCTLWRITE+$17400+ 114;       { simulate terminal input }
+        TIOCNOTTY        =IOCTLVOID+$7400+ 113;         { void tty association }
+        TIOCPKT          =IOCTLWRITE+$47400+ 112;       { pty: set/clear packet mode }
+                TIOCPKT_DATA            =$00;   { data packet }
+                TIOCPKT_FLUSHREAD       =$01;   { flush packet }
+                TIOCPKT_FLUSHWRITE      =$02;   { flush packet }
+                TIOCPKT_STOP            =$04;   { stop output }
+                TIOCPKT_START           =$08;   { start output }
+                TIOCPKT_NOSTOP          =$10;   { no more ^S, ^Q }
+                TIOCPKT_DOSTOP          =$20;   { now do ^S ^Q }
+                TIOCPKT_IOCTL           =$40;   { state change of pty driver }
+        TIOCSTOP         =IOCTLVOID+$7400+ 111;         { stop output, like ^S }
+        TIOCSTART        =IOCTLVOID+$7400+ 110;         { start output, like ^Q }
+        TIOCMSET         =IOCTLWRITE+$47400+ 109;       { set all modem bits }
+        TIOCMBIS         =IOCTLWRITE+$47400+ 108;       { bis modem bits }
+        TIOCMBIC         =IOCTLWRITE+$47400+ 107;       { bic modem bits }
+        TIOCMGET         =IOCTLREAD+$47400+ 106;        { get all modem bits }
+        TIOCREMOTE       =IOCTLWRITE+$47400+ 105;       { remote input editing }
+        TIOCGWINSZ       =IOCTLREAD+$87400+ 104;        { get window size }
+        TIOCSWINSZ       =IOCTLWRITE+$87400+ 103;       { set window size }
+        TIOCUCNTL        =IOCTLWRITE+$47400+ 102;       { pty: set/clr usr cntl mode }
+        TIOCSTAT         =IOCTLVOID+$7400+ 101;         { simulate ^T status message }
+  //                       UIOCCMD(n)   _IO('u', n)     { usr cntl op "n" }
+        TIOCCONS         =IOCTLWRITE+$47400+ 98;        { become virtual console }
+        TIOCSCTTY        =IOCTLVOID+$7400+ 97;          { become controlling tty }
+        TIOCEXT          =IOCTLWRITE+$47400+ 96;        { pty: external processing }
+        TIOCSIG          =IOCTLVOID+$7400+ 95;          { pty: generate signal }
+        TIOCDRAIN        =IOCTLVOID+$7400+ 94;          { wait till output drained }
+        TIOCMSDTRWAIT    =IOCTLWRITE+$47400+ 91;        { modem: set wait on close }
+        TIOCMGDTRWAIT    =IOCTLREAD+$47400+ 90; { modem: get wait on close }
+        TIOCTIMESTAMP    =IOCTLREAD+$87400+ 89;         { enable/get timestamp
+                                                 * of last input event }
+        TIOCDCDTIMESTAMP =IOCTLREAD+$87400+ 88; { enable/get timestamp
+                                                 * of last DCd rise }
+        TIOCSDRAINWAIT   =IOCTLWRITE+$47400+ 87;        { set ttywait timeout }
+        TIOCGDRAINWAIT   =IOCTLREAD+$47400+ 86; { get ttywait timeout }
+
+        TTYDISC          = 0;            { termios tty line discipline }
+        SLIPDISC         = 4;            { serial IP discipline }
+        PPPDISC          = 5;            { PPP discipline }
+        NETGRAPHDISC     = 6;            { Netgraph tty node discipline }
+
+	FIOCLEX          = IOCTLVOID +$6600+ 1;        { set close on exec on fd }
+ 	FIONCLEX         = IOCTLVOID +$6600+ 2;        { remove close on exec }
+ 	FIONREAD         = IOCTLREAD +$46600+127;     { get # bytes to read }
+ 	FIONBIO          = IOCTLWRITE+$46600+126;     { set/clear non-blocking i/o }
+ 	FIOASYNC         = IOCTLWRITE+$46600+125;     { set/clear async i/o }
+ 	FIOSETOWN        = IOCTLWRITE+$46600+124;     { set owner }
+ 	FIOGETOWN        = IOCTLREAD +$46600+123;     { get owner }  
+ 	FIODTYPE         = IOCTLREAD +$46600+122;     { get d_flags type part }         
+ 	FIOGETLBA        = IOCTLREAD +$46600+121;     { get start blk # }                 
+
+{
+ * Defaults on "first" open.
+ }
+        TTYDEF_IFLAG     =(BRKINT       or ICRNL        or IMAXBEL or IXON or IXANY);
+       TTYDEF_OFLAG      =(OPOST or ONLCR);
+       TTYDEF_LFLAG      =(ECHO or ICANON or ISIG or IEXTEN or ECHOE or ECHOKE or ECHOCTL);
+        TTYDEF_CFLAG     =(CREAD or CS8 or HUPCL);
+       TTYDEF_SPEED      =(B9600);
+
+
+
+{
+ * Control Character Defaults
+ }
+        CtrlMask        = $1f;  {\037}
+        CEOF            =chr( ORD('d') and CtrlMask);
+        CEOL            =chr( $ff and CtrlMask);{ XXX avoid _POSIX_VDISABLE }
+        CERASE          =chr( $7F and CtrlMask);
+        CINTR           =chr(ORD('c') and CtrlMask);
+        CSTATUS         =chr(ORD('t') and CtrlMask);
+        CKILL           =chr(ORD('u') and CtrlMask);
+        CMIN            =chr(1);
+        CQUIT           =chr(034  and CtrlMask);        { FS, ^\ }
+        CSUSP           =chr(ORD('z') and CtrlMask);
+        CTIME           =chr(0);
+        CDSUSP          =chr(ORD('y') and CtrlMask);
+        CSTART          =chr(ORD('q') and CtrlMask);
+        CSTOP           =chr(ORD('s') and CtrlMask);
+        CLNEXT          =chr(ORD('v') and CtrlMask);
+        CDISCARD        =chr(ORD('o') and CtrlMask);
+        CWERASE         =chr(ORD('w') and CtrlMask);
+        CREPRINT        =chr(ORD('r') and CtrlMask);
+        CEOT            =CEOF;
+{ compat }
+        CBRK            =CEOL;
+        CRPRNT          =CREPRINT;
+        CFLUSH          =CDISCARD;
+
+
+{
+ *        TTYDEFCHARS to include an array of default control characters.
+}
+    ttydefchars : array[0..NCCS-1] OF char =(
+        CEOF,   CEOL,   CEOL,   CERASE, CWERASE, CKILL, CREPRINT,
+        POSIX_VDISABLE, CINTR,  CQUIT,  CSUSP,  CDSUSP, CSTART, CSTOP,  CLNEXT,
+        CDISCARD, CMIN, CTIME,  CSTATUS, POSIX_VDISABLE);
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/termiosproc.inc rtl/dragonfly/termiosproc.inc
--- rtl/dragonfly.null/termiosproc.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/termiosproc.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,181 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   Termios implementation for FreeBSD
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+
+{******************************************************************************
+                         IOCtl and Termios calls
+******************************************************************************}
+
+Function TCGetAttr(fd:cint;var tios:TermIOS):cint; {$ifdef VER2_0}inline;{$endif}
+begin
+  TCGETAttr:=fpIoCtl(Fd,TIOCGETA,@tios);
+end;
+
+
+Function TCSetAttr(fd:cint;OptAct:cint;const tios:TermIOS):cint;
+var
+  nr: TIoCtlRequest;
+begin
+  case OptAct of
+  {the three constants TIOCSETA, TIOCSETAW and TIOCSETAF are
+   unsigned values above $80000000, so that they give range check errors
+   on 32-bit systems 
+   Solved by using TIoCtlRequest type for FpIOCtl second parameter }
+   TCSANOW   : nr:=TIOCSETA;
+   TCSADRAIN : nr:=TIOCSETAW;
+   TCSAFLUSH : nr:=TIOCSETAF;
+  else
+   begin
+     fpsetErrNo(ESysEINVAL);
+     TCSetAttr:=-1;
+     exit;
+   end;
+  end;
+  TCSetAttr:=fpIOCtl(fd,nr,@Tios);
+end;
+
+
+Procedure CFSetISpeed(var tios:TermIOS;speed:Cardinal); {$ifdef VER2_0}inline;{$endif}
+begin
+  tios.c_ispeed:=speed; {Probably the Bxxxx speed constants}
+end;
+
+
+Procedure CFSetOSpeed(var tios:TermIOS;speed:Cardinal); {$ifdef VER2_0}inline;{$endif}
+begin
+   tios.c_ospeed:=speed;
+end;
+
+
+
+Procedure CFMakeRaw(var tios:TermIOS);
+begin
+  with tios do
+   begin
+     c_iflag:=c_iflag and (not (IMAXBEL or IXOFF or INPCK or BRKINT or
+                PARMRK or ISTRIP or INLCR or IGNCR or ICRNL or IXON or
+                IGNPAR));
+     c_iflag:=c_iflag OR IGNBRK;
+     c_oflag:=c_oflag and (not OPOST);
+     c_lflag:=c_lflag and (not (ECHO or ECHOE or ECHOK or ECHONL or ICANON or
+                                ISIG or IEXTEN or NOFLSH or TOSTOP or PENDIN));
+     c_cflag:=(c_cflag and (not (CSIZE or PARENB))) or (CS8 OR cread);
+     c_cc[VMIN]:=1;
+     c_cc[VTIME]:=0;
+   end;
+end;
+
+Function TCSendBreak(fd,duration:cint):cint; {$ifdef VER2_0}inline;{$endif}
+var
+    sleepytime : ttimeval;
+begin
+ sleepytime.tv_sec := 0;
+ sleepytime.tv_usec := 400000;
+ if fpioctl(fd, TIOCSBRK, nil) = -1 then
+    exit(-1);
+ fpselect(0, nil, nil, nil, @sleepytime);
+ if fpioctl(fd, TIOCCBRK, nil) = -1 then
+   exit(-1);
+ TCSendBreak:=0;
+end;
+
+Function TCSetPGrp(fd,id:cint):cint; {$ifdef VER2_0}inline;{$endif}
+begin
+  TCSetPGrp:=fpIOCtl(fd,TIOCSPGRP,pointer(id));
+end;
+
+
+Function TCGetPGrp(fd:cint;var id:cint):cint; {$ifdef VER2_0}inline;{$endif}
+begin
+  TCGetPGrp:=fpIOCtl(fd,TIOCGPGRP,@id);
+end;
+
+Function TCDrain(fd:cint):cint; {$ifdef VER2_0}inline;{$endif}
+begin
+  TCDrain:=fpIOCtl(fd,TIOCDRAIN,nil); {Should set timeout to 1 first?}
+end;
+
+const 
+   _POSIX_VDISABLE = $ff;
+
+Function TCFlow(fd,act:cint):cint; {$ifdef VER2_0}inline;{$endif}
+var
+  term:Termios;
+  c : cuchar;
+  tmp : cint;
+begin
+    case act OF
+     TCOOFF :  TCFlow:=fpIoctl(fd,TIOCSTOP,nil);
+     TCOOn  :  TCFlow:=fpIOctl(Fd,TIOCStart,nil);
+     TCION,
+     TCIOFF :  begin
+	         if tcgetattr(fd, term) = -1 then
+                        exit(-1);
+                 if act=TCIOFF then  
+                   tmp:=VSTOP
+                 else
+                   tmp:=VSTART;
+                 c:=term.c_cc[tmp];
+                 if (c <> _POSIX_VDISABLE) and 
+			(fpwrite(fd, c, sizeof(c)) = -1) then
+                   exit (-1);
+                TCFlow:=0;
+              end;
+          else
+            begin
+              errno := esysEINVAL;
+              exit(-1);
+            end;
+      end;
+end;
+
+const FREAD  = 1; // marked "BSD visible"
+      FWRITE = 2;
+
+Function TCFlush(fd,qsel:cint):cint;  {$ifdef VER2_0}inline;{$endif}
+var comval : cint;
+begin
+  case qsel of
+     TCIFlush  : comval:=FREAD;
+     TCOFlush  : comval:=FWRITE;
+     TCIOFlush : comval:=FREAD or FWRITE;
+    else
+     begin
+       errno:=ESysEINVAL;
+       exit(-1);
+     end;
+   end;
+  TCFlush:=fpIOCtl(fd,TIOCFLUSH,pointer(@comval));
+end;
+
+Function IsATTY (Handle:cint):cint;
+{
+  Check if the filehandle described by 'handle' is a TTY (Terminal)
+}
+var
+  t : Termios;
+begin
+ IsAtty:=ord(TCGetAttr(Handle,t) <> -1);
+end;
+
+
+Function IsATTY(var f: text):cint; {$ifdef VER2_0}inline;{$endif}
+{
+  Idem as previous, only now for text variables.
+}
+begin
+  IsATTY:=IsaTTY(textrec(f).handle);
+end;
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/unixsock.inc rtl/dragonfly/unixsock.inc
--- rtl/dragonfly.null/unixsock.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/unixsock.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,110 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   socket call implementations for FreeBSD
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+{******************************************************************************
+                          Basic Socket Functions
+******************************************************************************}
+
+function  fpsocket (domain:cint; xtype:cint; protocol: cint):cint;
+Begin
+  fpSocket:=Do_Syscall(syscall_nr_socket,Domain,xtype,Protocol);
+  internal_socketerror:=fpgeterrno;
+End;
+
+function  fpsend (s:cint; msg:pointer; len:size_t; flags:cint):ssize_t;
+begin
+  fpSend:=do_syscall(syscall_nr_sendto,S,TSysParam(msg),Len,Flags,0,0);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpsendto (s:cint; msg:pointer; len:size_t; flags:cint; tox :psockaddr; tolen: tsocklen):ssize_t;
+begin
+  fpSendto:=do_syscall(syscall_nr_sendto,S,TSysParam(msg),Len,Flags,TSysParam(tox),tolen);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fprecv (s:cint; buf: pointer; len: size_t; flags:cint):ssize_t;
+begin
+  fpRecv:=do_syscall(syscall_nr_Recvfrom,S,tsysparam(buf),len,flags,0,0);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fprecvfrom (s:cint; buf: pointer; len: size_t; flags: cint; from : psockaddr; fromlen : psocklen):ssize_t;
+begin
+  fpRecvFrom:=do_syscall(syscall_nr_Recvfrom,S,TSysParam(buf),len,flags,TSysParam(from),TSysParam(fromlen));
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpbind (s:cint; addrx : psockaddr; addrlen : tsocklen):cint;
+begin
+  fpBind:=do_syscall(syscall_nr_Bind,S,TSysParam(addrx),addrlen);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fplisten (s:cint; backlog : cint):cint;
+begin
+  fpListen:=do_syscall(syscall_nr_Listen,S,backlog);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpaccept (s:cint; addrx : psockaddr; addrlen : psocklen):cint;
+begin
+  fpAccept:=do_syscall(syscall_nr_accept,S,TSysParam(addrx),TSysParam(addrlen));
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpconnect (s:cint; name  : psockaddr; namelen : tsocklen):cint;
+begin
+  fpConnect:=do_syscall(syscall_nr_connect,S,TSysParam(name),namelen);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpshutdown (s:cint; how:cint):cint;
+begin
+  fpShutDown:=do_syscall(syscall_nr_shutdown,S,how);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpgetsockname (s:cint; name  : psockaddr; namelen : psocklen):cint;
+begin
+  fpGetSockName:=do_syscall(syscall_nr_GetSockName,S,TSysParam(name),TSysParam(namelen));
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpgetpeername (s:cint; name  : psockaddr; namelen : psocklen):cint;
+begin
+  fpGetPeerName:=do_syscall(syscall_nr_GetPeerName,S,TSysParam(name),TSysParam(namelen));
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpsetsockopt  (s:cint; level:cint; optname:cint; optval:pointer; optlen : tsocklen):cint;
+begin
+  fpSetSockOpt:=do_syscall(syscall_nr_SetSockOpt,S,level,optname,TSysParam(optval),optlen);
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpgetsockopt  (s:cint; level:cint; optname:cint; optval:pointer; optlen : psocklen):cint;
+begin
+  fpGetSockOpt:=do_syscall(syscall_nr_GetSockOpt,S,level,TSysParam(optname),TSysParam(optval),TSysParam(optlen));
+  internal_socketerror:=fpgeterrno;
+end;
+
+function  fpsocketpair (d:cint; xtype:cint; protocol:cint; sv:pcint):cint;
+
+begin
+  fpSocketPair:=do_syscall(syscall_nr_SocketPair,d,xtype,protocol,TSysParam(sv));
+  internal_socketerror:=fpgeterrno;
+end;
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/unxconst.inc rtl/dragonfly/unxconst.inc
--- rtl/dragonfly.null/unxconst.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/unxconst.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,112 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Michael Van Canneyt,
+    member of the Free Pascal development team.
+
+    Constants for Unix unit.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+
+const
+
+  { Things for LSEEK call}
+  Seek_set = 0;
+  Seek_Cur = 1;
+  Seek_End = 2;
+
+  { Things for OPEN call - after include/sys/fcntl.h,
+   BSD specifies these constants in hex }
+  Open_Accmode  = 3;
+  Open_RdOnly   = 0;
+  Open_WrOnly   = 1;
+  Open_RdWr     = 2;
+  Open_NonBlock = 4;
+  Open_Append   = 8;
+  Open_ShLock   = $10;
+  Open_ExLock   = $20;
+  Open_ASync    = $40;
+  Open_FSync    = $80;
+  Open_NoFollow = $100;
+  Open_Create   = $200;       {BSD convention}
+  Open_Creat    = $200;       {Linux convention}
+  Open_Trunc    = $400;
+  Open_Excl     = $800;
+  Open_NoCTTY   = $8000;
+
+  { The waitpid uses the following options:}
+  Wait_NoHang   = 1;
+  Wait_UnTraced = 2;
+  Wait_Any      = -1;
+  Wait_MyPGRP   = 0;
+
+
+  { Constants to check stat.mode -  checked all STAT constants with BSD}
+  STAT_IFMT   = $f000; {00170000 }
+  STAT_IFSOCK = $c000; {0140000 }
+  STAT_IFLNK  = $a000; {0120000 }
+  STAT_IFREG  = $8000; {0100000 }
+  STAT_IFBLK  = $6000; {0060000 }
+  STAT_IFDIR  = $4000; {0040000 }
+  STAT_IFCHR  = $2000; {0020000 }
+  STAT_IFIFO  = $1000; {0010000 }
+  STAT_ISUID  = $0800; {0004000 }
+  STAT_ISGID  = $0400; {0002000 }
+  STAT_ISVTX  = $0200; {0001000}
+  { Constants to check permissions all }
+  STAT_IRWXO = $7;
+  STAT_IROTH = $4;
+  STAT_IWOTH = $2;
+  STAT_IXOTH = $1;
+
+  STAT_IRWXG = STAT_IRWXO shl 3;
+  STAT_IRGRP = STAT_IROTH shl 3;
+  STAT_IWGRP = STAT_IWOTH shl 3;
+  STAT_IXGRP = STAT_IXOTH shl 3;
+
+  STAT_IRWXU = STAT_IRWXO shl 6;
+  STAT_IRUSR = STAT_IROTH shl 6;
+  STAT_IWUSR = STAT_IWOTH shl 6;
+  STAT_IXUSR = STAT_IXOTH shl 6;
+
+  { Constants to test the type of filesystem }
+  fs_old_ext2 = $ef51;
+  fs_ext2     = $ef53;
+  fs_ext      = $137d;
+  fs_iso      = $9660;
+  fs_minix    = $137f;
+  fs_minix_30 = $138f;
+  fs_minux_V2 = $2468;
+  fs_msdos    = $4d44;
+  fs_nfs      = $6969;
+  fs_proc     = $9fa0;
+  fs_xia      = $012FD16D;
+
+  {Constansts Termios/Ioctl (used in Do_IsDevice) }
+  IOCtl_TCGETS= $40000000+$2C7400+ 19; // TCGETS is also in termios.inc, but the sysunix needs only this
+
+  ITimer_Real    =0;
+  ITimer_Virtual =1;
+  ITimer_Prof    =2;
+
+{
+  {Checked for BSD using Linuxthreads port}
+  { cloning flags }
+  CSIGNAL       = $000000ff; // signal mask to be sent at exit
+  CLONE_VM      = $00000100; // set if VM shared between processes
+  CLONE_FS      = $00000200; // set if fs info shared between processes
+  CLONE_FILES   = $00000400; // set if open files shared between processes
+  CLONE_SIGHAND = $00000800; // set if signal handlers shared
+  CLONE_PID     = $00001000; // set if pid shared
+
+type
+ TCloneFunc=function(args:pointer):longint;cdecl;
+}
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/unxfunc.inc rtl/dragonfly/unxfunc.inc
--- rtl/dragonfly.null/unxfunc.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/unxfunc.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,57 @@
+{
+   This file is part of the Free Pascal run time library.
+   Copyright (c) 2000 by Marco van de Voort
+     member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+**********************************************************************}
+
+{$ifndef HAS_LIBC_PIPING}
+Function PClose(Var F:file) : cint;
+var
+  pl : ^cint;
+  res : cint;
+
+begin
+  fpclose(filerec(F).Handle);
+{ closed our side, Now wait for the other - this appears to be needed ?? }
+  pl:=@(filerec(f).userdata[2]);
+  fpwaitpid(pl^,@res,0);
+  pclose:=res shr 8;
+end;
+
+Function PClose(Var F:text) :cint;
+var
+  pl  : ^longint;
+  res : longint;
+
+begin
+  fpclose(Textrec(F).Handle);
+{ closed our side, Now wait for the other - this appears to be needed ?? }
+  pl:=@(textrec(f).userdata[2]);
+  fpwaitpid(pl^,@res,0);
+  pclose:=res shr 8;
+end;
+{$ENDIF}
+
+
+Function AssignPipe(var pipe_in,pipe_out:cint):cint; [public, alias : 'FPC_SYSC_ASSIGNPIPE'];
+{
+  Sets up a pair of file variables, which act as a pipe. The first one can
+  be read from, the second one can be written to.
+  If the operation was unsuccesful, errno is set.
+}
+var
+  pip  : tfildes;
+begin
+  assignPipe:=fppipe(pip);
+  pipe_in:=pip[0];
+  pipe_out:=pip[1];
+end;
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/unxsockh.inc rtl/dragonfly/unxsockh.inc
--- rtl/dragonfly.null/unxsockh.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/unxsockh.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,365 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   OS dependant part of the header.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+Const
+{*
+ * Address families.
+ *}
+  AF_UNSPEC        = 0;		{ unspecified }
+  AF_UNIX          = 1;		{ standardized name for AF_LOCAL }
+  AF_LOCAL         = AF_UNIX;	{ local to host (pipes, portals) }
+  AF_INET          = 2;		{ internetwork: UDP, TCP, etc. }
+  AF_IMPLINK       = 3;		{ arpanet imp addresses }
+  AF_PUP           = 4;		{ pup protocols: e.g. BSP }
+  AF_CHAOS         = 5;		{ mit CHAOS protocols }
+  AF_NETBIOS       = 6;		{ SMB protocols }
+  AF_ISO           = 7;		{ ISO protocols }
+  AF_OSI           = AF_ISO;
+  AF_ECMA          = 8;		{ European computer manufacturers }
+  AF_DATAKIT       = 9;		{ datakit protocols }
+  AF_CCITT         = 10;	{ CCITT protocols, X.25 etc }
+  AF_SNA           = 11;	{ IBM SNA }
+  AF_DECnet        = 12;	{ DECnet }
+  AF_DLI           = 13;	{ DEC Direct data link interface }
+  AF_LAT           = 14;	{ LAT }
+  AF_HYLINK        = 15;	{ NSC Hyperchannel }
+  AF_APPLETALK     = 16;	{ Apple Talk }
+  AF_ROUTE         = 17;	{ Internal Routing Protocol }
+  AF_LINK          = 18;	{ Link layer interface }
+  pseudo_AF_XTP    = 19;	{ eXpress Transfer Protocol (no AF) }
+  AF_COIP          = 20;	{ connection-oriented IP, aka ST II }
+  AF_CNT           = 21;	{ Computer Network Technology }
+  pseudo_AF_RTIP   = 22;	{ Help Identify RTIP packets }
+  AF_IPX           = 23;	{ Novell Internet Protocol }
+  AF_SIP           = 24;	{ Simple Internet Protocol }
+  pseudo_AF_PIP    = 25;	{ Help Identify PIP packets }
+  AF_ISDN          = 26;	{ Integrated Services Digital Network}
+  AF_E164          = AF_ISDN;	{ CCITT E.164 recommendation }
+  pseudo_AF_KEY    = 27;	{ Internal key-management function }
+  AF_INET6         = 28;	{ IPv6 }
+  AF_NATM          = 29;	{ native ATM access }
+  AF_ATM           = 30;	{ ATM }
+  pseudo_AF_HDRCMPLT = 31;	{ Used by BPF to not rewrite headers
+					 * in interface output routine
+                                         }
+  AF_NETGRAPH      = 32;	{ Netgraph sockets }
+  AF_SLOW          = 33;	{ 802.3ad slow protocol }
+  AF_SCLUSTER      = 34;	{ Sitara cluster protocol }
+  AF_ARP           = 35;
+  AF_BLUETOOTH     = 36;	{ Bluetooth sockets }
+  AF_IEEE80211     = 37;	{ IEEE 802.11 protocol }
+  AF_MAX           = 38;
+  
+  {
+   * Protocol families, same as address families for now.
+    }
+
+  const
+     PF_UNSPEC = AF_UNSPEC;
+     PF_LOCAL = AF_LOCAL;
+  { backward compatibility  }
+     PF_UNIX = PF_LOCAL;
+     PF_INET = AF_INET;
+     PF_IMPLINK = AF_IMPLINK;
+     PF_PUP = AF_PUP;
+     PF_CHAOS = AF_CHAOS;
+     PF_NETBIOS = AF_NETBIOS;
+     PF_ISO = AF_ISO;
+     PF_OSI = AF_ISO;
+     PF_ECMA = AF_ECMA;
+     PF_DATAKIT = AF_DATAKIT;
+     PF_CCITT = AF_CCITT;
+     PF_SNA = AF_SNA;
+     PF_DECnet = AF_DECnet;
+     PF_DLI = AF_DLI;
+     PF_LAT = AF_LAT;
+     PF_HYLINK = AF_HYLINK;
+     PF_APPLETALK = AF_APPLETALK;
+     PF_ROUTE = AF_ROUTE;
+     PF_LINK = AF_LINK;
+  { really just proto family, no AF  }
+     PF_XTP = pseudo_AF_XTP;
+     PF_COIP = AF_COIP;
+     PF_CNT = AF_CNT;
+     PF_SIP = AF_SIP;
+     PF_IPX = AF_IPX;
+  { same format as AF_INET  }
+     PF_RTIP = pseudo_AF_RTIP;
+     PF_PIP = pseudo_AF_PIP;
+     PF_ISDN = AF_ISDN;
+     PF_KEY = pseudo_AF_KEY;
+     PF_INET6 = AF_INET6;
+     PF_NATM = AF_NATM;
+     PF_ATM = AF_ATM;
+     PF_NETGRAPH = AF_NETGRAPH;
+     PF_SLOW = AF_SLOW;
+     PF_SCLUSTER = AF_SCLUSTER;
+     PF_ARP = AF_ARP;
+     PF_BLUETOOTH = AF_BLUETOOTH;
+     PF_MAX = AF_MAX;
+
+
+  SOCK_PACKET     = 10;
+
+
+{ Maximum queue length specifiable by listen.  }
+  SOMAXCONN     = 128;
+
+        SOL_SOCKET 	 = $FFFF;
+        SO_DEBUG         = $0001;        { turn on debugging info recording }
+        SO_ACCEPTCONN    = $0002;        { socket has had listen() }
+        SO_REUSEADDR     = $0004;        { allow local address reuse }
+        SO_KEEPALIVE     = $0008;        { keep connections alive }
+        SO_DONTROUTE     = $0010;        { just use interface addresses }
+        SO_BROADCAST     = $0020;        { permit sending of broadcast msgs }
+        SO_USELOOPBACK   = $0040;        { bypass hardware when possible }
+        SO_LINGER        = $0080;        { linger on close if data present }
+        SO_OOBINLINE     = $0100;        { leave received OOB data in line }
+        SO_REUSEPORT     = $0200;        { allow local address & port reuse }
+        SO_TIMESTAMP     = $0400;        { timestamp received dgram traffic }
+
+{
+ * Additional options, not kept in so_options.
+ }
+        SO_SNDBUF        =$1001;        { send buffer size }
+        SO_RCVBUF        =$1002;        { receive buffer size }
+        SO_SNDLOWAT      =$1003;        { send low-water mark }
+        SO_RCVLOWAT      =$1004;        { receive low-water mark }
+        SO_SNDTIMEO      =$1005;        { send timeout }
+        SO_RCVTIMEO      =$1006;        { receive timeout }
+        SO_ERROR         =$1007;        { get error status and clear }
+        SO_TYPE          =$1008;        { get socket type }
+
+
+        SHUT_RD         =0;             { shut down the reading side }
+        SHUT_WR         =1;             { shut down the writing side }
+        SHUT_RDWR       =2;             { shut down both sides }
+
+	IPPROTO_IP              = 0;               { dummy for IP }
+	IPPROTO_ICMP            = 1;               { control message protocol }
+	IPPROTO_TCP             = 6;               { tcp }
+	IPPROTO_UDP             = 17;              { user datagram protocol }
+
+
+	IPPROTO_HOPOPTS		= 0 ; 		{ IP6 hop-by-hop options }
+	IPPROTO_IGMP		= 2 ; 		{ group mgmt protocol }
+	IPPROTO_GGP		= 3 ; 		{ gateway^2 (deprecated) }
+	IPPROTO_IPV4		= 4 ; 		{ IPv4 encapsulation }
+	IPPROTO_IPIP		= IPPROTO_IPV4;	{ for compatibility }
+	IPPROTO_ST		= 7 ; 		{ Stream protocol II }
+	IPPROTO_EGP		= 8 ; 		{ exterior gateway protocol }
+	IPPROTO_PIGP		= 9 ; 		{ private interior gateway }
+	IPPROTO_RCCMON		= 10; 		{ BBN RCC Monitoring }
+	IPPROTO_NVPII		= 11; 		{ network voice protocol}
+	IPPROTO_PUP		= 12; 		{ pup }
+	IPPROTO_ARGUS		= 13; 		{ Argus }
+	IPPROTO_EMCON		= 14; 		{ EMCON }
+	IPPROTO_XNET		= 15; 		{ Cross Net Debugger }
+	IPPROTO_CHAOS		= 16; 		{ Chaos}
+	IPPROTO_MUX		= 18; 		{ Multiplexing }
+	IPPROTO_MEAS		= 19; 		{ DCN Measurement Subsystems }
+	IPPROTO_HMP		= 20; 		{ Host Monitoring }
+	IPPROTO_PRM		= 21; 		{ Packet Radio Measurement }
+	IPPROTO_IDP		= 22; 		{ xns idp }
+	IPPROTO_TRUNK1		= 23; 		{ Trunk-1 }
+	IPPROTO_TRUNK2		= 24; 		{ Trunk-2 }
+	IPPROTO_LEAF1		= 25; 		{ Leaf-1 }
+	IPPROTO_LEAF2		= 26; 		{ Leaf-2 }
+	IPPROTO_RDP		= 27; 		{ Reliable Data }
+	IPPROTO_IRTP		= 28; 		{ Reliable Transaction }
+	IPPROTO_TP		= 29; 		{ tp-4 w/ class negotiation }
+	IPPROTO_BLT		= 30; 		{ Bulk Data Transfer }
+	IPPROTO_NSP		= 31; 		{ Network Services }
+	IPPROTO_INP		= 32; 		{ Merit Internodal }
+	IPPROTO_SEP		= 33; 		{ Sequential Exchange }
+	IPPROTO_3PC		= 34; 		{ Third Party Connect }
+	IPPROTO_IDPR		= 35; 		{ InterDomain Policy Routing }
+	IPPROTO_XTP		= 36; 		{ XTP }
+	IPPROTO_DDP		= 37; 		{ Datagram Delivery }
+	IPPROTO_CMTP		= 38; 		{ Control Message Transport }
+	IPPROTO_TPXX		= 39; 		{ TP++ Transport }
+	IPPROTO_IL		= 40; 		{ IL transport protocol }
+	IPPROTO_IPV6		= 41; 		{ IP6 header }
+	IPPROTO_SDRP		= 42; 		{ Source Demand Routing }
+	IPPROTO_ROUTING		= 43; 		{ IP6 routing header }
+	IPPROTO_FRAGMENT	= 44; 		{ IP6 fragmentation header }
+	IPPROTO_IDRP		= 45; 		{ InterDomain Routing}
+	IPPROTO_RSVP		= 46; 		{ resource reservation }
+	IPPROTO_GRE		= 47; 		{ General Routing Encap. }
+	IPPROTO_MHRP		= 48; 		{ Mobile Host Routing }
+	IPPROTO_BHA		= 49; 		{ BHA }
+	IPPROTO_ESP		= 50; 		{ IP6 Encap Sec. Payload }
+	IPPROTO_AH		= 51; 		{ IP6 Auth Header }
+	IPPROTO_INLSP		= 52; 		{ Integ. Net Layer Security }
+	IPPROTO_SWIPE		= 53; 		{ IP with encryption }
+	IPPROTO_NHRP		= 54; 		{ Next Hop Resolution }
+	IPPROTO_MOBILE		= 55; 		{ IP Mobility }
+	IPPROTO_TLSP		= 56; 		{ Transport Layer Security }
+	IPPROTO_SKIP		= 57; 		{ SKIP }
+	IPPROTO_ICMPV6		= 58; 		{ ICMP6 }
+	IPPROTO_NONE		= 59; 		{ IP6 no next header }
+	IPPROTO_DSTOPTS		= 60; 		{ IP6 destination option }
+	IPPROTO_AHIP		= 61; 		{ any host internal protocol }
+	IPPROTO_CFTP		= 62; 		{ CFTP }
+	IPPROTO_HELLO		= 63; 		{ "hello" routing protocol }
+	IPPROTO_SATEXPAK	= 64; 		{ SATNET/Backroom EXPAK }
+	IPPROTO_KRYPTOLAN	= 65; 		{ Kryptolan }
+	IPPROTO_RVD		= 66; 		{ Remote Virtual Disk }
+	IPPROTO_IPPC		= 67; 		{ Pluribus Packet Core }
+	IPPROTO_ADFS		= 68; 		{ Any distributed FS }
+	IPPROTO_SATMON		= 69; 		{ Satnet Monitoring }
+	IPPROTO_VISA		= 70; 		{ VISA Protocol }
+	IPPROTO_IPCV		= 71; 		{ Packet Core Utility }
+	IPPROTO_CPNX		= 72; 		{ Comp. Prot. Net. Executive }
+	IPPROTO_CPHB		= 73; 		{ Comp. Prot. HeartBeat }
+	IPPROTO_WSN		= 74; 		{ Wang Span Network }
+	IPPROTO_PVP		= 75; 		{ Packet Video Protocol }
+	IPPROTO_BRSATMON	= 76; 		{ BackRoom SATNET Monitoring }
+	IPPROTO_ND		= 77; 		{ Sun net disk proto (temp.) }
+	IPPROTO_WBMON		= 78; 		{ WIDEBAND Monitoring }
+	IPPROTO_WBEXPAK		= 79; 		{ WIDEBAND EXPAK }
+	IPPROTO_EON		= 80; 		{ ISO cnlp }
+	IPPROTO_VMTP		= 81; 		{ VMTP }
+	IPPROTO_SVMTP		= 82; 		{ Secure VMTP }
+	IPPROTO_VINES		= 83; 		{ Banyon VINES }
+	IPPROTO_TTP		= 84; 		{ TTP }
+	IPPROTO_IGP		= 85; 		{ NSFNET-IGP }
+	IPPROTO_DGP		= 86; 		{ dissimilar gateway prot. }
+	IPPROTO_TCF		= 87; 		{ TCF }
+	IPPROTO_IGRP		= 88; 		{ Cisco/GXS IGRP }
+	IPPROTO_OSPFIGP		= 89; 		{ OSPFIGP }
+	IPPROTO_SRPC		= 90; 		{ Strite RPC protocol }
+	IPPROTO_LARP		= 91; 		{ Locus Address Resoloution }
+	IPPROTO_MTP		= 92; 		{ Multicast Transport }
+	IPPROTO_AX25		= 93; 		{ AX.25 Frames }
+	IPPROTO_IPEIP		= 94; 		{ IP encapsulated in IP }
+	IPPROTO_MICP		= 95; 		{ Mobile Int.ing control }
+	IPPROTO_SCCSP		= 96; 		{ Semaphore Comm. security }
+	IPPROTO_ETHERIP		= 97; 		{ Ethernet IP encapsulation }
+	IPPROTO_ENCAP		= 98; 		{ encapsulation header }
+	IPPROTO_APES		= 99; 		{ any private encr. scheme }
+	IPPROTO_GMTP		= 100;		{ GMTP}
+	IPPROTO_IPCOMP		= 108;		{ payload compression (IPComp) }
+{ 101-254: Partly Unassigned }
+	IPPROTO_PIM		= 103;		{ Protocol Independent Mcast }
+	IPPROTO_CARP		= 112;		{ CARP }
+	IPPROTO_PGM		= 113;		{ PGM }
+	IPPROTO_PFSYNC		= 240;		{ PFSYNC }
+
+{ last return value of *_input(), meaning "all job for this pkt is done".  }
+	IPPROTO_RAW             = 255;
+	IPPROTO_MAX		= 256;
+	IPPROTO_DONE		= 257;
+
+{
+ * Options for use with [gs]etsockopt at the IP level.
+ * First word of comment is data type; bool is stored in int.
+ }
+	IP_OPTIONS		= 1 ;   { buf/ip_opts; set/get IP options }
+	IP_HDRINCL		= 2 ;   { int; header is included with data }
+	IP_TOS			= 3 ;   { int; IP type of service and preced. }
+	IP_TTL			= 4 ;   { int; IP time to live }
+	IP_RECVOPTS		= 5 ;   { bool; receive all IP opts w/dgram }
+	IP_RECVRETOPTS		= 6 ;   { bool; receive IP opts for response }
+	IP_RECVDSTADDR		= 7 ;   { bool; receive IP dst addr w/dgram }
+	IP_SENDSRCADDR		= IP_RECVDSTADDR; { cmsg_type to set src addr }
+	IP_RETOPTS		= 8 ;   { ip_opts; set/get IP options }
+	IP_MULTICAST_IF		= 9 ;   { u_char; set/get IP multicast i/f  }
+	IP_MULTICAST_TTL	= 10;   { u_char; set/get IP multicast ttl }
+	IP_MULTICAST_LOOP	= 11;   { u_char; set/get IP multicast loopback }
+	IP_ADD_MEMBERSHIP	= 12;   { ip_mreq; add an IP group membership }
+	IP_DROP_MEMBERSHIP	= 13;   { ip_mreq; drop an IP group membership }
+	IP_MULTICAST_VIF	= 14;   { set/get IP mcast virt. iface }
+	IP_RSVP_ON		= 15;   { enable RSVP in kernel }
+	IP_RSVP_OFF		= 16;   { disable RSVP in kernel }
+	IP_RSVP_VIF_ON		= 17;   { set RSVP per-vif socket }
+	IP_RSVP_VIF_OFF		= 18;   { unset RSVP per-vif socket }
+	IP_PORTRANGE		= 19;   { int; range to choose for unspec port }
+	IP_RECVIF		= 20;   { bool; receive reception if w/dgram }
+
+{ for IPSEC }
+	IP_IPSEC_POLICY		= 21;   { int; set/get security policy }
+	IP_FAITH		= 22;   { bool; accept FAITH'ed connections }
+
+	IP_ONESBCAST		= 23;   { bool: send all-ones broadcast }
+                                
+	IP_FW_TABLE_ADD		= 40;   { add entry }
+	IP_FW_TABLE_DEL		= 41;   { delete entry }
+	IP_FW_TABLE_FLUSH	= 42;   { flush table }
+	IP_FW_TABLE_GETSIZE	= 43;   { get table size }
+	IP_FW_TABLE_LIST	= 44;   { list table contents }
+
+	IP_FW_ADD		= 50;   { add a firewall rule to chain }
+	IP_FW_DEL		= 51;   { delete a firewall rule from chain }
+	IP_FW_FLUSH		= 52;   { flush firewall rule chain }
+	IP_FW_ZERO		= 53;   { clear single/all firewall counter(s) }
+	IP_FW_GET		= 54;   { get entire firewall rule chain }
+	IP_FW_RESETLOG		= 55;   { reset logging counters }
+
+	IP_DUMMYNET_CONFIGURE	= 60;   { add/configure a dummynet pipe }
+	IP_DUMMYNET_DEL		= 61;   { delete a dummynet pipe from chain }
+	IP_DUMMYNET_FLUSH	= 62;   { flush dummynet }
+	IP_DUMMYNET_GET		= 64;   { get entire dummynet pipes }
+
+	IP_RECVTTL		= 65;   { bool; receive IP TTL w/dgram }
+
+	IPV6_SOCKOPT_RESERVED1	= 3 ; { reserved for future use }
+	IPV6_UNICAST_HOPS	= 4 ; { int; IP6 hops }
+	IPV6_MULTICAST_IF	= 9 ; { u_int; setget IP6 multicast if  }
+	IPV6_MULTICAST_HOPS	= 10; { int; setget IP6 multicast hops }
+	IPV6_MULTICAST_LOOP	= 11; { u_int; setget IP6 multicast loopback }
+	IPV6_JOIN_GROUP		= 12; { ip6_mreq; join a group membership }
+	IPV6_LEAVE_GROUP	= 13; { ip6_mreq; leave a group membership }
+	IPV6_PORTRANGE		= 14; { int; range to choose for unspec port }
+
+	IPV6_PKTINFO            = 46; { in6_pktinfo; send if, src addr }	
+ 	IPV6_HOPLIMIT           = 47; { int; send hop limit }
+ 	IPV6_NEXTHOP            = 48; { sockaddr; next hop addr }
+ 	IPV6_HOPOPTS            = 49; { ip6_hbh; send hop-by-hop option }
+ 	IPV6_DSTOPTS            = 50; { ip6_dest; send dst option befor rthdr }
+ 	IPV6_RTHDR              = 51; { ip6_rthdr; send routing header }
+ 	IPV6_PKTOPTIONS         = 52; { buf/cmsghdr; set/get IPv6 options }
+  
+  { Flags for send, recv etc. }
+  MSG_OOB       = $0001;              { Process out-of-band data}
+  MSG_PEEK      = $0002;              { Peek at incoming messages }
+  MSG_DONTROUTE = $0004;              { Don't use local routing }
+  MSG_EOR       = $0008;              { End of record }
+  MSG_TRUNC     = $0010;
+  MSG_CTRUNC    = $0020;              { Control data lost before delivery }
+  MSG_WAITALL   = $0040;              { Wait for a full request }
+  MSG_DONTWAIT  = $0080;              { Non-blocking I/O }
+  MSG_EOF       = $0100;
+  MSG_NBIO      = $4000;
+  MSG_COMPAT    = $8000;
+  MSG_SOCALLBCK = $10000;
+  MSG_NOSIGNAL  = $20000;              { Do not generate SIGPIPE }
+  
+  INVALID_SOCKET = -1;
+  SOCKET_ERROR = -1;
+  
+     TCP_NODELAY = $01;
+  { set maximum segment size  }
+     TCP_MAXSEG = $02;
+  { don't push last block of write  }
+     TCP_NOPUSH = $04;
+  { don't use TCP options  }
+     TCP_NOOPT = $08;
+  { use MD5 digests (RFC2385)  }
+     TCP_MD5SIG = $10;
+  { retrieve tcp_info structure  }
+     TCP_INFO = $20;
+
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/unxsysc.inc rtl/dragonfly/unxsysc.inc
--- rtl/dragonfly.null/unxsysc.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/unxsysc.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,91 @@
+{
+   This file is part of the Free Pascal run time library.
+   Copyright (c) 2003 Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+**********************************************************************}
+
+(*
+function clone(func:TCloneFunc;sp:pointer;flags:longint;args:pointer):longint;
+{NOT IMPLEMENTED YET UNDER BSD}
+begin // perhaps it is better to implement the hack from solaris then this msg
+ HALT;
+END;
+
+  if (pointer(func)=nil) or (sp=nil) then
+   begin
+     Lfpseterrno(EsysEInval);
+     exit(-1);
+   end;
+  asm
+        { Insert the argument onto the new stack. }
+        movl    sp,%ecx
+        subl    $8,%ecx
+        movl    args,%eax
+        movl    %eax,4(%ecx)
+
+        { Save the function pointer as the zeroth argument.
+          It will be popped off in the child in the ebx frobbing below. }
+        movl    func,%eax
+        movl    %eax,0(%ecx)
+
+        { Do the system call }
+        pushl   %ebx
+        pushl   %ebx
+      //  movl    flags,%ebx
+        movl    $251,%eax
+        int     $0x80
+        popl    %ebx
+        popl    %ebx
+        test    %eax,%eax
+        jnz     .Lclone_end
+
+        { We're in the new thread }
+        subl    %ebp,%ebp       { terminate the stack frame }
+        call    *%ebx
+        { exit process }
+        movl    %eax,%ebx
+        movl    $1,%eax
+        int     $0x80
+
+.Lclone_end:
+        movl    %eax,__RESULT
+  end;
+end;
+*)
+
+Function  fpfStatFS (Fd: cint; Info:pstatfs):cint;
+begin
+  fpfstatfs:=do_SysCall(SysCall_nr_fstatfs,fd,TSysParam(info))
+end;
+
+Function  fpStatFS  (Path:pchar; Info:pstatfs):cint;
+
+begin
+  fpstatfs:=do_SysCall(SysCall_nr_statfs,TSysParam(path),TSysParam(Info))
+end;
+
+Function  fpfsync (fd : cint) : cint;
+
+begin
+  fpfsync:=do_SysCall(syscall_nr_fsync, fd);
+end;
+
+Function  fpFlock (fd,mode : longint) : cint;
+
+begin
+ fpFlock:=do_syscall(syscall_nr_flock,fd,mode);
+end;
+
+function MUnMap (P : Pointer; Size : size_t) : cint;
+begin
+  MUnMap:=do_syscall(syscall_nr_munmap,TSysParam(P),Size);
+end;
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/bsyscall.inc rtl/dragonfly/x86_64/bsyscall.inc
--- rtl/dragonfly.null/x86_64/bsyscall.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/bsyscall.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1 @@
+{ empty bsyscall }
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/cprt0.as rtl/dragonfly/x86_64/cprt0.as
--- rtl/dragonfly.null/x86_64/cprt0.as	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/cprt0.as	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,182 @@
+#
+#   This file is part of the Free Pascal run time library.
+#   Copyright (c) 1999-2000 by Marco van de Voort, Pierre Mueller
+#   members of the Free Pascal development team.
+#
+#   See the file COPYING.FPC, included in this distribution,
+#   for details about the copyright.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY;without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+#**********************************************************************}
+#
+# DragonFly ELF startup code for Free Pascal for dynamical linking to libc.
+#
+# To avoid needing a "COMPAT" system, patch the constant following the 
+# "DragonFly" field in the abitag to the relevant ABI number 
+
+	.file	"crt1.c"
+	.section	.note.ABI-tag,"a",@progbits
+	.align 4
+	.type	abitag, @object
+	.size	abitag, 28
+abitag:
+	.long	10
+	.long	4
+	.long	1
+	.string	"DragonFly"
+	.align	4
+	.long	900044
+.globl __progname
+	.section	.rodata
+.LC0:
+	.string	""
+	.data
+	.align 8
+	.type	__progname, @object
+	.size	__progname, 8
+__progname:
+	.quad	.LC0
+	.text
+	.p2align 4,,15
+.globl _start
+	.type	_start, @function
+_start:
+.LFB5:
+	pushq	%rbp
+.LCFI0:
+	movq	%rsp, %rbp
+.LCFI1:
+	subq	$48, %rsp
+.LCFI2:
+	movq	%rdi, -40(%rbp)
+	movq	%rsi, -48(%rbp)
+	movq	-40(%rbp), %rax
+	movq	(%rax), %rax
+	movl	%eax, -28(%rbp)
+	movl	%eax, operatingsystem_parameter_argc(%rip)
+	movq	-40(%rbp), %rax
+	addq	$8, %rax
+	movq	%rax, -24(%rbp)
+	movq	%rax, operatingsystem_parameter_argv(%rip)
+	movq	-40(%rbp), %rdx
+	addq	$16, %rdx
+	movl	-28(%rbp), %eax
+	cltq
+	salq	$3, %rax
+	leaq	(%rdx,%rax), %rax
+	movq	%rax, -16(%rbp)
+	movq	-16(%rbp), %rax
+	movq	%rax, operatingsystem_parameter_envp(%rip)
+	movq	%rax, environ(%rip)
+	cmpl	$0, -28(%rbp)
+	jle	.L2
+	movq	-24(%rbp), %rax
+	movq	(%rax), %rax
+	testq	%rax, %rax
+	je	.L2
+	movq	-24(%rbp), %rax
+	movq	(%rax), %rax
+	movq	%rax, __progname(%rip)
+	movq	__progname(%rip), %rax
+	movq	%rax, -8(%rbp)
+	jmp	.L5
+.L6:
+	movq	-8(%rbp), %rax
+	movzbl	(%rax), %eax
+	cmpb	$47, %al
+	jne	.L7
+	movq	-8(%rbp), %rax
+	addq	$1, %rax
+	movq	%rax, __progname(%rip)
+.L7:
+	addq	$1, -8(%rbp)
+.L5:
+	movq	-8(%rbp), %rax
+	movzbl	(%rax), %eax
+	testb	%al, %al
+	jne	.L6
+.L2:
+	movl	$_DYNAMIC, %eax
+	testq	%rax, %rax
+	je	.L9
+	movq	-48(%rbp), %rdi
+	call	atexit
+	jmp	.L11
+.L9:
+	call	_init_tls
+.L11:
+	movl	$_fini, %edi
+	call	atexit
+	call	_init
+#	movq	-16(%rbp), %rdx
+#	movq	-24(%rbp), %rsi
+#	movl	-28(%rbp), %edi
+	xorq   %rbp,%rbp  	
+	call	main
+	movl	%eax, %edi
+	call	exit
+.LFE5:
+	.size	_start, .-_start
+.bss
+        .type   __stkptr,@object
+        .size   __stkptr,8
+        .global __stkptr
+__stkptr:
+        .skip   8
+
+        .type operatingsystem_parameters,@object
+        .size operatingsystem_parameters,24
+operatingsystem_parameters:
+        .skip 3*8
+
+        .global operatingsystem_parameter_envp
+        .global operatingsystem_parameter_argc
+        .global operatingsystem_parameter_argv
+        .set operatingsystem_parameter_envp,operatingsystem_parameters+0
+        .set operatingsystem_parameter_argc,operatingsystem_parameters+8
+        .set operatingsystem_parameter_argv,operatingsystem_parameters+16
+
+	.comm	environ,8,8
+	.weak	_DYNAMIC
+	.section	.eh_frame,"a",@progbits
+.Lframe1:
+	.long	.LECIE1-.LSCIE1
+.LSCIE1:
+	.long	0x0
+	.byte	0x1
+	.string	"zR"
+	.uleb128 0x1
+	.sleb128 -8
+	.byte	0x10
+	.uleb128 0x1
+	.byte	0x3
+	.byte	0xc
+	.uleb128 0x7
+	.uleb128 0x8
+	.byte	0x90
+	.uleb128 0x1
+	.align 8
+.LECIE1:
+.LSFDE1:
+	.long	.LEFDE1-.LASFDE1
+.LASFDE1:
+	.long	.LASFDE1-.Lframe1
+	.long	.LFB5
+	.long	.LFE5-.LFB5
+	.uleb128 0x0
+	.byte	0x4
+	.long	.LCFI0-.LFB5
+	.byte	0xe
+	.uleb128 0x10
+	.byte	0x86
+	.uleb128 0x2
+	.byte	0x4
+	.long	.LCFI1-.LCFI0
+	.byte	0xd
+	.uleb128 0x6
+	.align 8
+.LEFDE1:
+	.ident	"[DragonFly]"
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/dllprt0.as rtl/dragonfly/x86_64/dllprt0.as
--- rtl/dragonfly.null/x86_64/dllprt0.as	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/dllprt0.as	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,72 @@
+#
+#   This file is part of the Free Pascal run time library.
+#   Copyright (c) 1999-2000 by Marco van de Voort, Michael Van Canneyt
+#                                                  and Peter Vreman
+#   members of the Free Pascal development team.
+#
+#   See the file COPYING.FPC, included in this distribution,
+#   for details about the copyright.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY;without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+#
+#**********************************************************************}
+#
+# DragonFly standard (shared) ELF startup code for Free Pascal
+#
+# DragonFly RunTime dynamic loader only
+# calls the functions specified by -init
+# as functions without parameters
+# Thus, it is not possible to retrieve argc, argv and envp
+# for libraries.
+# On x86_64 CPU, using weak for the operatingsystem_parameter_XXX
+# allows to bind to main program parameters,
+# but this does not seem to work for i386 loader.
+ 
+	.file	"crt1.c"
+	.section	.note.ABI-tag,"a",@progbits
+	.p2align 2
+	.type	abitag, @object
+	.size	abitag, 28
+abitag:
+	.long	10
+	.long	4
+	.long	1
+	.string	"DragonFly"
+	.align	4
+	.long	400000
+
+	.text
+	.p2align 2,,3
+	.globl FPC_LIB_START
+	.type FPC_LIB_START,@function
+FPC_LIB_START:
+	.globl FPC_SHARED_LIB_START
+	.type FPC_SHARED_LIB_START,@function
+FPC_SHARED_LIB_START:
+	# jmp	_startlib@PLT
+        movb    $1,operatingsystem_islibrary(%rip)
+        #movq    operatingsystem_islibrary@GOTPCREL(%rip),%rax
+        #movb    $1,(%rax)
+	call	PASCALMAIN@PLT
+	ret
+	.p2align 2,,3
+        .globl  _haltproc
+        .type   _haltproc,@function
+/* this routine is only called when the halt() routine of the RTL embedded in
+  the shared library is called */
+_haltproc:
+	.globl FPC_SHARED_LIB_EXIT
+	.type FPC_SHARED_LIB_EXIT,@function
+FPC_SHARED_LIB_EXIT:
+        call    FPC_LIB_EXIT@PLT
+	movl    $1,%eax                 /* exit syscall */
+        movq    operatingsystem_result(%rip),%rbx
+        movzwl  (%rbx),%edi
+        syscall
+        jmp     _haltproc@PLT
+	/* Do not fail linkage if argc, argv and envp are not found. */
+	.weak   operatingsystem_parameter_argc
+	.weak   operatingsystem_parameter_argv
+	.weak   operatingsystem_parameter_envp
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/gprt0.as rtl/dragonfly/x86_64/gprt0.as
--- rtl/dragonfly.null/x86_64/gprt0.as	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/gprt0.as	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,136 @@
+	.file	"crt1.c"
+	.section	.note.ABI-tag,"a",@progbits
+	.p2align 2
+	.type	abitag, @object
+	.size	abitag, 28
+abitag:
+	.long	10
+	.long	4
+	.long	1
+	.string	"DragonFly"
+	.align	4
+	.long	400000
+	.section	.rodata
+.LC0:
+	.string	""
+.globl __progname
+	.data
+	.p2align 3
+	.type	__progname, @object
+	.size	__progname, 8
+__progname:
+	.quad	.LC0
+	.text
+	.p2align 2,,3
+.globl _start
+	.type	_start, @function
+_start:
+.LFB9:
+	pushq	%rbp
+.LCFI0:
+	movq	%rsp, %rbp
+.LCFI1:
+	subq	$48, %rsp
+.LCFI2:
+	movq	%rdi, -8(%rbp)
+	movq	%rsi, -16(%rbp)
+	movq	-8(%rbp), %rax
+	movl	(%rax), %eax
+	movl	%eax, -20(%rbp)
+	movl	%eax, operatingsystem_parameter_argc(%rip)
+	movq	-8(%rbp), %rax
+	addq	$8, %rax
+	movq	%rax, -32(%rbp)
+	movq    %rax, operatingsystem_parameter_argv(%rip)
+	movl	-20(%rbp), %eax
+	cltq
+	salq	$3, %rax
+	addq	-8(%rbp), %rax
+	addq	$16, %rax
+	movq	%rax, -40(%rbp)
+	movq    %rax, operatingsystem_parameter_envp(%rip)
+	movq	-40(%rbp), %rax
+	movq	%rax, environ(%rip)
+	cmpl	$0, -20(%rbp)
+	jle	.L5
+	movq	-32(%rbp), %rax
+	cmpq	$0, (%rax)
+	je	.L5
+	movq	-32(%rbp), %rax
+	movq	(%rax), %rax
+	movq	%rax, __progname(%rip)
+	movq	__progname(%rip), %rax
+	movq	%rax, -48(%rbp)
+.L6:
+	movq	-48(%rbp), %rax
+	cmpb	$0, (%rax)
+	jne	.L9
+	jmp	.L5
+.L9:
+	movq	-48(%rbp), %rax
+	cmpb	$47, (%rax)
+	jne	.L8
+	movq	-48(%rbp), %rax
+	incq	%rax
+	movq	%rax, __progname(%rip)
+.L8:
+	leaq	-48(%rbp), %rax
+	incq	(%rax)
+	jmp	.L6
+.L5:
+# 	movl	$_DYNAMIC, %eax
+# 	testq	%rax, %rax
+# 	je	.L11
+# 	movq	-16(%rbp), %rdi
+# 	call	atexit
+.L11:
+# 	movl	$_fini, %edi
+# 	call	atexit
+#	call	_init
+#	movq	-40(%rbp), %rdx    #env
+#	movq	-32(%rbp), %rsi  #argv
+#	movl	-20(%rbp), %edi  # argc
+	xorq    %rbp,%rbp
+	call	main
+	movl	%eax, %edi
+	call	exit
+.LFE9:
+	.size	_start, .-_start
+	.comm	environ,8,8
+	.weak	_DYNAMIC
+	.section	.eh_frame,"a",@progbits
+.Lframe1:
+	.long	.LECIE1-.LSCIE1
+.LSCIE1:
+	.long	0x0
+	.byte	0x1
+	.string	""
+	.uleb128 0x1
+	.sleb128 -8
+	.byte	0x10
+	.byte	0xc
+	.uleb128 0x7
+	.uleb128 0x8
+	.byte	0x90
+	.uleb128 0x1
+	.p2align 3
+.LECIE1:
+.LSFDE1:
+	.long	.LEFDE1-.LASFDE1
+.LASFDE1:
+	.long	.LASFDE1-.Lframe1
+	.quad	.LFB9
+	.quad	.LFE9-.LFB9
+	.byte	0x4
+	.long	.LCFI0-.LFB9
+	.byte	0xe
+	.uleb128 0x10
+	.byte	0x86
+	.uleb128 0x2
+	.byte	0x4
+	.long	.LCFI1-.LCFI0
+	.byte	0xd
+	.uleb128 0x6
+	.p2align 3
+.LEFDE1:
+	.ident	"[DragonFly]"
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/prt0.as rtl/dragonfly/x86_64/prt0.as
--- rtl/dragonfly.null/x86_64/prt0.as	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/prt0.as	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,158 @@
+	.file	"crt1.c"
+	.section	.note.ABI-tag,"a",@progbits
+	.p2align 2
+	.type	abitag, @object
+	.size	abitag, 28
+abitag:
+	.long	10
+	.long	4
+	.long	1
+	.string	"DragonFly"
+	.align	4
+	.long	400000
+
+	.section	.rodata
+.LC0:
+	.string	""
+.globl __progname
+	.data
+	.p2align 3
+	.type	__progname, @object
+	.size	__progname, 8
+__progname:
+	.quad	.LC0
+	.text
+	.p2align 2,,3
+.globl _start
+	.type	_start, @function
+_start:
+.LFB9:
+	pushq	%rbp
+.LCFI0:
+	movq	%rsp, %rbp
+.LCFI1:
+	subq	$48, %rsp
+.LCFI2:
+	movq	%rdi, -8(%rbp)
+	movq	%rsi, -16(%rbp)
+	movq	-8(%rbp), %rax
+	movl	(%rax), %eax
+	movl	%eax, -20(%rbp)
+	movl	%eax, operatingsystem_parameter_argc(%rip)
+	movq	-8(%rbp), %rax
+	addq	$8, %rax
+	movq	%rax, -32(%rbp)
+	movq    %rax, operatingsystem_parameter_argv(%rip)
+	movl	-20(%rbp), %eax
+	cltq
+	salq	$3, %rax
+	addq	-8(%rbp), %rax
+	addq	$16, %rax
+	movq	%rax, -40(%rbp)
+	movq    %rax, operatingsystem_parameter_envp(%rip)
+	movq	-40(%rbp), %rax
+	movq	%rax, environ(%rip)
+	cmpl	$0, -20(%rbp)
+	jle	.L5
+	movq	-32(%rbp), %rax
+	cmpq	$0, (%rax)
+	je	.L5
+	movq	-32(%rbp), %rax
+	movq	(%rax), %rax
+	movq	%rax, __progname(%rip)
+	movq	__progname(%rip), %rax
+	movq	%rax, -48(%rbp)
+.L6:
+	movq	-48(%rbp), %rax
+	cmpb	$0, (%rax)
+	jne	.L9
+	jmp	.L5
+.L9:
+	movq	-48(%rbp), %rax
+	cmpb	$47, (%rax)
+	jne	.L8
+	movq	-48(%rbp), %rax
+	incq	%rax
+	movq	%rax, __progname(%rip)
+.L8:
+	leaq	-48(%rbp), %rax
+	incq	(%rax)
+	jmp	.L6
+.L5:
+# 	movl	$_DYNAMIC, %eax
+# 	testq	%rax, %rax
+# 	je	.L11
+# 	movq	-16(%rbp), %rdi
+# 	call	atexit
+.L11:
+# 	movl	$_fini, %edi
+# 	call	atexit
+#	call	_init
+#	movq	-40(%rbp), %rdx    #env
+#	movq	-32(%rbp), %rsi  #argv
+#	movl	-20(%rbp), %edi  # argc
+	xorq    %rbp,%rbp
+	call	main
+	movl	%eax, %edi
+#       call	exit
+.LFE9:
+	.size	_start, .-_start
+
+.bss
+        .type   __stkptr,@object
+        .size   __stkptr,8
+        .global __stkptr
+__stkptr:
+        .skip   8
+
+        .type operatingsystem_parameters,@object
+        .size operatingsystem_parameters,24
+operatingsystem_parameters:
+        .skip 3*8
+
+        .global operatingsystem_parameter_envp
+        .global operatingsystem_parameter_argc
+        .global operatingsystem_parameter_argv
+        .set operatingsystem_parameter_envp,operatingsystem_parameters+0
+        .set operatingsystem_parameter_argc,operatingsystem_parameters+8
+        .set operatingsystem_parameter_argv,operatingsystem_parameters+16
+
+
+	.comm	environ,8,8
+	.weak	_DYNAMIC
+	.section	.eh_frame,"a",@progbits
+.Lframe1:
+	.long	.LECIE1-.LSCIE1
+.LSCIE1:
+	.long	0x0
+	.byte	0x1
+	.string	""
+	.uleb128 0x1
+	.sleb128 -8
+	.byte	0x10
+	.byte	0xc
+	.uleb128 0x7
+	.uleb128 0x8
+	.byte	0x90
+	.uleb128 0x1
+	.p2align 3
+.LECIE1:
+.LSFDE1:
+	.long	.LEFDE1-.LASFDE1
+.LASFDE1:
+	.long	.LASFDE1-.Lframe1
+	.quad	.LFB9
+	.quad	.LFE9-.LFB9
+	.byte	0x4
+	.long	.LCFI0-.LFB9
+	.byte	0xe
+	.uleb128 0x10
+	.byte	0x86
+	.uleb128 0x2
+	.byte	0x4
+	.long	.LCFI1-.LCFI0
+	.byte	0xd
+	.uleb128 0x6
+	.p2align 3
+.LEFDE1:
+	.ident	"[DragonFly]"
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/si_c.inc rtl/dragonfly/x86_64/si_c.inc
--- rtl/dragonfly.null/x86_64/si_c.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/si_c.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,92 @@
+
+Type
+    TCleanup = procedure; cdecl;
+
+var 
+  environ : ppchar; cvar; public  name '__environ';
+  progname: pchar = #0#0; cvar; public name '__progname';
+  dynamic : pchar;  external name '_DYNAMIC'; // #pragma weak
+
+procedure atexit(prc:TCleanup); cdecl external name 'atexit';
+procedure cleanup(prc:TCleanup); cdecl external name 'cleanup';			
+procedure init_tls; cdecl; external name 'init_tls';
+procedure fini; cdecl; external name '_fini';
+procedure init; cdecl; external name '_init';
+procedure libc_exit(exitcode:longint);cdecl; external name 'exit';
+function  main(nrarg:longint;pp:ppchar;env:ppchar):longint; cdecl; external name 'main';
+
+{$ifdef gcrt}
+ procedure cmcleanup; cdecl; external name '_mcleanup';
+ procedure monstratup(p,p2:pointer); cdecl; external name 'monstartup';
+
+var 
+ eprol:longint; external name 'eprol'; 
+ etext:longint; external name 'etext';
+{$endif}
+
+procedure start(ap:ppchar;cleanup:TCleanup);
+
+var argc: longint;
+    argv: ppchar;
+    env : ppchar;
+    s   : pchar;
+begin
+  argc:=plongint(ap)^; 
+  argv:=ppchar(ap[1]);
+  env:=	ppchar(ap[2+argc]);
+  environ:=env;
+  if (argc>0) and (argv[0]<>#0) Then
+   begin
+     progname:=argv[0];
+     s:=progname;
+     while s^<>#0 do
+        begin
+          if s^='/' then
+            progname:=@s[1];
+          inc(s);
+	end; 
+    end;
+  if assigned(pchar(@dynamic)) then // I suspect this is a trick to find
+				    // out runtime if we are shared
+				    // linking, so the same code can be used
+				    // for static and shared linking
+    atexit(cleanup)
+  else
+    init_tls;
+  {$ifdef GCRT}
+    atexit(@_mcleanup);
+  {$endif}
+  atexit(@fini);
+  {$ifdef GCRT}
+    monstartup(@eprol,@etext);
+  {$endif} 
+  init;
+  {$ifdef GCRT}
+   asm
+    eprol:
+   end;
+  {$endif} 
+
+  libc_exit(main(argc,argv,env)); // doesn't return
+ asm
+     { We need this stuff to make gdb behave itself, otherwise
+      gdb will chokes with SIGILL when trying to debug apps.
+    }
+    .section ".note.ABI-tag", "a"
+    .align 4
+    .long 10
+    .long 4 
+    .long  1
+    .asciz "DragonFly"
+    .align 4
+    .long	400000
+    .align 4
+    .section	.note.GNU-stack,"",@progbits
+  end;
+end;
+
+
+
+begin
+end.
+
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/sighnd.inc rtl/dragonfly/x86_64/sighnd.inc
--- rtl/dragonfly.null/x86_64/sighnd.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/sighnd.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,54 @@
+{
+   This file is part of the Free Pascal run time library.
+   (c) 2000-2003 by Marco van de Voort
+   member of the Free Pascal development team.
+
+   See the file COPYING.FPC, included in this distribution,
+   for details about the copyright.
+
+   Signalhandler for DragonFly
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY;without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+}
+
+procedure SignalToRunerror(Sig: cint; info : psiginfo;  SigContext:PSigContext); public name '_FPC_DEFAULTSIGHANDLER'; cdecl;
+
+var
+  res : word;
+
+begin
+  res:=0;
+  case sig of
+    SIGFPE :
+          begin
+            Case Info^.si_code Of
+                FPE_INTDIV : Res:=200;  {integer divide fault. Div0?}
+                FPE_FLTOVF : Res:=205;  {Overflow trap}
+                FPE_FLTUND : Res:=206;  {Stack over/underflow}
+                FPE_FLTRES : Res:=216;  {Device not available}
+                FPE_FLTINV : Res:=216;  {Invalid floating point operation}
+               Else
+                Res:=208; {coprocessor error}
+                End;
+             sysResetFPU;
+          End;
+    SIGILL,
+    SIGBUS,
+    SIGSEGV :
+        res:=216;
+    SIGINT:
+        res:=217;
+    SIGQUIT:
+        res:=233;
+  end;
+  {$ifdef FPC_USE_SIGPROCMASK}
+   reenable_signal(sig);
+  {$endif }
+{ give runtime error at the position where the signal was raised }
+  if res<>0 then
+   begin
+     HandleError(res);
+   end;
+end;
diff -ur --unidirectional-new-file rtl/dragonfly.null/x86_64/signal.inc rtl/dragonfly/x86_64/signal.inc
--- rtl/dragonfly.null/x86_64/signal.inc	1970-01-01 01:00:00.000000000 +0100
+++ rtl/dragonfly/x86_64/signal.inc	2014-11-18 16:53:27.000000000 +0100
@@ -0,0 +1,201 @@
+{
+    This file is part of the Free Pascal run time library.
+    Copyright (c) 1999-2000 by Jonas Maebe,
+    member of the Free Pascal development team.
+
+    See the file COPYING.FPC, included in this distribution,
+    for details about the copyright.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+ **********************************************************************}
+
+
+Const   { For sending a signal }
+
+  SA_NOCLDSTOP = 8;
+  SA_ONSTACK   = $001; { take signal on signal stack }
+  SA_RESTART   = $002; { restart system call on signal return }
+  SA_RESETHAND = $004; { reset to SIG_DFL when taking signal }
+  SA_NODEFER   = $010; { don't mask the signal we're delivering }
+  SA_NOCLDWAIT = $020; { don't keep zombies around }
+  SA_SIGINFO   = $040; { signal handler with SA_SIGINFO args }
+
+  SIG_BLOCK   = 1;
+  SIG_UNBLOCK = 2;
+  SIG_SETMASK = 3;
+
+{BSD Checked}
+  SIG_DFL = 0 ;
+  SIG_IGN = 1 ;
+  SIG_ERR = -1 ;
+
+  SIGHUP     = 1;
+  SIGINT     = 2;
+  SIGQUIT    = 3;
+  SIGILL     = 4;
+  SIGTRAP    = 5;
+  SIGABRT    = 6;
+  SIGIOT     = 6;
+  SIGEMT     = 7;
+  SIGFPE     = 8;
+  SIGKILL    = 9;
+  SIGBUS     = 10;
+  SIGSEGV    = 11;
+  SIGSYS     = 12;
+  SIGPIPE    = 13;
+  SIGALRM    = 14;
+  SIGTERM    = 15;
+  SIGURG     = 16;
+  SIGSTOP    = 17;
+  SIGTSTP    = 18;
+  SIGCONT    = 19;
+  SIGCHLD    = 20;
+  SIGTTIN    = 21;
+  SIGTTOU    = 22;
+  SIGIO      = 23;
+  SIGXCPU    = 24;
+  SIGXFSZ    = 25;
+  SIGVTALRM  = 26;
+  SIGPROF    = 27;
+  SIGWINCH   = 28;
+  SIGINFO    = 29;
+  SIGUSR1    = 30;
+  SIGUSR2    = 31;
+
+
+{$packrecords C}
+const
+  SI_PAD_SIZE   = ((128/sizeof(longint)) - 3);
+
+{
+ * The sequence of the fields/registers in struct sigcontext should match
+ * those in mcontext_t.
+ }
+
+type sigset_t = array[0..3] of Longint;
+
+    psigcontext = ^sigcontextrec;
+    PSigContextRec = ^SigContextRec;
+    SigContextRec = record
+       sc_mask      : sigset_t;          { signal mask to restore }
+       sc_onstack   : cint64;              { sigstack state to restore }
+
+       sc_rdi       : cint64;              { machine state (struct trapframe): }
+       sc_rsi       : cint64;
+       sc_rdx       : cint64;
+       sc_rcx       : cint64;
+       sc_r8        : cint64;
+       sc_r9        : cint64;
+       sc_rax       : cint64;
+       sc_rbx       : cint64;
+       sc_rbp       : cint64;
+       sc_r10       : cint64;
+       sc_r11       : cint64;
+       sc_r12       : cint64;
+       sc_r13       : cint64;
+       sc_r14       : cint64;
+       sc_r15       : cint64;
+       sc_xflags    : cint64;
+       sc_trapno    : cint64;
+       sc_addr      : cint64;
+       sc_flags     : cint64;
+       sc_err       : cint64;
+       sc_rip       : cint64;
+       sc_cs        : cint64;
+       sc_rflags    : cint64;
+       sc_rsp       : cint64;
+       sc_ss        : cint64;
+       sc_len       : cuint32;
+       sc_fpformat  : cuint32;
+       sc_ownedfp   : cuint32;
+       sc_reserved  : cuint32;
+       sc_unused    : array[0..7] of cuint32;
+       sc_pregs     : array[0..255] of cuint32;
+    end;
+
+
+
+  Sigval = Record
+            Case Boolean OF
+        { Members as suggested by Annex C of POSIX 1003.1b. }
+                false : (sigval_int : Longint);
+                True  : (sigval_ptr : Pointer);
+            End;
+
+
+  PSigInfo   = ^SigInfo_t;
+  PSigInfo_t = ^SigInfo_t;
+  SigInfo_t = record
+                si_signo,                       { signal number }
+                si_errno,                       { errno association }
+        {
+         * Cause of signal, one of the SI_ macros or signal-specific
+         * values, i.e. one of the FPE_... values for SIGFPE. This
+         * value is equivalent to the second argument to an old-style
+         * FreeBSD signal handler.
+         }
+                si_code,                        { signal code }
+                si_pid          : cint32;       { sending process }
+                si_uid          : cuint32;      { sender's ruid }
+                si_status       : cint32;       { exit value }
+                si_addr         : Pointer;      { faulting instruction }
+                si_value        : SigVal;       { signal value }
+                si_band         : cint32;       { band event for SIGPOLL }
+                __spare         : array[0..6] of cint32; { gimme some slack }
+                end;
+  TSigInfo = SigInfo_t;
+  TSigInfo_t = TSigInfo;
+
+
+
+  SignalHandler    = Procedure(Sig : Longint);cdecl;
+  TSignalHandler   = Procedure(Sig : Longint);cdecl;
+  PSignalHandler   = ^SignalHandler;
+  SignalRestorer   = Procedure;cdecl;
+  PSignalRestorer  = ^SignalRestorer;
+  sigActionHandler = procedure(Sig: Longint; sininfo:psiginfo; SigContext: PSigContext);cdecl;
+
+  TSigset=sigset_t;
+  sigset=tsigset;
+  PSigSet = ^TSigSet;
+
+  SigActionRec = packed record
+{     Handler  : record
+      case byte of
+        0: (Sh: SignalHandler);
+        1: (Sa: TSigAction);
+      end;}
+    sa_handler  : sigActionHandler;
+    Sa_Flags    : Longint;
+    Sa_Mask     : TSigSet;
+  end;
+  PSigActionRec = ^SigActionRec;
+  
+
+  pstack_t = ^stack_t;
+  stack_t = record
+    ss_sp   : pChar;                    {* signal stack base *}
+    ss_size : size_t;                   {* signal stack length *}
+    ss_flags: cint32;                   {* SS_DISABLE and/or SS_ONSTACK *}
+  end;
+  TStack = stack_t;
+  PStack = pstack_t;
+
+{
+  Change action of process upon receipt of a signal.
+  Signum specifies the signal (all except SigKill and SigStop).
+  If Act is non-nil, it is used to specify the new action.
+  If OldAct is non-nil the previous action is saved there.
+}
+const
+        FPE_INTOVF      =1;     { integer overflow }
+        FPE_INTDIV      =2;     { integer divide by zero }
+        FPE_FLTDIV      =3;     { floating point divide by zero }
+        FPE_FLTOVF      =4;     { floating point overflow }
+        FPE_FLTUND      =5;     { floating point underflow }
+        FPE_FLTRES      =6;     { floating point inexact result }
+        FPE_FLTINV      =7;     { invalid floating point operation }
+        FPE_FLTSUB      =8;     { subscript out of range }
